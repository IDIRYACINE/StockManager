type Query {
  aggregateCity(where: CityWhereInput, orderBy: [CityOrderByWithRelationInput!], cursor: CityWhereUniqueInput, take: Int, skip: Int): AggregateCity!
  findFirstCity(where: CityWhereInput, orderBy: [CityOrderByWithRelationInput!], cursor: CityWhereUniqueInput, take: Int, skip: Int, distinct: [CityScalarFieldEnum!]): City
  findFirstCityOrThrow(where: CityWhereInput, orderBy: [CityOrderByWithRelationInput!], cursor: CityWhereUniqueInput, take: Int, skip: Int, distinct: [CityScalarFieldEnum!]): City
  cities(where: CityWhereInput, orderBy: [CityOrderByWithRelationInput!], cursor: CityWhereUniqueInput, take: Int, skip: Int, distinct: [CityScalarFieldEnum!]): [City!]!
  city(where: CityWhereUniqueInput!): City
  getCity(where: CityWhereUniqueInput!): City
  groupByCity(where: CityWhereInput, orderBy: [CityOrderByWithAggregationInput!], by: [CityScalarFieldEnum!]!, having: CityScalarWhereWithAggregatesInput, take: Int, skip: Int): [CityGroupBy!]!
  aggregateColors(where: ColorsWhereInput, orderBy: [ColorsOrderByWithRelationInput!], cursor: ColorsWhereUniqueInput, take: Int, skip: Int): AggregateColors!
  findFirstColors(where: ColorsWhereInput, orderBy: [ColorsOrderByWithRelationInput!], cursor: ColorsWhereUniqueInput, take: Int, skip: Int, distinct: [ColorsScalarFieldEnum!]): Colors
  findFirstColorsOrThrow(where: ColorsWhereInput, orderBy: [ColorsOrderByWithRelationInput!], cursor: ColorsWhereUniqueInput, take: Int, skip: Int, distinct: [ColorsScalarFieldEnum!]): Colors
  findManyColors(where: ColorsWhereInput, orderBy: [ColorsOrderByWithRelationInput!], cursor: ColorsWhereUniqueInput, take: Int, skip: Int, distinct: [ColorsScalarFieldEnum!]): [Colors!]!
  findUniqueColors(where: ColorsWhereUniqueInput!): Colors
  findUniqueColorsOrThrow(where: ColorsWhereUniqueInput!): Colors
  groupByColors(where: ColorsWhereInput, orderBy: [ColorsOrderByWithAggregationInput!], by: [ColorsScalarFieldEnum!]!, having: ColorsScalarWhereWithAggregatesInput, take: Int, skip: Int): [ColorsGroupBy!]!
  aggregatePayements(where: PayementsWhereInput, orderBy: [PayementsOrderByWithRelationInput!], cursor: PayementsWhereUniqueInput, take: Int, skip: Int): AggregatePayements!
  findFirstPayements(where: PayementsWhereInput, orderBy: [PayementsOrderByWithRelationInput!], cursor: PayementsWhereUniqueInput, take: Int, skip: Int, distinct: [PayementsScalarFieldEnum!]): Payements
  findFirstPayementsOrThrow(where: PayementsWhereInput, orderBy: [PayementsOrderByWithRelationInput!], cursor: PayementsWhereUniqueInput, take: Int, skip: Int, distinct: [PayementsScalarFieldEnum!]): Payements
  findManyPayements(where: PayementsWhereInput, orderBy: [PayementsOrderByWithRelationInput!], cursor: PayementsWhereUniqueInput, take: Int, skip: Int, distinct: [PayementsScalarFieldEnum!]): [Payements!]!
  findUniquePayements(where: PayementsWhereUniqueInput!): Payements
  findUniquePayementsOrThrow(where: PayementsWhereUniqueInput!): Payements
  groupByPayements(where: PayementsWhereInput, orderBy: [PayementsOrderByWithAggregationInput!], by: [PayementsScalarFieldEnum!]!, having: PayementsScalarWhereWithAggregatesInput, take: Int, skip: Int): [PayementsGroupBy!]!
  aggregateProductFamily(where: ProductFamilyWhereInput, orderBy: [ProductFamilyOrderByWithRelationInput!], cursor: ProductFamilyWhereUniqueInput, take: Int, skip: Int): AggregateProductFamily!
  findFirstProductFamily(where: ProductFamilyWhereInput, orderBy: [ProductFamilyOrderByWithRelationInput!], cursor: ProductFamilyWhereUniqueInput, take: Int, skip: Int, distinct: [ProductFamilyScalarFieldEnum!]): ProductFamily
  findFirstProductFamilyOrThrow(where: ProductFamilyWhereInput, orderBy: [ProductFamilyOrderByWithRelationInput!], cursor: ProductFamilyWhereUniqueInput, take: Int, skip: Int, distinct: [ProductFamilyScalarFieldEnum!]): ProductFamily
  productFamilies(where: ProductFamilyWhereInput, orderBy: [ProductFamilyOrderByWithRelationInput!], cursor: ProductFamilyWhereUniqueInput, take: Int, skip: Int, distinct: [ProductFamilyScalarFieldEnum!]): [ProductFamily!]!
  productFamily(where: ProductFamilyWhereUniqueInput!): ProductFamily
  getProductFamily(where: ProductFamilyWhereUniqueInput!): ProductFamily
  groupByProductFamily(where: ProductFamilyWhereInput, orderBy: [ProductFamilyOrderByWithAggregationInput!], by: [ProductFamilyScalarFieldEnum!]!, having: ProductFamilyScalarWhereWithAggregatesInput, take: Int, skip: Int): [ProductFamilyGroupBy!]!
  aggregateProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int): AggregateProductModel!
  findFirstProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): ProductModel
  findFirstProductModelOrThrow(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): ProductModel
  productModels(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): [ProductModel!]!
  productModel(where: ProductModelWhereUniqueInput!): ProductModel
  getProductModel(where: ProductModelWhereUniqueInput!): ProductModel
  groupByProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithAggregationInput!], by: [ProductModelScalarFieldEnum!]!, having: ProductModelScalarWhereWithAggregatesInput, take: Int, skip: Int): [ProductModelGroupBy!]!
  aggregateProducts(where: ProductsWhereInput, orderBy: [ProductsOrderByWithRelationInput!], cursor: ProductsWhereUniqueInput, take: Int, skip: Int): AggregateProducts!
  findFirstProducts(where: ProductsWhereInput, orderBy: [ProductsOrderByWithRelationInput!], cursor: ProductsWhereUniqueInput, take: Int, skip: Int, distinct: [ProductsScalarFieldEnum!]): Products
  findFirstProductsOrThrow(where: ProductsWhereInput, orderBy: [ProductsOrderByWithRelationInput!], cursor: ProductsWhereUniqueInput, take: Int, skip: Int, distinct: [ProductsScalarFieldEnum!]): Products
  findManyProducts(where: ProductsWhereInput, orderBy: [ProductsOrderByWithRelationInput!], cursor: ProductsWhereUniqueInput, take: Int, skip: Int, distinct: [ProductsScalarFieldEnum!]): [Products!]!
  findUniqueProducts(where: ProductsWhereUniqueInput!): Products
  findUniqueProductsOrThrow(where: ProductsWhereUniqueInput!): Products
  groupByProducts(where: ProductsWhereInput, orderBy: [ProductsOrderByWithAggregationInput!], by: [ProductsScalarFieldEnum!]!, having: ProductsScalarWhereWithAggregatesInput, take: Int, skip: Int): [ProductsGroupBy!]!
  aggregateSellers(where: SellersWhereInput, orderBy: [SellersOrderByWithRelationInput!], cursor: SellersWhereUniqueInput, take: Int, skip: Int): AggregateSellers!
  findFirstSellers(where: SellersWhereInput, orderBy: [SellersOrderByWithRelationInput!], cursor: SellersWhereUniqueInput, take: Int, skip: Int, distinct: [SellersScalarFieldEnum!]): Sellers
  findFirstSellersOrThrow(where: SellersWhereInput, orderBy: [SellersOrderByWithRelationInput!], cursor: SellersWhereUniqueInput, take: Int, skip: Int, distinct: [SellersScalarFieldEnum!]): Sellers
  findManySellers(where: SellersWhereInput, orderBy: [SellersOrderByWithRelationInput!], cursor: SellersWhereUniqueInput, take: Int, skip: Int, distinct: [SellersScalarFieldEnum!]): [Sellers!]!
  findUniqueSellers(where: SellersWhereUniqueInput!): Sellers
  findUniqueSellersOrThrow(where: SellersWhereUniqueInput!): Sellers
  groupBySellers(where: SellersWhereInput, orderBy: [SellersOrderByWithAggregationInput!], by: [SellersScalarFieldEnum!]!, having: SellersScalarWhereWithAggregatesInput, take: Int, skip: Int): [SellersGroupBy!]!
  aggregateSizes(where: SizesWhereInput, orderBy: [SizesOrderByWithRelationInput!], cursor: SizesWhereUniqueInput, take: Int, skip: Int): AggregateSizes!
  findFirstSizes(where: SizesWhereInput, orderBy: [SizesOrderByWithRelationInput!], cursor: SizesWhereUniqueInput, take: Int, skip: Int, distinct: [SizesScalarFieldEnum!]): Sizes
  findFirstSizesOrThrow(where: SizesWhereInput, orderBy: [SizesOrderByWithRelationInput!], cursor: SizesWhereUniqueInput, take: Int, skip: Int, distinct: [SizesScalarFieldEnum!]): Sizes
  findManySizes(where: SizesWhereInput, orderBy: [SizesOrderByWithRelationInput!], cursor: SizesWhereUniqueInput, take: Int, skip: Int, distinct: [SizesScalarFieldEnum!]): [Sizes!]!
  findUniqueSizes(where: SizesWhereUniqueInput!): Sizes
  findUniqueSizesOrThrow(where: SizesWhereUniqueInput!): Sizes
  groupBySizes(where: SizesWhereInput, orderBy: [SizesOrderByWithAggregationInput!], by: [SizesScalarFieldEnum!]!, having: SizesScalarWhereWithAggregatesInput, take: Int, skip: Int): [SizesGroupBy!]!
  aggregateTransactionProduct(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithRelationInput!], cursor: TransactionProductWhereUniqueInput, take: Int, skip: Int): AggregateTransactionProduct!
  findFirstTransactionProduct(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithRelationInput!], cursor: TransactionProductWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionProductScalarFieldEnum!]): TransactionProduct
  findFirstTransactionProductOrThrow(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithRelationInput!], cursor: TransactionProductWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionProductScalarFieldEnum!]): TransactionProduct
  transactionProducts(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithRelationInput!], cursor: TransactionProductWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionProductScalarFieldEnum!]): [TransactionProduct!]!
  transactionProduct(where: TransactionProductWhereUniqueInput!): TransactionProduct
  getTransactionProduct(where: TransactionProductWhereUniqueInput!): TransactionProduct
  groupByTransactionProduct(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithAggregationInput!], by: [TransactionProductScalarFieldEnum!]!, having: TransactionProductScalarWhereWithAggregatesInput, take: Int, skip: Int): [TransactionProductGroupBy!]!
  aggregateTransactionStatus(where: TransactionStatusWhereInput, orderBy: [TransactionStatusOrderByWithRelationInput!], cursor: TransactionStatusWhereUniqueInput, take: Int, skip: Int): AggregateTransactionStatus!
  findFirstTransactionStatus(where: TransactionStatusWhereInput, orderBy: [TransactionStatusOrderByWithRelationInput!], cursor: TransactionStatusWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionStatusScalarFieldEnum!]): TransactionStatus
  findFirstTransactionStatusOrThrow(where: TransactionStatusWhereInput, orderBy: [TransactionStatusOrderByWithRelationInput!], cursor: TransactionStatusWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionStatusScalarFieldEnum!]): TransactionStatus
  transactionStatuses(where: TransactionStatusWhereInput, orderBy: [TransactionStatusOrderByWithRelationInput!], cursor: TransactionStatusWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionStatusScalarFieldEnum!]): [TransactionStatus!]!
  transactionStatus(where: TransactionStatusWhereUniqueInput!): TransactionStatus
  getTransactionStatus(where: TransactionStatusWhereUniqueInput!): TransactionStatus
  groupByTransactionStatus(where: TransactionStatusWhereInput, orderBy: [TransactionStatusOrderByWithAggregationInput!], by: [TransactionStatusScalarFieldEnum!]!, having: TransactionStatusScalarWhereWithAggregatesInput, take: Int, skip: Int): [TransactionStatusGroupBy!]!
  aggregateTransactionTypes(where: TransactionTypesWhereInput, orderBy: [TransactionTypesOrderByWithRelationInput!], cursor: TransactionTypesWhereUniqueInput, take: Int, skip: Int): AggregateTransactionTypes!
  findFirstTransactionTypes(where: TransactionTypesWhereInput, orderBy: [TransactionTypesOrderByWithRelationInput!], cursor: TransactionTypesWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionTypesScalarFieldEnum!]): TransactionTypes
  findFirstTransactionTypesOrThrow(where: TransactionTypesWhereInput, orderBy: [TransactionTypesOrderByWithRelationInput!], cursor: TransactionTypesWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionTypesScalarFieldEnum!]): TransactionTypes
  findManyTransactionTypes(where: TransactionTypesWhereInput, orderBy: [TransactionTypesOrderByWithRelationInput!], cursor: TransactionTypesWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionTypesScalarFieldEnum!]): [TransactionTypes!]!
  findUniqueTransactionTypes(where: TransactionTypesWhereUniqueInput!): TransactionTypes
  findUniqueTransactionTypesOrThrow(where: TransactionTypesWhereUniqueInput!): TransactionTypes
  groupByTransactionTypes(where: TransactionTypesWhereInput, orderBy: [TransactionTypesOrderByWithAggregationInput!], by: [TransactionTypesScalarFieldEnum!]!, having: TransactionTypesScalarWhereWithAggregatesInput, take: Int, skip: Int): [TransactionTypesGroupBy!]!
  aggregateTransactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int): AggregateTransactions!
  findFirstTransactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): Transactions
  findFirstTransactionsOrThrow(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): Transactions
  findManyTransactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): [Transactions!]!
  findUniqueTransactions(where: TransactionsWhereUniqueInput!): Transactions
  findUniqueTransactionsOrThrow(where: TransactionsWhereUniqueInput!): Transactions
  groupByTransactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithAggregationInput!], by: [TransactionsScalarFieldEnum!]!, having: TransactionsScalarWhereWithAggregatesInput, take: Int, skip: Int): [TransactionsGroupBy!]!
}

type AggregateCity {
  _count: CityCountAggregate
  _avg: CityAvgAggregate
  _sum: CitySumAggregate
  _min: CityMinAggregate
  _max: CityMaxAggregate
}

type CityCountAggregate {
  city_id: Int!
  city_name: Int!
  _all: Int!
}

type CityAvgAggregate {
  city_id: Float
}

type CitySumAggregate {
  city_id: Int
}

type CityMinAggregate {
  city_id: Int
  city_name: String
}

type CityMaxAggregate {
  city_id: Int
  city_name: String
}

input CityWhereInput {
  AND: [CityWhereInput!]
  OR: [CityWhereInput!]
  NOT: [CityWhereInput!]
  city_id: IntFilter
  city_name: StringFilter
  Transactions: TransactionsListRelationFilter
}

input IntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input NestedIntFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntFilter
}

input StringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input NestedStringFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringFilter
}

input TransactionsListRelationFilter {
  every: TransactionsWhereInput
  some: TransactionsWhereInput
  none: TransactionsWhereInput
}

input TransactionsWhereInput {
  AND: [TransactionsWhereInput!]
  OR: [TransactionsWhereInput!]
  NOT: [TransactionsWhereInput!]
  transaction_id: IntFilter
  seller_id: IntFilter
  product_id: IntFilter
  customer_name: StringFilter
  customer_phone: StringFilter
  city_id: IntFilter
  address: StringFilter
  quantity: IntFilter
  date: DateTimeFilter
  remainingPayement: FloatFilter
  totalPayement: FloatFilter
  seller: SellersRelationFilter
  city: CityRelationFilter
  transaction_type_id: IntFilter
  transaction_type: TransactionTypesRelationFilter
  status_id: IntFilter
  status: TransactionStatusRelationFilter
  Payements: PayementsListRelationFilter
}

input DateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input NestedDateTimeFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeFilter
}

input FloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input NestedFloatFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatFilter
}

input SellersRelationFilter {
  is: SellersWhereInput
  isNot: SellersWhereInput
}

input SellersWhereInput {
  AND: [SellersWhereInput!]
  OR: [SellersWhereInput!]
  NOT: [SellersWhereInput!]
  seller_id: IntFilter
  seller_name: StringFilter
  seller_phone: StringFilter
  picture: StringFilter
  Transactions: TransactionsListRelationFilter
}

input CityRelationFilter {
  is: CityWhereInput
  isNot: CityWhereInput
}

input TransactionTypesRelationFilter {
  is: TransactionTypesWhereInput
  isNot: TransactionTypesWhereInput
}

input TransactionTypesWhereInput {
  AND: [TransactionTypesWhereInput!]
  OR: [TransactionTypesWhereInput!]
  NOT: [TransactionTypesWhereInput!]
  transaction_type_id: IntFilter
  type_name: StringFilter
  description: StringFilter
  Transactions: TransactionsListRelationFilter
}

input TransactionStatusRelationFilter {
  is: TransactionStatusWhereInput
  isNot: TransactionStatusWhereInput
}

input TransactionStatusWhereInput {
  AND: [TransactionStatusWhereInput!]
  OR: [TransactionStatusWhereInput!]
  NOT: [TransactionStatusWhereInput!]
  transaction_status_id: IntFilter
  name: StringFilter
  description: StringFilter
  Transactions: TransactionsListRelationFilter
}

input PayementsListRelationFilter {
  every: PayementsWhereInput
  some: PayementsWhereInput
  none: PayementsWhereInput
}

input PayementsWhereInput {
  AND: [PayementsWhereInput!]
  OR: [PayementsWhereInput!]
  NOT: [PayementsWhereInput!]
  payement_id: IntFilter
  transaction_id: IntFilter
  payement: FloatFilter
  transaction: TransactionsRelationFilter
}

input TransactionsRelationFilter {
  is: TransactionsWhereInput
  isNot: TransactionsWhereInput
}

input CityOrderByWithRelationInput {
  city_id: SortOrder
  city_name: SortOrder
  Transactions: TransactionsOrderByRelationAggregateInput
}

enum SortOrder {
  asc
  desc
}

input TransactionsOrderByRelationAggregateInput {
  _count: SortOrder
}

input CityWhereUniqueInput {
  city_id: Int
}

type City {
  city_id: Int!
  city_name: String!
  _count: CityCount
  Transactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): [Transactions!]!
}

type CityCount {
  Transactions: Int!
}

type Transactions {
  transaction_id: Int!
  seller_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  city_id: Int!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  transaction_type_id: Int!
  status_id: Int!
  _count: TransactionsCount
  seller: Sellers!
  city: City!
  transaction_type: TransactionTypes!
  status: TransactionStatus!
  Payements(where: PayementsWhereInput, orderBy: [PayementsOrderByWithRelationInput!], cursor: PayementsWhereUniqueInput, take: Int, skip: Int, distinct: [PayementsScalarFieldEnum!]): [Payements!]!
}

type TransactionsCount {
  Payements: Int!
}

type Sellers {
  seller_id: Int!
  seller_name: String!
  seller_phone: String!
  picture: String!
  _count: SellersCount
  Transactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): [Transactions!]!
}

type SellersCount {
  Transactions: Int!
}

input TransactionsOrderByWithRelationInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  customer_name: SortOrder
  customer_phone: SortOrder
  city_id: SortOrder
  address: SortOrder
  quantity: SortOrder
  date: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  seller: SellersOrderByWithRelationInput
  city: CityOrderByWithRelationInput
  transaction_type_id: SortOrder
  transaction_type: TransactionTypesOrderByWithRelationInput
  status_id: SortOrder
  status: TransactionStatusOrderByWithRelationInput
  Payements: PayementsOrderByRelationAggregateInput
}

input SellersOrderByWithRelationInput {
  seller_id: SortOrder
  seller_name: SortOrder
  seller_phone: SortOrder
  picture: SortOrder
  Transactions: TransactionsOrderByRelationAggregateInput
}

input TransactionTypesOrderByWithRelationInput {
  transaction_type_id: SortOrder
  type_name: SortOrder
  description: SortOrder
  Transactions: TransactionsOrderByRelationAggregateInput
}

input TransactionStatusOrderByWithRelationInput {
  transaction_status_id: SortOrder
  name: SortOrder
  description: SortOrder
  Transactions: TransactionsOrderByRelationAggregateInput
}

input PayementsOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransactionsWhereUniqueInput {
  transaction_id: Int
}

enum TransactionsScalarFieldEnum {
  transaction_id
  seller_id
  product_id
  customer_name
  customer_phone
  city_id
  address
  quantity
  date
  remainingPayement
  totalPayement
  transaction_type_id
  status_id
}

type TransactionTypes {
  transaction_type_id: Int!
  type_name: String!
  description: String!
  _count: TransactionTypesCount
  Transactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): [Transactions!]!
}

type TransactionTypesCount {
  Transactions: Int!
}

type TransactionStatus {
  transaction_status_id: Int!
  name: String!
  description: String!
  _count: TransactionStatusCount
  Transactions(where: TransactionsWhereInput, orderBy: [TransactionsOrderByWithRelationInput!], cursor: TransactionsWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionsScalarFieldEnum!]): [Transactions!]!
}

type TransactionStatusCount {
  Transactions: Int!
}

type Payements {
  payement_id: Int!
  transaction_id: Int!
  payement: Float!
  transaction: Transactions!
}

input PayementsOrderByWithRelationInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
  transaction: TransactionsOrderByWithRelationInput
}

input PayementsWhereUniqueInput {
  transaction_id_payement_id: PayementsTransaction_idPayement_idCompoundUniqueInput
}

input PayementsTransaction_idPayement_idCompoundUniqueInput {
  transaction_id: Int!
  payement_id: Int!
}

enum PayementsScalarFieldEnum {
  payement_id
  transaction_id
  payement
}

enum CityScalarFieldEnum {
  city_id
  city_name
}

type CityGroupBy {
  city_id: Int!
  city_name: String!
  _count: CityCountAggregate
  _avg: CityAvgAggregate
  _sum: CitySumAggregate
  _min: CityMinAggregate
  _max: CityMaxAggregate
}

input CityOrderByWithAggregationInput {
  city_id: SortOrder
  city_name: SortOrder
  _count: CityCountOrderByAggregateInput
  _avg: CityAvgOrderByAggregateInput
  _max: CityMaxOrderByAggregateInput
  _min: CityMinOrderByAggregateInput
  _sum: CitySumOrderByAggregateInput
}

input CityCountOrderByAggregateInput {
  city_id: SortOrder
  city_name: SortOrder
}

input CityAvgOrderByAggregateInput {
  city_id: SortOrder
}

input CityMaxOrderByAggregateInput {
  city_id: SortOrder
  city_name: SortOrder
}

input CityMinOrderByAggregateInput {
  city_id: SortOrder
  city_name: SortOrder
}

input CitySumOrderByAggregateInput {
  city_id: SortOrder
}

input CityScalarWhereWithAggregatesInput {
  AND: [CityScalarWhereWithAggregatesInput!]
  OR: [CityScalarWhereWithAggregatesInput!]
  NOT: [CityScalarWhereWithAggregatesInput!]
  city_id: IntWithAggregatesFilter
  city_name: StringWithAggregatesFilter
}

input IntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input NestedIntWithAggregatesFilter {
  equals: Int
  in: [Int!]
  notIn: [Int!]
  lt: Int
  lte: Int
  gt: Int
  gte: Int
  not: NestedIntWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedIntFilter
  _min: NestedIntFilter
  _max: NestedIntFilter
}

input StringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

input NestedStringWithAggregatesFilter {
  equals: String
  in: [String!]
  notIn: [String!]
  lt: String
  lte: String
  gt: String
  gte: String
  contains: String
  startsWith: String
  endsWith: String
  not: NestedStringWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedStringFilter
  _max: NestedStringFilter
}

type AggregateColors {
  _count: ColorsCountAggregate
  _avg: ColorsAvgAggregate
  _sum: ColorsSumAggregate
  _min: ColorsMinAggregate
  _max: ColorsMaxAggregate
}

type ColorsCountAggregate {
  id: Int!
  color: Int!
  _all: Int!
}

type ColorsAvgAggregate {
  id: Float
}

type ColorsSumAggregate {
  id: Int
}

type ColorsMinAggregate {
  id: Int
  color: String
}

type ColorsMaxAggregate {
  id: Int
  color: String
}

input ColorsWhereInput {
  AND: [ColorsWhereInput!]
  OR: [ColorsWhereInput!]
  NOT: [ColorsWhereInput!]
  id: IntFilter
  color: StringFilter
  ProductModel: ProductModelListRelationFilter
}

input ProductModelListRelationFilter {
  every: ProductModelWhereInput
  some: ProductModelWhereInput
  none: ProductModelWhereInput
}

input ProductModelWhereInput {
  AND: [ProductModelWhereInput!]
  OR: [ProductModelWhereInput!]
  NOT: [ProductModelWhereInput!]
  product_id: IntFilter
  color_id: IntFilter
  size_id: IntFilter
  quantity: IntFilter
  product: ProductsRelationFilter
  size: SizesRelationFilter
  color: ColorsRelationFilter
}

input ProductsRelationFilter {
  is: ProductsWhereInput
  isNot: ProductsWhereInput
}

input ProductsWhereInput {
  AND: [ProductsWhereInput!]
  OR: [ProductsWhereInput!]
  NOT: [ProductsWhereInput!]
  product_id: IntFilter
  reference: IntFilter
  name: StringFilter
  buyingPrice: FloatFilter
  sellingPrice: FloatFilter
  description: StringFilter
  picture: StringFilter
  family_id: IntFilter
  family: ProductFamilyRelationFilter
  ProductModel: ProductModelListRelationFilter
  TransactionProduct: TransactionProductListRelationFilter
}

input ProductFamilyRelationFilter {
  is: ProductFamilyWhereInput
  isNot: ProductFamilyWhereInput
}

input ProductFamilyWhereInput {
  AND: [ProductFamilyWhereInput!]
  OR: [ProductFamilyWhereInput!]
  NOT: [ProductFamilyWhereInput!]
  id: IntFilter
  name: StringFilter
  Products: ProductsListRelationFilter
}

input ProductsListRelationFilter {
  every: ProductsWhereInput
  some: ProductsWhereInput
  none: ProductsWhereInput
}

input TransactionProductListRelationFilter {
  every: TransactionProductWhereInput
  some: TransactionProductWhereInput
  none: TransactionProductWhereInput
}

input TransactionProductWhereInput {
  AND: [TransactionProductWhereInput!]
  OR: [TransactionProductWhereInput!]
  NOT: [TransactionProductWhereInput!]
  transaction_id: IntFilter
  product_id: IntFilter
  quantity: IntFilter
  price: FloatFilter
  product_name: StringFilter
  product: ProductsRelationFilter
}

input SizesRelationFilter {
  is: SizesWhereInput
  isNot: SizesWhereInput
}

input SizesWhereInput {
  AND: [SizesWhereInput!]
  OR: [SizesWhereInput!]
  NOT: [SizesWhereInput!]
  id: IntFilter
  size: StringFilter
  ProductModel: ProductModelListRelationFilter
}

input ColorsRelationFilter {
  is: ColorsWhereInput
  isNot: ColorsWhereInput
}

input ColorsOrderByWithRelationInput {
  id: SortOrder
  color: SortOrder
  ProductModel: ProductModelOrderByRelationAggregateInput
}

input ProductModelOrderByRelationAggregateInput {
  _count: SortOrder
}

input ColorsWhereUniqueInput {
  id: Int
}

type Colors {
  id: Int!
  color: String!
  _count: ColorsCount
  ProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): [ProductModel!]!
}

type ColorsCount {
  ProductModel: Int!
}

type ProductModel {
  product_id: Int!
  color_id: Int!
  size_id: Int!
  quantity: Int!
  product: Products!
  size: Sizes!
  color: Colors!
}

type Products {
  product_id: Int!
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  family_id: Int!
  _count: ProductsCount
  family: ProductFamily!
  ProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): [ProductModel!]!
  TransactionProduct(where: TransactionProductWhereInput, orderBy: [TransactionProductOrderByWithRelationInput!], cursor: TransactionProductWhereUniqueInput, take: Int, skip: Int, distinct: [TransactionProductScalarFieldEnum!]): [TransactionProduct!]!
}

type ProductsCount {
  ProductModel: Int!
  TransactionProduct: Int!
}

type ProductFamily {
  id: Int!
  name: String!
  _count: ProductFamilyCount
  Products(where: ProductsWhereInput, orderBy: [ProductsOrderByWithRelationInput!], cursor: ProductsWhereUniqueInput, take: Int, skip: Int, distinct: [ProductsScalarFieldEnum!]): [Products!]!
}

type ProductFamilyCount {
  Products: Int!
}

input ProductsOrderByWithRelationInput {
  product_id: SortOrder
  reference: SortOrder
  name: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  description: SortOrder
  picture: SortOrder
  family_id: SortOrder
  family: ProductFamilyOrderByWithRelationInput
  ProductModel: ProductModelOrderByRelationAggregateInput
  TransactionProduct: TransactionProductOrderByRelationAggregateInput
}

input ProductFamilyOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  Products: ProductsOrderByRelationAggregateInput
}

input ProductsOrderByRelationAggregateInput {
  _count: SortOrder
}

input TransactionProductOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductsWhereUniqueInput {
  product_id: Int
}

enum ProductsScalarFieldEnum {
  product_id
  reference
  name
  buyingPrice
  sellingPrice
  description
  picture
  family_id
}

input ProductModelOrderByWithRelationInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
  product: ProductsOrderByWithRelationInput
  size: SizesOrderByWithRelationInput
  color: ColorsOrderByWithRelationInput
}

input SizesOrderByWithRelationInput {
  id: SortOrder
  size: SortOrder
  ProductModel: ProductModelOrderByRelationAggregateInput
}

input ProductModelWhereUniqueInput {
  product_id_color_id_size_id: ProductModelProduct_idColor_idSize_idCompoundUniqueInput
}

input ProductModelProduct_idColor_idSize_idCompoundUniqueInput {
  product_id: Int!
  color_id: Int!
  size_id: Int!
}

enum ProductModelScalarFieldEnum {
  product_id
  color_id
  size_id
  quantity
}

type TransactionProduct {
  transaction_id: Int!
  product_id: Int!
  quantity: Int!
  price: Float!
  product_name: String!
  product: Products!
}

input TransactionProductOrderByWithRelationInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
  product_name: SortOrder
  product: ProductsOrderByWithRelationInput
}

input TransactionProductWhereUniqueInput {
  transaction_id: Int
}

enum TransactionProductScalarFieldEnum {
  transaction_id
  product_id
  quantity
  price
  product_name
}

type Sizes {
  id: Int!
  size: String!
  _count: SizesCount
  ProductModel(where: ProductModelWhereInput, orderBy: [ProductModelOrderByWithRelationInput!], cursor: ProductModelWhereUniqueInput, take: Int, skip: Int, distinct: [ProductModelScalarFieldEnum!]): [ProductModel!]!
}

type SizesCount {
  ProductModel: Int!
}

enum ColorsScalarFieldEnum {
  id
  color
}

type ColorsGroupBy {
  id: Int!
  color: String!
  _count: ColorsCountAggregate
  _avg: ColorsAvgAggregate
  _sum: ColorsSumAggregate
  _min: ColorsMinAggregate
  _max: ColorsMaxAggregate
}

input ColorsOrderByWithAggregationInput {
  id: SortOrder
  color: SortOrder
  _count: ColorsCountOrderByAggregateInput
  _avg: ColorsAvgOrderByAggregateInput
  _max: ColorsMaxOrderByAggregateInput
  _min: ColorsMinOrderByAggregateInput
  _sum: ColorsSumOrderByAggregateInput
}

input ColorsCountOrderByAggregateInput {
  id: SortOrder
  color: SortOrder
}

input ColorsAvgOrderByAggregateInput {
  id: SortOrder
}

input ColorsMaxOrderByAggregateInput {
  id: SortOrder
  color: SortOrder
}

input ColorsMinOrderByAggregateInput {
  id: SortOrder
  color: SortOrder
}

input ColorsSumOrderByAggregateInput {
  id: SortOrder
}

input ColorsScalarWhereWithAggregatesInput {
  AND: [ColorsScalarWhereWithAggregatesInput!]
  OR: [ColorsScalarWhereWithAggregatesInput!]
  NOT: [ColorsScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  color: StringWithAggregatesFilter
}

type AggregatePayements {
  _count: PayementsCountAggregate
  _avg: PayementsAvgAggregate
  _sum: PayementsSumAggregate
  _min: PayementsMinAggregate
  _max: PayementsMaxAggregate
}

type PayementsCountAggregate {
  payement_id: Int!
  transaction_id: Int!
  payement: Int!
  _all: Int!
}

type PayementsAvgAggregate {
  payement_id: Float
  transaction_id: Float
  payement: Float
}

type PayementsSumAggregate {
  payement_id: Int
  transaction_id: Int
  payement: Float
}

type PayementsMinAggregate {
  payement_id: Int
  transaction_id: Int
  payement: Float
}

type PayementsMaxAggregate {
  payement_id: Int
  transaction_id: Int
  payement: Float
}

type PayementsGroupBy {
  payement_id: Int!
  transaction_id: Int!
  payement: Float!
  _count: PayementsCountAggregate
  _avg: PayementsAvgAggregate
  _sum: PayementsSumAggregate
  _min: PayementsMinAggregate
  _max: PayementsMaxAggregate
}

input PayementsOrderByWithAggregationInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
  _count: PayementsCountOrderByAggregateInput
  _avg: PayementsAvgOrderByAggregateInput
  _max: PayementsMaxOrderByAggregateInput
  _min: PayementsMinOrderByAggregateInput
  _sum: PayementsSumOrderByAggregateInput
}

input PayementsCountOrderByAggregateInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
}

input PayementsAvgOrderByAggregateInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
}

input PayementsMaxOrderByAggregateInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
}

input PayementsMinOrderByAggregateInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
}

input PayementsSumOrderByAggregateInput {
  payement_id: SortOrder
  transaction_id: SortOrder
  payement: SortOrder
}

input PayementsScalarWhereWithAggregatesInput {
  AND: [PayementsScalarWhereWithAggregatesInput!]
  OR: [PayementsScalarWhereWithAggregatesInput!]
  NOT: [PayementsScalarWhereWithAggregatesInput!]
  payement_id: IntWithAggregatesFilter
  transaction_id: IntWithAggregatesFilter
  payement: FloatWithAggregatesFilter
}

input FloatWithAggregatesFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedFloatFilter
  _min: NestedFloatFilter
  _max: NestedFloatFilter
}

input NestedFloatWithAggregatesFilter {
  equals: Float
  in: [Float!]
  notIn: [Float!]
  lt: Float
  lte: Float
  gt: Float
  gte: Float
  not: NestedFloatWithAggregatesFilter
  _count: NestedIntFilter
  _avg: NestedFloatFilter
  _sum: NestedFloatFilter
  _min: NestedFloatFilter
  _max: NestedFloatFilter
}

type AggregateProductFamily {
  _count: ProductFamilyCountAggregate
  _avg: ProductFamilyAvgAggregate
  _sum: ProductFamilySumAggregate
  _min: ProductFamilyMinAggregate
  _max: ProductFamilyMaxAggregate
}

type ProductFamilyCountAggregate {
  id: Int!
  name: Int!
  _all: Int!
}

type ProductFamilyAvgAggregate {
  id: Float
}

type ProductFamilySumAggregate {
  id: Int
}

type ProductFamilyMinAggregate {
  id: Int
  name: String
}

type ProductFamilyMaxAggregate {
  id: Int
  name: String
}

input ProductFamilyWhereUniqueInput {
  id: Int
}

enum ProductFamilyScalarFieldEnum {
  id
  name
}

type ProductFamilyGroupBy {
  id: Int!
  name: String!
  _count: ProductFamilyCountAggregate
  _avg: ProductFamilyAvgAggregate
  _sum: ProductFamilySumAggregate
  _min: ProductFamilyMinAggregate
  _max: ProductFamilyMaxAggregate
}

input ProductFamilyOrderByWithAggregationInput {
  id: SortOrder
  name: SortOrder
  _count: ProductFamilyCountOrderByAggregateInput
  _avg: ProductFamilyAvgOrderByAggregateInput
  _max: ProductFamilyMaxOrderByAggregateInput
  _min: ProductFamilyMinOrderByAggregateInput
  _sum: ProductFamilySumOrderByAggregateInput
}

input ProductFamilyCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input ProductFamilyAvgOrderByAggregateInput {
  id: SortOrder
}

input ProductFamilyMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input ProductFamilyMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
}

input ProductFamilySumOrderByAggregateInput {
  id: SortOrder
}

input ProductFamilyScalarWhereWithAggregatesInput {
  AND: [ProductFamilyScalarWhereWithAggregatesInput!]
  OR: [ProductFamilyScalarWhereWithAggregatesInput!]
  NOT: [ProductFamilyScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
}

type AggregateProductModel {
  _count: ProductModelCountAggregate
  _avg: ProductModelAvgAggregate
  _sum: ProductModelSumAggregate
  _min: ProductModelMinAggregate
  _max: ProductModelMaxAggregate
}

type ProductModelCountAggregate {
  product_id: Int!
  color_id: Int!
  size_id: Int!
  quantity: Int!
  _all: Int!
}

type ProductModelAvgAggregate {
  product_id: Float
  color_id: Float
  size_id: Float
  quantity: Float
}

type ProductModelSumAggregate {
  product_id: Int
  color_id: Int
  size_id: Int
  quantity: Int
}

type ProductModelMinAggregate {
  product_id: Int
  color_id: Int
  size_id: Int
  quantity: Int
}

type ProductModelMaxAggregate {
  product_id: Int
  color_id: Int
  size_id: Int
  quantity: Int
}

type ProductModelGroupBy {
  product_id: Int!
  color_id: Int!
  size_id: Int!
  quantity: Int!
  _count: ProductModelCountAggregate
  _avg: ProductModelAvgAggregate
  _sum: ProductModelSumAggregate
  _min: ProductModelMinAggregate
  _max: ProductModelMaxAggregate
}

input ProductModelOrderByWithAggregationInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
  _count: ProductModelCountOrderByAggregateInput
  _avg: ProductModelAvgOrderByAggregateInput
  _max: ProductModelMaxOrderByAggregateInput
  _min: ProductModelMinOrderByAggregateInput
  _sum: ProductModelSumOrderByAggregateInput
}

input ProductModelCountOrderByAggregateInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
}

input ProductModelAvgOrderByAggregateInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
}

input ProductModelMaxOrderByAggregateInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
}

input ProductModelMinOrderByAggregateInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
}

input ProductModelSumOrderByAggregateInput {
  product_id: SortOrder
  color_id: SortOrder
  size_id: SortOrder
  quantity: SortOrder
}

input ProductModelScalarWhereWithAggregatesInput {
  AND: [ProductModelScalarWhereWithAggregatesInput!]
  OR: [ProductModelScalarWhereWithAggregatesInput!]
  NOT: [ProductModelScalarWhereWithAggregatesInput!]
  product_id: IntWithAggregatesFilter
  color_id: IntWithAggregatesFilter
  size_id: IntWithAggregatesFilter
  quantity: IntWithAggregatesFilter
}

type AggregateProducts {
  _count: ProductsCountAggregate
  _avg: ProductsAvgAggregate
  _sum: ProductsSumAggregate
  _min: ProductsMinAggregate
  _max: ProductsMaxAggregate
}

type ProductsCountAggregate {
  product_id: Int!
  reference: Int!
  name: Int!
  buyingPrice: Int!
  sellingPrice: Int!
  description: Int!
  picture: Int!
  family_id: Int!
  _all: Int!
}

type ProductsAvgAggregate {
  product_id: Float
  reference: Float
  buyingPrice: Float
  sellingPrice: Float
  family_id: Float
}

type ProductsSumAggregate {
  product_id: Int
  reference: Int
  buyingPrice: Float
  sellingPrice: Float
  family_id: Int
}

type ProductsMinAggregate {
  product_id: Int
  reference: Int
  name: String
  buyingPrice: Float
  sellingPrice: Float
  description: String
  picture: String
  family_id: Int
}

type ProductsMaxAggregate {
  product_id: Int
  reference: Int
  name: String
  buyingPrice: Float
  sellingPrice: Float
  description: String
  picture: String
  family_id: Int
}

type ProductsGroupBy {
  product_id: Int!
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  family_id: Int!
  _count: ProductsCountAggregate
  _avg: ProductsAvgAggregate
  _sum: ProductsSumAggregate
  _min: ProductsMinAggregate
  _max: ProductsMaxAggregate
}

input ProductsOrderByWithAggregationInput {
  product_id: SortOrder
  reference: SortOrder
  name: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  description: SortOrder
  picture: SortOrder
  family_id: SortOrder
  _count: ProductsCountOrderByAggregateInput
  _avg: ProductsAvgOrderByAggregateInput
  _max: ProductsMaxOrderByAggregateInput
  _min: ProductsMinOrderByAggregateInput
  _sum: ProductsSumOrderByAggregateInput
}

input ProductsCountOrderByAggregateInput {
  product_id: SortOrder
  reference: SortOrder
  name: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  description: SortOrder
  picture: SortOrder
  family_id: SortOrder
}

input ProductsAvgOrderByAggregateInput {
  product_id: SortOrder
  reference: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  family_id: SortOrder
}

input ProductsMaxOrderByAggregateInput {
  product_id: SortOrder
  reference: SortOrder
  name: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  description: SortOrder
  picture: SortOrder
  family_id: SortOrder
}

input ProductsMinOrderByAggregateInput {
  product_id: SortOrder
  reference: SortOrder
  name: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  description: SortOrder
  picture: SortOrder
  family_id: SortOrder
}

input ProductsSumOrderByAggregateInput {
  product_id: SortOrder
  reference: SortOrder
  buyingPrice: SortOrder
  sellingPrice: SortOrder
  family_id: SortOrder
}

input ProductsScalarWhereWithAggregatesInput {
  AND: [ProductsScalarWhereWithAggregatesInput!]
  OR: [ProductsScalarWhereWithAggregatesInput!]
  NOT: [ProductsScalarWhereWithAggregatesInput!]
  product_id: IntWithAggregatesFilter
  reference: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  buyingPrice: FloatWithAggregatesFilter
  sellingPrice: FloatWithAggregatesFilter
  description: StringWithAggregatesFilter
  picture: StringWithAggregatesFilter
  family_id: IntWithAggregatesFilter
}

type AggregateSellers {
  _count: SellersCountAggregate
  _avg: SellersAvgAggregate
  _sum: SellersSumAggregate
  _min: SellersMinAggregate
  _max: SellersMaxAggregate
}

type SellersCountAggregate {
  seller_id: Int!
  seller_name: Int!
  seller_phone: Int!
  picture: Int!
  _all: Int!
}

type SellersAvgAggregate {
  seller_id: Float
}

type SellersSumAggregate {
  seller_id: Int
}

type SellersMinAggregate {
  seller_id: Int
  seller_name: String
  seller_phone: String
  picture: String
}

type SellersMaxAggregate {
  seller_id: Int
  seller_name: String
  seller_phone: String
  picture: String
}

input SellersWhereUniqueInput {
  seller_id: Int
}

enum SellersScalarFieldEnum {
  seller_id
  seller_name
  seller_phone
  picture
}

type SellersGroupBy {
  seller_id: Int!
  seller_name: String!
  seller_phone: String!
  picture: String!
  _count: SellersCountAggregate
  _avg: SellersAvgAggregate
  _sum: SellersSumAggregate
  _min: SellersMinAggregate
  _max: SellersMaxAggregate
}

input SellersOrderByWithAggregationInput {
  seller_id: SortOrder
  seller_name: SortOrder
  seller_phone: SortOrder
  picture: SortOrder
  _count: SellersCountOrderByAggregateInput
  _avg: SellersAvgOrderByAggregateInput
  _max: SellersMaxOrderByAggregateInput
  _min: SellersMinOrderByAggregateInput
  _sum: SellersSumOrderByAggregateInput
}

input SellersCountOrderByAggregateInput {
  seller_id: SortOrder
  seller_name: SortOrder
  seller_phone: SortOrder
  picture: SortOrder
}

input SellersAvgOrderByAggregateInput {
  seller_id: SortOrder
}

input SellersMaxOrderByAggregateInput {
  seller_id: SortOrder
  seller_name: SortOrder
  seller_phone: SortOrder
  picture: SortOrder
}

input SellersMinOrderByAggregateInput {
  seller_id: SortOrder
  seller_name: SortOrder
  seller_phone: SortOrder
  picture: SortOrder
}

input SellersSumOrderByAggregateInput {
  seller_id: SortOrder
}

input SellersScalarWhereWithAggregatesInput {
  AND: [SellersScalarWhereWithAggregatesInput!]
  OR: [SellersScalarWhereWithAggregatesInput!]
  NOT: [SellersScalarWhereWithAggregatesInput!]
  seller_id: IntWithAggregatesFilter
  seller_name: StringWithAggregatesFilter
  seller_phone: StringWithAggregatesFilter
  picture: StringWithAggregatesFilter
}

type AggregateSizes {
  _count: SizesCountAggregate
  _avg: SizesAvgAggregate
  _sum: SizesSumAggregate
  _min: SizesMinAggregate
  _max: SizesMaxAggregate
}

type SizesCountAggregate {
  id: Int!
  size: Int!
  _all: Int!
}

type SizesAvgAggregate {
  id: Float
}

type SizesSumAggregate {
  id: Int
}

type SizesMinAggregate {
  id: Int
  size: String
}

type SizesMaxAggregate {
  id: Int
  size: String
}

input SizesWhereUniqueInput {
  id: Int
}

enum SizesScalarFieldEnum {
  id
  size
}

type SizesGroupBy {
  id: Int!
  size: String!
  _count: SizesCountAggregate
  _avg: SizesAvgAggregate
  _sum: SizesSumAggregate
  _min: SizesMinAggregate
  _max: SizesMaxAggregate
}

input SizesOrderByWithAggregationInput {
  id: SortOrder
  size: SortOrder
  _count: SizesCountOrderByAggregateInput
  _avg: SizesAvgOrderByAggregateInput
  _max: SizesMaxOrderByAggregateInput
  _min: SizesMinOrderByAggregateInput
  _sum: SizesSumOrderByAggregateInput
}

input SizesCountOrderByAggregateInput {
  id: SortOrder
  size: SortOrder
}

input SizesAvgOrderByAggregateInput {
  id: SortOrder
}

input SizesMaxOrderByAggregateInput {
  id: SortOrder
  size: SortOrder
}

input SizesMinOrderByAggregateInput {
  id: SortOrder
  size: SortOrder
}

input SizesSumOrderByAggregateInput {
  id: SortOrder
}

input SizesScalarWhereWithAggregatesInput {
  AND: [SizesScalarWhereWithAggregatesInput!]
  OR: [SizesScalarWhereWithAggregatesInput!]
  NOT: [SizesScalarWhereWithAggregatesInput!]
  id: IntWithAggregatesFilter
  size: StringWithAggregatesFilter
}

type AggregateTransactionProduct {
  _count: TransactionProductCountAggregate
  _avg: TransactionProductAvgAggregate
  _sum: TransactionProductSumAggregate
  _min: TransactionProductMinAggregate
  _max: TransactionProductMaxAggregate
}

type TransactionProductCountAggregate {
  transaction_id: Int!
  product_id: Int!
  quantity: Int!
  price: Int!
  product_name: Int!
  _all: Int!
}

type TransactionProductAvgAggregate {
  transaction_id: Float
  product_id: Float
  quantity: Float
  price: Float
}

type TransactionProductSumAggregate {
  transaction_id: Int
  product_id: Int
  quantity: Int
  price: Float
}

type TransactionProductMinAggregate {
  transaction_id: Int
  product_id: Int
  quantity: Int
  price: Float
  product_name: String
}

type TransactionProductMaxAggregate {
  transaction_id: Int
  product_id: Int
  quantity: Int
  price: Float
  product_name: String
}

type TransactionProductGroupBy {
  transaction_id: Int!
  product_id: Int!
  quantity: Int!
  price: Float!
  product_name: String!
  _count: TransactionProductCountAggregate
  _avg: TransactionProductAvgAggregate
  _sum: TransactionProductSumAggregate
  _min: TransactionProductMinAggregate
  _max: TransactionProductMaxAggregate
}

input TransactionProductOrderByWithAggregationInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
  product_name: SortOrder
  _count: TransactionProductCountOrderByAggregateInput
  _avg: TransactionProductAvgOrderByAggregateInput
  _max: TransactionProductMaxOrderByAggregateInput
  _min: TransactionProductMinOrderByAggregateInput
  _sum: TransactionProductSumOrderByAggregateInput
}

input TransactionProductCountOrderByAggregateInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
  product_name: SortOrder
}

input TransactionProductAvgOrderByAggregateInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
}

input TransactionProductMaxOrderByAggregateInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
  product_name: SortOrder
}

input TransactionProductMinOrderByAggregateInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
  product_name: SortOrder
}

input TransactionProductSumOrderByAggregateInput {
  transaction_id: SortOrder
  product_id: SortOrder
  quantity: SortOrder
  price: SortOrder
}

input TransactionProductScalarWhereWithAggregatesInput {
  AND: [TransactionProductScalarWhereWithAggregatesInput!]
  OR: [TransactionProductScalarWhereWithAggregatesInput!]
  NOT: [TransactionProductScalarWhereWithAggregatesInput!]
  transaction_id: IntWithAggregatesFilter
  product_id: IntWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  price: FloatWithAggregatesFilter
  product_name: StringWithAggregatesFilter
}

type AggregateTransactionStatus {
  _count: TransactionStatusCountAggregate
  _avg: TransactionStatusAvgAggregate
  _sum: TransactionStatusSumAggregate
  _min: TransactionStatusMinAggregate
  _max: TransactionStatusMaxAggregate
}

type TransactionStatusCountAggregate {
  transaction_status_id: Int!
  name: Int!
  description: Int!
  _all: Int!
}

type TransactionStatusAvgAggregate {
  transaction_status_id: Float
}

type TransactionStatusSumAggregate {
  transaction_status_id: Int
}

type TransactionStatusMinAggregate {
  transaction_status_id: Int
  name: String
  description: String
}

type TransactionStatusMaxAggregate {
  transaction_status_id: Int
  name: String
  description: String
}

input TransactionStatusWhereUniqueInput {
  transaction_status_id: Int
}

enum TransactionStatusScalarFieldEnum {
  transaction_status_id
  name
  description
}

type TransactionStatusGroupBy {
  transaction_status_id: Int!
  name: String!
  description: String!
  _count: TransactionStatusCountAggregate
  _avg: TransactionStatusAvgAggregate
  _sum: TransactionStatusSumAggregate
  _min: TransactionStatusMinAggregate
  _max: TransactionStatusMaxAggregate
}

input TransactionStatusOrderByWithAggregationInput {
  transaction_status_id: SortOrder
  name: SortOrder
  description: SortOrder
  _count: TransactionStatusCountOrderByAggregateInput
  _avg: TransactionStatusAvgOrderByAggregateInput
  _max: TransactionStatusMaxOrderByAggregateInput
  _min: TransactionStatusMinOrderByAggregateInput
  _sum: TransactionStatusSumOrderByAggregateInput
}

input TransactionStatusCountOrderByAggregateInput {
  transaction_status_id: SortOrder
  name: SortOrder
  description: SortOrder
}

input TransactionStatusAvgOrderByAggregateInput {
  transaction_status_id: SortOrder
}

input TransactionStatusMaxOrderByAggregateInput {
  transaction_status_id: SortOrder
  name: SortOrder
  description: SortOrder
}

input TransactionStatusMinOrderByAggregateInput {
  transaction_status_id: SortOrder
  name: SortOrder
  description: SortOrder
}

input TransactionStatusSumOrderByAggregateInput {
  transaction_status_id: SortOrder
}

input TransactionStatusScalarWhereWithAggregatesInput {
  AND: [TransactionStatusScalarWhereWithAggregatesInput!]
  OR: [TransactionStatusScalarWhereWithAggregatesInput!]
  NOT: [TransactionStatusScalarWhereWithAggregatesInput!]
  transaction_status_id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  description: StringWithAggregatesFilter
}

type AggregateTransactionTypes {
  _count: TransactionTypesCountAggregate
  _avg: TransactionTypesAvgAggregate
  _sum: TransactionTypesSumAggregate
  _min: TransactionTypesMinAggregate
  _max: TransactionTypesMaxAggregate
}

type TransactionTypesCountAggregate {
  transaction_type_id: Int!
  type_name: Int!
  description: Int!
  _all: Int!
}

type TransactionTypesAvgAggregate {
  transaction_type_id: Float
}

type TransactionTypesSumAggregate {
  transaction_type_id: Int
}

type TransactionTypesMinAggregate {
  transaction_type_id: Int
  type_name: String
  description: String
}

type TransactionTypesMaxAggregate {
  transaction_type_id: Int
  type_name: String
  description: String
}

input TransactionTypesWhereUniqueInput {
  transaction_type_id: Int
}

enum TransactionTypesScalarFieldEnum {
  transaction_type_id
  type_name
  description
}

type TransactionTypesGroupBy {
  transaction_type_id: Int!
  type_name: String!
  description: String!
  _count: TransactionTypesCountAggregate
  _avg: TransactionTypesAvgAggregate
  _sum: TransactionTypesSumAggregate
  _min: TransactionTypesMinAggregate
  _max: TransactionTypesMaxAggregate
}

input TransactionTypesOrderByWithAggregationInput {
  transaction_type_id: SortOrder
  type_name: SortOrder
  description: SortOrder
  _count: TransactionTypesCountOrderByAggregateInput
  _avg: TransactionTypesAvgOrderByAggregateInput
  _max: TransactionTypesMaxOrderByAggregateInput
  _min: TransactionTypesMinOrderByAggregateInput
  _sum: TransactionTypesSumOrderByAggregateInput
}

input TransactionTypesCountOrderByAggregateInput {
  transaction_type_id: SortOrder
  type_name: SortOrder
  description: SortOrder
}

input TransactionTypesAvgOrderByAggregateInput {
  transaction_type_id: SortOrder
}

input TransactionTypesMaxOrderByAggregateInput {
  transaction_type_id: SortOrder
  type_name: SortOrder
  description: SortOrder
}

input TransactionTypesMinOrderByAggregateInput {
  transaction_type_id: SortOrder
  type_name: SortOrder
  description: SortOrder
}

input TransactionTypesSumOrderByAggregateInput {
  transaction_type_id: SortOrder
}

input TransactionTypesScalarWhereWithAggregatesInput {
  AND: [TransactionTypesScalarWhereWithAggregatesInput!]
  OR: [TransactionTypesScalarWhereWithAggregatesInput!]
  NOT: [TransactionTypesScalarWhereWithAggregatesInput!]
  transaction_type_id: IntWithAggregatesFilter
  type_name: StringWithAggregatesFilter
  description: StringWithAggregatesFilter
}

type AggregateTransactions {
  _count: TransactionsCountAggregate
  _avg: TransactionsAvgAggregate
  _sum: TransactionsSumAggregate
  _min: TransactionsMinAggregate
  _max: TransactionsMaxAggregate
}

type TransactionsCountAggregate {
  transaction_id: Int!
  seller_id: Int!
  product_id: Int!
  customer_name: Int!
  customer_phone: Int!
  city_id: Int!
  address: Int!
  quantity: Int!
  date: Int!
  remainingPayement: Int!
  totalPayement: Int!
  transaction_type_id: Int!
  status_id: Int!
  _all: Int!
}

type TransactionsAvgAggregate {
  transaction_id: Float
  seller_id: Float
  product_id: Float
  city_id: Float
  quantity: Float
  remainingPayement: Float
  totalPayement: Float
  transaction_type_id: Float
  status_id: Float
}

type TransactionsSumAggregate {
  transaction_id: Int
  seller_id: Int
  product_id: Int
  city_id: Int
  quantity: Int
  remainingPayement: Float
  totalPayement: Float
  transaction_type_id: Int
  status_id: Int
}

type TransactionsMinAggregate {
  transaction_id: Int
  seller_id: Int
  product_id: Int
  customer_name: String
  customer_phone: String
  city_id: Int
  address: String
  quantity: Int
  date: DateTime
  remainingPayement: Float
  totalPayement: Float
  transaction_type_id: Int
  status_id: Int
}

type TransactionsMaxAggregate {
  transaction_id: Int
  seller_id: Int
  product_id: Int
  customer_name: String
  customer_phone: String
  city_id: Int
  address: String
  quantity: Int
  date: DateTime
  remainingPayement: Float
  totalPayement: Float
  transaction_type_id: Int
  status_id: Int
}

type TransactionsGroupBy {
  transaction_id: Int!
  seller_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  city_id: Int!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  transaction_type_id: Int!
  status_id: Int!
  _count: TransactionsCountAggregate
  _avg: TransactionsAvgAggregate
  _sum: TransactionsSumAggregate
  _min: TransactionsMinAggregate
  _max: TransactionsMaxAggregate
}

input TransactionsOrderByWithAggregationInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  customer_name: SortOrder
  customer_phone: SortOrder
  city_id: SortOrder
  address: SortOrder
  quantity: SortOrder
  date: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
  _count: TransactionsCountOrderByAggregateInput
  _avg: TransactionsAvgOrderByAggregateInput
  _max: TransactionsMaxOrderByAggregateInput
  _min: TransactionsMinOrderByAggregateInput
  _sum: TransactionsSumOrderByAggregateInput
}

input TransactionsCountOrderByAggregateInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  customer_name: SortOrder
  customer_phone: SortOrder
  city_id: SortOrder
  address: SortOrder
  quantity: SortOrder
  date: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
}

input TransactionsAvgOrderByAggregateInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  city_id: SortOrder
  quantity: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
}

input TransactionsMaxOrderByAggregateInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  customer_name: SortOrder
  customer_phone: SortOrder
  city_id: SortOrder
  address: SortOrder
  quantity: SortOrder
  date: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
}

input TransactionsMinOrderByAggregateInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  customer_name: SortOrder
  customer_phone: SortOrder
  city_id: SortOrder
  address: SortOrder
  quantity: SortOrder
  date: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
}

input TransactionsSumOrderByAggregateInput {
  transaction_id: SortOrder
  seller_id: SortOrder
  product_id: SortOrder
  city_id: SortOrder
  quantity: SortOrder
  remainingPayement: SortOrder
  totalPayement: SortOrder
  transaction_type_id: SortOrder
  status_id: SortOrder
}

input TransactionsScalarWhereWithAggregatesInput {
  AND: [TransactionsScalarWhereWithAggregatesInput!]
  OR: [TransactionsScalarWhereWithAggregatesInput!]
  NOT: [TransactionsScalarWhereWithAggregatesInput!]
  transaction_id: IntWithAggregatesFilter
  seller_id: IntWithAggregatesFilter
  product_id: IntWithAggregatesFilter
  customer_name: StringWithAggregatesFilter
  customer_phone: StringWithAggregatesFilter
  city_id: IntWithAggregatesFilter
  address: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
  date: DateTimeWithAggregatesFilter
  remainingPayement: FloatWithAggregatesFilter
  totalPayement: FloatWithAggregatesFilter
  transaction_type_id: IntWithAggregatesFilter
  status_id: IntWithAggregatesFilter
}

input DateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

input NestedDateTimeWithAggregatesFilter {
  equals: DateTime
  in: [DateTime!]
  notIn: [DateTime!]
  lt: DateTime
  lte: DateTime
  gt: DateTime
  gte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  _count: NestedIntFilter
  _min: NestedDateTimeFilter
  _max: NestedDateTimeFilter
}

type Mutation {
  createOneCity(data: CityCreateInput!): City!
  deleteManyCity(where: CityWhereInput): AffectedRowsOutput!
  deleteOneCity(where: CityWhereUniqueInput!): City
  updateManyCity(data: CityUpdateManyMutationInput!, where: CityWhereInput): AffectedRowsOutput!
  updateOneCity(data: CityUpdateInput!, where: CityWhereUniqueInput!): City
  upsertOneCity(where: CityWhereUniqueInput!, create: CityCreateInput!, update: CityUpdateInput!): City!
  createOneColors(data: ColorsCreateInput!): Colors!
  deleteManyColors(where: ColorsWhereInput): AffectedRowsOutput!
  deleteOneColors(where: ColorsWhereUniqueInput!): Colors
  updateManyColors(data: ColorsUpdateManyMutationInput!, where: ColorsWhereInput): AffectedRowsOutput!
  updateOneColors(data: ColorsUpdateInput!, where: ColorsWhereUniqueInput!): Colors
  upsertOneColors(where: ColorsWhereUniqueInput!, create: ColorsCreateInput!, update: ColorsUpdateInput!): Colors!
  createOnePayements(data: PayementsCreateInput!): Payements!
  deleteManyPayements(where: PayementsWhereInput): AffectedRowsOutput!
  deleteOnePayements(where: PayementsWhereUniqueInput!): Payements
  updateManyPayements(data: PayementsUpdateManyMutationInput!, where: PayementsWhereInput): AffectedRowsOutput!
  updateOnePayements(data: PayementsUpdateInput!, where: PayementsWhereUniqueInput!): Payements
  upsertOnePayements(where: PayementsWhereUniqueInput!, create: PayementsCreateInput!, update: PayementsUpdateInput!): Payements!
  createOneProductFamily(data: ProductFamilyCreateInput!): ProductFamily!
  deleteManyProductFamily(where: ProductFamilyWhereInput): AffectedRowsOutput!
  deleteOneProductFamily(where: ProductFamilyWhereUniqueInput!): ProductFamily
  updateManyProductFamily(data: ProductFamilyUpdateManyMutationInput!, where: ProductFamilyWhereInput): AffectedRowsOutput!
  updateOneProductFamily(data: ProductFamilyUpdateInput!, where: ProductFamilyWhereUniqueInput!): ProductFamily
  upsertOneProductFamily(where: ProductFamilyWhereUniqueInput!, create: ProductFamilyCreateInput!, update: ProductFamilyUpdateInput!): ProductFamily!
  createOneProductModel(data: ProductModelCreateInput!): ProductModel!
  deleteManyProductModel(where: ProductModelWhereInput): AffectedRowsOutput!
  deleteOneProductModel(where: ProductModelWhereUniqueInput!): ProductModel
  updateManyProductModel(data: ProductModelUpdateManyMutationInput!, where: ProductModelWhereInput): AffectedRowsOutput!
  updateOneProductModel(data: ProductModelUpdateInput!, where: ProductModelWhereUniqueInput!): ProductModel
  upsertOneProductModel(where: ProductModelWhereUniqueInput!, create: ProductModelCreateInput!, update: ProductModelUpdateInput!): ProductModel!
  createOneProducts(data: ProductsCreateInput!): Products!
  deleteManyProducts(where: ProductsWhereInput): AffectedRowsOutput!
  deleteOneProducts(where: ProductsWhereUniqueInput!): Products
  updateManyProducts(data: ProductsUpdateManyMutationInput!, where: ProductsWhereInput): AffectedRowsOutput!
  updateOneProducts(data: ProductsUpdateInput!, where: ProductsWhereUniqueInput!): Products
  upsertOneProducts(where: ProductsWhereUniqueInput!, create: ProductsCreateInput!, update: ProductsUpdateInput!): Products!
  createOneSellers(data: SellersCreateInput!): Sellers!
  deleteManySellers(where: SellersWhereInput): AffectedRowsOutput!
  deleteOneSellers(where: SellersWhereUniqueInput!): Sellers
  updateManySellers(data: SellersUpdateManyMutationInput!, where: SellersWhereInput): AffectedRowsOutput!
  updateOneSellers(data: SellersUpdateInput!, where: SellersWhereUniqueInput!): Sellers
  upsertOneSellers(where: SellersWhereUniqueInput!, create: SellersCreateInput!, update: SellersUpdateInput!): Sellers!
  createOneSizes(data: SizesCreateInput!): Sizes!
  deleteManySizes(where: SizesWhereInput): AffectedRowsOutput!
  deleteOneSizes(where: SizesWhereUniqueInput!): Sizes
  updateManySizes(data: SizesUpdateManyMutationInput!, where: SizesWhereInput): AffectedRowsOutput!
  updateOneSizes(data: SizesUpdateInput!, where: SizesWhereUniqueInput!): Sizes
  upsertOneSizes(where: SizesWhereUniqueInput!, create: SizesCreateInput!, update: SizesUpdateInput!): Sizes!
  createOneTransactionProduct(data: TransactionProductCreateInput!): TransactionProduct!
  deleteManyTransactionProduct(where: TransactionProductWhereInput): AffectedRowsOutput!
  deleteOneTransactionProduct(where: TransactionProductWhereUniqueInput!): TransactionProduct
  updateManyTransactionProduct(data: TransactionProductUpdateManyMutationInput!, where: TransactionProductWhereInput): AffectedRowsOutput!
  updateOneTransactionProduct(data: TransactionProductUpdateInput!, where: TransactionProductWhereUniqueInput!): TransactionProduct
  upsertOneTransactionProduct(where: TransactionProductWhereUniqueInput!, create: TransactionProductCreateInput!, update: TransactionProductUpdateInput!): TransactionProduct!
  createOneTransactionStatus(data: TransactionStatusCreateInput!): TransactionStatus!
  deleteManyTransactionStatus(where: TransactionStatusWhereInput): AffectedRowsOutput!
  deleteOneTransactionStatus(where: TransactionStatusWhereUniqueInput!): TransactionStatus
  updateManyTransactionStatus(data: TransactionStatusUpdateManyMutationInput!, where: TransactionStatusWhereInput): AffectedRowsOutput!
  updateOneTransactionStatus(data: TransactionStatusUpdateInput!, where: TransactionStatusWhereUniqueInput!): TransactionStatus
  upsertOneTransactionStatus(where: TransactionStatusWhereUniqueInput!, create: TransactionStatusCreateInput!, update: TransactionStatusUpdateInput!): TransactionStatus!
  createOneTransactionTypes(data: TransactionTypesCreateInput!): TransactionTypes!
  deleteManyTransactionTypes(where: TransactionTypesWhereInput): AffectedRowsOutput!
  deleteOneTransactionTypes(where: TransactionTypesWhereUniqueInput!): TransactionTypes
  updateManyTransactionTypes(data: TransactionTypesUpdateManyMutationInput!, where: TransactionTypesWhereInput): AffectedRowsOutput!
  updateOneTransactionTypes(data: TransactionTypesUpdateInput!, where: TransactionTypesWhereUniqueInput!): TransactionTypes
  upsertOneTransactionTypes(where: TransactionTypesWhereUniqueInput!, create: TransactionTypesCreateInput!, update: TransactionTypesUpdateInput!): TransactionTypes!
  createOneTransactions(data: TransactionsCreateInput!): Transactions!
  deleteManyTransactions(where: TransactionsWhereInput): AffectedRowsOutput!
  deleteOneTransactions(where: TransactionsWhereUniqueInput!): Transactions
  updateManyTransactions(data: TransactionsUpdateManyMutationInput!, where: TransactionsWhereInput): AffectedRowsOutput!
  updateOneTransactions(data: TransactionsUpdateInput!, where: TransactionsWhereUniqueInput!): Transactions
  upsertOneTransactions(where: TransactionsWhereUniqueInput!, create: TransactionsCreateInput!, update: TransactionsUpdateInput!): Transactions!
}

input CityCreateInput {
  city_id: Int!
  city_name: String!
  Transactions: TransactionsCreateNestedManyWithoutCityInput
}

input TransactionsCreateNestedManyWithoutCityInput {
  create: [TransactionsCreateWithoutCityInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutCityInput!]
  connect: [TransactionsWhereUniqueInput!]
}

input TransactionsCreateWithoutCityInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  seller: SellersCreateNestedOneWithoutTransactionsInput!
  transaction_type: TransactionTypesCreateNestedOneWithoutTransactionsInput!
  status: TransactionStatusCreateNestedOneWithoutTransactionsInput
  Payements: PayementsCreateNestedManyWithoutTransactionInput
}

input SellersCreateNestedOneWithoutTransactionsInput {
  create: SellersCreateWithoutTransactionsInput
  connectOrCreate: SellersCreateOrConnectWithoutTransactionsInput
  connect: SellersWhereUniqueInput
}

input SellersCreateWithoutTransactionsInput {
  seller_name: String!
  seller_phone: String!
  picture: String!
}

input SellersCreateOrConnectWithoutTransactionsInput {
  where: SellersWhereUniqueInput!
  create: SellersCreateWithoutTransactionsInput!
}

input TransactionTypesCreateNestedOneWithoutTransactionsInput {
  create: TransactionTypesCreateWithoutTransactionsInput
  connectOrCreate: TransactionTypesCreateOrConnectWithoutTransactionsInput
  connect: TransactionTypesWhereUniqueInput
}

input TransactionTypesCreateWithoutTransactionsInput {
  type_name: String!
  description: String!
}

input TransactionTypesCreateOrConnectWithoutTransactionsInput {
  where: TransactionTypesWhereUniqueInput!
  create: TransactionTypesCreateWithoutTransactionsInput!
}

input TransactionStatusCreateNestedOneWithoutTransactionsInput {
  create: TransactionStatusCreateWithoutTransactionsInput
  connectOrCreate: TransactionStatusCreateOrConnectWithoutTransactionsInput
  connect: TransactionStatusWhereUniqueInput
}

input TransactionStatusCreateWithoutTransactionsInput {
  name: String!
  description: String!
}

input TransactionStatusCreateOrConnectWithoutTransactionsInput {
  where: TransactionStatusWhereUniqueInput!
  create: TransactionStatusCreateWithoutTransactionsInput!
}

input PayementsCreateNestedManyWithoutTransactionInput {
  create: [PayementsCreateWithoutTransactionInput!]
  connectOrCreate: [PayementsCreateOrConnectWithoutTransactionInput!]
  connect: [PayementsWhereUniqueInput!]
}

input PayementsCreateWithoutTransactionInput {
  payement_id: Int!
  payement: Float!
}

input PayementsCreateOrConnectWithoutTransactionInput {
  where: PayementsWhereUniqueInput!
  create: PayementsCreateWithoutTransactionInput!
}

input TransactionsCreateOrConnectWithoutCityInput {
  where: TransactionsWhereUniqueInput!
  create: TransactionsCreateWithoutCityInput!
}

type AffectedRowsOutput {
  count: Int!
}

input CityUpdateManyMutationInput {
  city_id: IntFieldUpdateOperationsInput
  city_name: StringFieldUpdateOperationsInput
}

input IntFieldUpdateOperationsInput {
  set: Int
  increment: Int
  decrement: Int
  multiply: Int
  divide: Int
}

input StringFieldUpdateOperationsInput {
  set: String
}

input CityUpdateInput {
  city_id: IntFieldUpdateOperationsInput
  city_name: StringFieldUpdateOperationsInput
  Transactions: TransactionsUpdateManyWithoutCityNestedInput
}

input TransactionsUpdateManyWithoutCityNestedInput {
  create: [TransactionsCreateWithoutCityInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutCityInput!]
  upsert: [TransactionsUpsertWithWhereUniqueWithoutCityInput!]
  set: [TransactionsWhereUniqueInput!]
  disconnect: [TransactionsWhereUniqueInput!]
  delete: [TransactionsWhereUniqueInput!]
  connect: [TransactionsWhereUniqueInput!]
  update: [TransactionsUpdateWithWhereUniqueWithoutCityInput!]
  updateMany: [TransactionsUpdateManyWithWhereWithoutCityInput!]
  deleteMany: [TransactionsScalarWhereInput!]
}

input TransactionsUpsertWithWhereUniqueWithoutCityInput {
  where: TransactionsWhereUniqueInput!
  update: TransactionsUpdateWithoutCityInput!
  create: TransactionsCreateWithoutCityInput!
}

input TransactionsUpdateWithoutCityInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  seller: SellersUpdateOneRequiredWithoutTransactionsNestedInput
  transaction_type: TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  status: TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
  Payements: PayementsUpdateManyWithoutTransactionNestedInput
}

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input FloatFieldUpdateOperationsInput {
  set: Float
  increment: Float
  decrement: Float
  multiply: Float
  divide: Float
}

input SellersUpdateOneRequiredWithoutTransactionsNestedInput {
  create: SellersCreateWithoutTransactionsInput
  connectOrCreate: SellersCreateOrConnectWithoutTransactionsInput
  upsert: SellersUpsertWithoutTransactionsInput
  connect: SellersWhereUniqueInput
  update: SellersUpdateWithoutTransactionsInput
}

input SellersUpsertWithoutTransactionsInput {
  update: SellersUpdateWithoutTransactionsInput!
  create: SellersCreateWithoutTransactionsInput!
}

input SellersUpdateWithoutTransactionsInput {
  seller_name: StringFieldUpdateOperationsInput
  seller_phone: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
}

input TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput {
  create: TransactionTypesCreateWithoutTransactionsInput
  connectOrCreate: TransactionTypesCreateOrConnectWithoutTransactionsInput
  upsert: TransactionTypesUpsertWithoutTransactionsInput
  connect: TransactionTypesWhereUniqueInput
  update: TransactionTypesUpdateWithoutTransactionsInput
}

input TransactionTypesUpsertWithoutTransactionsInput {
  update: TransactionTypesUpdateWithoutTransactionsInput!
  create: TransactionTypesCreateWithoutTransactionsInput!
}

input TransactionTypesUpdateWithoutTransactionsInput {
  type_name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
}

input TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput {
  create: TransactionStatusCreateWithoutTransactionsInput
  connectOrCreate: TransactionStatusCreateOrConnectWithoutTransactionsInput
  upsert: TransactionStatusUpsertWithoutTransactionsInput
  connect: TransactionStatusWhereUniqueInput
  update: TransactionStatusUpdateWithoutTransactionsInput
}

input TransactionStatusUpsertWithoutTransactionsInput {
  update: TransactionStatusUpdateWithoutTransactionsInput!
  create: TransactionStatusCreateWithoutTransactionsInput!
}

input TransactionStatusUpdateWithoutTransactionsInput {
  name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
}

input PayementsUpdateManyWithoutTransactionNestedInput {
  create: [PayementsCreateWithoutTransactionInput!]
  connectOrCreate: [PayementsCreateOrConnectWithoutTransactionInput!]
  upsert: [PayementsUpsertWithWhereUniqueWithoutTransactionInput!]
  set: [PayementsWhereUniqueInput!]
  disconnect: [PayementsWhereUniqueInput!]
  delete: [PayementsWhereUniqueInput!]
  connect: [PayementsWhereUniqueInput!]
  update: [PayementsUpdateWithWhereUniqueWithoutTransactionInput!]
  updateMany: [PayementsUpdateManyWithWhereWithoutTransactionInput!]
  deleteMany: [PayementsScalarWhereInput!]
}

input PayementsUpsertWithWhereUniqueWithoutTransactionInput {
  where: PayementsWhereUniqueInput!
  update: PayementsUpdateWithoutTransactionInput!
  create: PayementsCreateWithoutTransactionInput!
}

input PayementsUpdateWithoutTransactionInput {
  payement_id: IntFieldUpdateOperationsInput
  payement: FloatFieldUpdateOperationsInput
}

input PayementsUpdateWithWhereUniqueWithoutTransactionInput {
  where: PayementsWhereUniqueInput!
  data: PayementsUpdateWithoutTransactionInput!
}

input PayementsUpdateManyWithWhereWithoutTransactionInput {
  where: PayementsScalarWhereInput!
  data: PayementsUpdateManyMutationInput!
}

input PayementsScalarWhereInput {
  AND: [PayementsScalarWhereInput!]
  OR: [PayementsScalarWhereInput!]
  NOT: [PayementsScalarWhereInput!]
  payement_id: IntFilter
  transaction_id: IntFilter
  payement: FloatFilter
}

input PayementsUpdateManyMutationInput {
  payement_id: IntFieldUpdateOperationsInput
  payement: FloatFieldUpdateOperationsInput
}

input TransactionsUpdateWithWhereUniqueWithoutCityInput {
  where: TransactionsWhereUniqueInput!
  data: TransactionsUpdateWithoutCityInput!
}

input TransactionsUpdateManyWithWhereWithoutCityInput {
  where: TransactionsScalarWhereInput!
  data: TransactionsUpdateManyMutationInput!
}

input TransactionsScalarWhereInput {
  AND: [TransactionsScalarWhereInput!]
  OR: [TransactionsScalarWhereInput!]
  NOT: [TransactionsScalarWhereInput!]
  transaction_id: IntFilter
  seller_id: IntFilter
  product_id: IntFilter
  customer_name: StringFilter
  customer_phone: StringFilter
  city_id: IntFilter
  address: StringFilter
  quantity: IntFilter
  date: DateTimeFilter
  remainingPayement: FloatFilter
  totalPayement: FloatFilter
  transaction_type_id: IntFilter
  status_id: IntFilter
}

input TransactionsUpdateManyMutationInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
}

input ColorsCreateInput {
  id: Int!
  color: String!
  ProductModel: ProductModelCreateNestedManyWithoutColorInput
}

input ProductModelCreateNestedManyWithoutColorInput {
  create: [ProductModelCreateWithoutColorInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutColorInput!]
  connect: [ProductModelWhereUniqueInput!]
}

input ProductModelCreateWithoutColorInput {
  quantity: Int!
  product: ProductsCreateNestedOneWithoutProductModelInput!
  size: SizesCreateNestedOneWithoutProductModelInput!
}

input ProductsCreateNestedOneWithoutProductModelInput {
  create: ProductsCreateWithoutProductModelInput
  connectOrCreate: ProductsCreateOrConnectWithoutProductModelInput
  connect: ProductsWhereUniqueInput
}

input ProductsCreateWithoutProductModelInput {
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  family: ProductFamilyCreateNestedOneWithoutProductsInput!
  TransactionProduct: TransactionProductCreateNestedManyWithoutProductInput
}

input ProductFamilyCreateNestedOneWithoutProductsInput {
  create: ProductFamilyCreateWithoutProductsInput
  connectOrCreate: ProductFamilyCreateOrConnectWithoutProductsInput
  connect: ProductFamilyWhereUniqueInput
}

input ProductFamilyCreateWithoutProductsInput {
  name: String!
}

input ProductFamilyCreateOrConnectWithoutProductsInput {
  where: ProductFamilyWhereUniqueInput!
  create: ProductFamilyCreateWithoutProductsInput!
}

input TransactionProductCreateNestedManyWithoutProductInput {
  create: [TransactionProductCreateWithoutProductInput!]
  connectOrCreate: [TransactionProductCreateOrConnectWithoutProductInput!]
  connect: [TransactionProductWhereUniqueInput!]
}

input TransactionProductCreateWithoutProductInput {
  quantity: Int!
  price: Float!
  product_name: String!
}

input TransactionProductCreateOrConnectWithoutProductInput {
  where: TransactionProductWhereUniqueInput!
  create: TransactionProductCreateWithoutProductInput!
}

input ProductsCreateOrConnectWithoutProductModelInput {
  where: ProductsWhereUniqueInput!
  create: ProductsCreateWithoutProductModelInput!
}

input SizesCreateNestedOneWithoutProductModelInput {
  create: SizesCreateWithoutProductModelInput
  connectOrCreate: SizesCreateOrConnectWithoutProductModelInput
  connect: SizesWhereUniqueInput
}

input SizesCreateWithoutProductModelInput {
  id: Int!
  size: String!
}

input SizesCreateOrConnectWithoutProductModelInput {
  where: SizesWhereUniqueInput!
  create: SizesCreateWithoutProductModelInput!
}

input ProductModelCreateOrConnectWithoutColorInput {
  where: ProductModelWhereUniqueInput!
  create: ProductModelCreateWithoutColorInput!
}

input ColorsUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
  color: StringFieldUpdateOperationsInput
}

input ColorsUpdateInput {
  id: IntFieldUpdateOperationsInput
  color: StringFieldUpdateOperationsInput
  ProductModel: ProductModelUpdateManyWithoutColorNestedInput
}

input ProductModelUpdateManyWithoutColorNestedInput {
  create: [ProductModelCreateWithoutColorInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutColorInput!]
  upsert: [ProductModelUpsertWithWhereUniqueWithoutColorInput!]
  set: [ProductModelWhereUniqueInput!]
  disconnect: [ProductModelWhereUniqueInput!]
  delete: [ProductModelWhereUniqueInput!]
  connect: [ProductModelWhereUniqueInput!]
  update: [ProductModelUpdateWithWhereUniqueWithoutColorInput!]
  updateMany: [ProductModelUpdateManyWithWhereWithoutColorInput!]
  deleteMany: [ProductModelScalarWhereInput!]
}

input ProductModelUpsertWithWhereUniqueWithoutColorInput {
  where: ProductModelWhereUniqueInput!
  update: ProductModelUpdateWithoutColorInput!
  create: ProductModelCreateWithoutColorInput!
}

input ProductModelUpdateWithoutColorInput {
  quantity: IntFieldUpdateOperationsInput
  product: ProductsUpdateOneRequiredWithoutProductModelNestedInput
  size: SizesUpdateOneRequiredWithoutProductModelNestedInput
}

input ProductsUpdateOneRequiredWithoutProductModelNestedInput {
  create: ProductsCreateWithoutProductModelInput
  connectOrCreate: ProductsCreateOrConnectWithoutProductModelInput
  upsert: ProductsUpsertWithoutProductModelInput
  connect: ProductsWhereUniqueInput
  update: ProductsUpdateWithoutProductModelInput
}

input ProductsUpsertWithoutProductModelInput {
  update: ProductsUpdateWithoutProductModelInput!
  create: ProductsCreateWithoutProductModelInput!
}

input ProductsUpdateWithoutProductModelInput {
  reference: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  buyingPrice: FloatFieldUpdateOperationsInput
  sellingPrice: FloatFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
  family: ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
  TransactionProduct: TransactionProductUpdateManyWithoutProductNestedInput
}

input ProductFamilyUpdateOneRequiredWithoutProductsNestedInput {
  create: ProductFamilyCreateWithoutProductsInput
  connectOrCreate: ProductFamilyCreateOrConnectWithoutProductsInput
  upsert: ProductFamilyUpsertWithoutProductsInput
  connect: ProductFamilyWhereUniqueInput
  update: ProductFamilyUpdateWithoutProductsInput
}

input ProductFamilyUpsertWithoutProductsInput {
  update: ProductFamilyUpdateWithoutProductsInput!
  create: ProductFamilyCreateWithoutProductsInput!
}

input ProductFamilyUpdateWithoutProductsInput {
  name: StringFieldUpdateOperationsInput
}

input TransactionProductUpdateManyWithoutProductNestedInput {
  create: [TransactionProductCreateWithoutProductInput!]
  connectOrCreate: [TransactionProductCreateOrConnectWithoutProductInput!]
  upsert: [TransactionProductUpsertWithWhereUniqueWithoutProductInput!]
  set: [TransactionProductWhereUniqueInput!]
  disconnect: [TransactionProductWhereUniqueInput!]
  delete: [TransactionProductWhereUniqueInput!]
  connect: [TransactionProductWhereUniqueInput!]
  update: [TransactionProductUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [TransactionProductUpdateManyWithWhereWithoutProductInput!]
  deleteMany: [TransactionProductScalarWhereInput!]
}

input TransactionProductUpsertWithWhereUniqueWithoutProductInput {
  where: TransactionProductWhereUniqueInput!
  update: TransactionProductUpdateWithoutProductInput!
  create: TransactionProductCreateWithoutProductInput!
}

input TransactionProductUpdateWithoutProductInput {
  quantity: IntFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
}

input TransactionProductUpdateWithWhereUniqueWithoutProductInput {
  where: TransactionProductWhereUniqueInput!
  data: TransactionProductUpdateWithoutProductInput!
}

input TransactionProductUpdateManyWithWhereWithoutProductInput {
  where: TransactionProductScalarWhereInput!
  data: TransactionProductUpdateManyMutationInput!
}

input TransactionProductScalarWhereInput {
  AND: [TransactionProductScalarWhereInput!]
  OR: [TransactionProductScalarWhereInput!]
  NOT: [TransactionProductScalarWhereInput!]
  transaction_id: IntFilter
  product_id: IntFilter
  quantity: IntFilter
  price: FloatFilter
  product_name: StringFilter
}

input TransactionProductUpdateManyMutationInput {
  quantity: IntFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
}

input SizesUpdateOneRequiredWithoutProductModelNestedInput {
  create: SizesCreateWithoutProductModelInput
  connectOrCreate: SizesCreateOrConnectWithoutProductModelInput
  upsert: SizesUpsertWithoutProductModelInput
  connect: SizesWhereUniqueInput
  update: SizesUpdateWithoutProductModelInput
}

input SizesUpsertWithoutProductModelInput {
  update: SizesUpdateWithoutProductModelInput!
  create: SizesCreateWithoutProductModelInput!
}

input SizesUpdateWithoutProductModelInput {
  id: IntFieldUpdateOperationsInput
  size: StringFieldUpdateOperationsInput
}

input ProductModelUpdateWithWhereUniqueWithoutColorInput {
  where: ProductModelWhereUniqueInput!
  data: ProductModelUpdateWithoutColorInput!
}

input ProductModelUpdateManyWithWhereWithoutColorInput {
  where: ProductModelScalarWhereInput!
  data: ProductModelUpdateManyMutationInput!
}

input ProductModelScalarWhereInput {
  AND: [ProductModelScalarWhereInput!]
  OR: [ProductModelScalarWhereInput!]
  NOT: [ProductModelScalarWhereInput!]
  product_id: IntFilter
  color_id: IntFilter
  size_id: IntFilter
  quantity: IntFilter
}

input ProductModelUpdateManyMutationInput {
  quantity: IntFieldUpdateOperationsInput
}

input PayementsCreateInput {
  payement_id: Int!
  payement: Float!
  transaction: TransactionsCreateNestedOneWithoutPayementsInput!
}

input TransactionsCreateNestedOneWithoutPayementsInput {
  create: TransactionsCreateWithoutPayementsInput
  connectOrCreate: TransactionsCreateOrConnectWithoutPayementsInput
  connect: TransactionsWhereUniqueInput
}

input TransactionsCreateWithoutPayementsInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  seller: SellersCreateNestedOneWithoutTransactionsInput!
  city: CityCreateNestedOneWithoutTransactionsInput!
  transaction_type: TransactionTypesCreateNestedOneWithoutTransactionsInput!
  status: TransactionStatusCreateNestedOneWithoutTransactionsInput
}

input CityCreateNestedOneWithoutTransactionsInput {
  create: CityCreateWithoutTransactionsInput
  connectOrCreate: CityCreateOrConnectWithoutTransactionsInput
  connect: CityWhereUniqueInput
}

input CityCreateWithoutTransactionsInput {
  city_id: Int!
  city_name: String!
}

input CityCreateOrConnectWithoutTransactionsInput {
  where: CityWhereUniqueInput!
  create: CityCreateWithoutTransactionsInput!
}

input TransactionsCreateOrConnectWithoutPayementsInput {
  where: TransactionsWhereUniqueInput!
  create: TransactionsCreateWithoutPayementsInput!
}

input PayementsUpdateInput {
  payement_id: IntFieldUpdateOperationsInput
  payement: FloatFieldUpdateOperationsInput
  transaction: TransactionsUpdateOneRequiredWithoutPayementsNestedInput
}

input TransactionsUpdateOneRequiredWithoutPayementsNestedInput {
  create: TransactionsCreateWithoutPayementsInput
  connectOrCreate: TransactionsCreateOrConnectWithoutPayementsInput
  upsert: TransactionsUpsertWithoutPayementsInput
  connect: TransactionsWhereUniqueInput
  update: TransactionsUpdateWithoutPayementsInput
}

input TransactionsUpsertWithoutPayementsInput {
  update: TransactionsUpdateWithoutPayementsInput!
  create: TransactionsCreateWithoutPayementsInput!
}

input TransactionsUpdateWithoutPayementsInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  seller: SellersUpdateOneRequiredWithoutTransactionsNestedInput
  city: CityUpdateOneRequiredWithoutTransactionsNestedInput
  transaction_type: TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  status: TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
}

input CityUpdateOneRequiredWithoutTransactionsNestedInput {
  create: CityCreateWithoutTransactionsInput
  connectOrCreate: CityCreateOrConnectWithoutTransactionsInput
  upsert: CityUpsertWithoutTransactionsInput
  connect: CityWhereUniqueInput
  update: CityUpdateWithoutTransactionsInput
}

input CityUpsertWithoutTransactionsInput {
  update: CityUpdateWithoutTransactionsInput!
  create: CityCreateWithoutTransactionsInput!
}

input CityUpdateWithoutTransactionsInput {
  city_id: IntFieldUpdateOperationsInput
  city_name: StringFieldUpdateOperationsInput
}

input ProductFamilyCreateInput {
  name: String!
  Products: ProductsCreateNestedManyWithoutFamilyInput
}

input ProductsCreateNestedManyWithoutFamilyInput {
  create: [ProductsCreateWithoutFamilyInput!]
  connectOrCreate: [ProductsCreateOrConnectWithoutFamilyInput!]
  connect: [ProductsWhereUniqueInput!]
}

input ProductsCreateWithoutFamilyInput {
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  ProductModel: ProductModelCreateNestedManyWithoutProductInput
  TransactionProduct: TransactionProductCreateNestedManyWithoutProductInput
}

input ProductModelCreateNestedManyWithoutProductInput {
  create: [ProductModelCreateWithoutProductInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutProductInput!]
  connect: [ProductModelWhereUniqueInput!]
}

input ProductModelCreateWithoutProductInput {
  quantity: Int!
  size: SizesCreateNestedOneWithoutProductModelInput!
  color: ColorsCreateNestedOneWithoutProductModelInput!
}

input ColorsCreateNestedOneWithoutProductModelInput {
  create: ColorsCreateWithoutProductModelInput
  connectOrCreate: ColorsCreateOrConnectWithoutProductModelInput
  connect: ColorsWhereUniqueInput
}

input ColorsCreateWithoutProductModelInput {
  id: Int!
  color: String!
}

input ColorsCreateOrConnectWithoutProductModelInput {
  where: ColorsWhereUniqueInput!
  create: ColorsCreateWithoutProductModelInput!
}

input ProductModelCreateOrConnectWithoutProductInput {
  where: ProductModelWhereUniqueInput!
  create: ProductModelCreateWithoutProductInput!
}

input ProductsCreateOrConnectWithoutFamilyInput {
  where: ProductsWhereUniqueInput!
  create: ProductsCreateWithoutFamilyInput!
}

input ProductFamilyUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
}

input ProductFamilyUpdateInput {
  name: StringFieldUpdateOperationsInput
  Products: ProductsUpdateManyWithoutFamilyNestedInput
}

input ProductsUpdateManyWithoutFamilyNestedInput {
  create: [ProductsCreateWithoutFamilyInput!]
  connectOrCreate: [ProductsCreateOrConnectWithoutFamilyInput!]
  upsert: [ProductsUpsertWithWhereUniqueWithoutFamilyInput!]
  set: [ProductsWhereUniqueInput!]
  disconnect: [ProductsWhereUniqueInput!]
  delete: [ProductsWhereUniqueInput!]
  connect: [ProductsWhereUniqueInput!]
  update: [ProductsUpdateWithWhereUniqueWithoutFamilyInput!]
  updateMany: [ProductsUpdateManyWithWhereWithoutFamilyInput!]
  deleteMany: [ProductsScalarWhereInput!]
}

input ProductsUpsertWithWhereUniqueWithoutFamilyInput {
  where: ProductsWhereUniqueInput!
  update: ProductsUpdateWithoutFamilyInput!
  create: ProductsCreateWithoutFamilyInput!
}

input ProductsUpdateWithoutFamilyInput {
  reference: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  buyingPrice: FloatFieldUpdateOperationsInput
  sellingPrice: FloatFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
  ProductModel: ProductModelUpdateManyWithoutProductNestedInput
  TransactionProduct: TransactionProductUpdateManyWithoutProductNestedInput
}

input ProductModelUpdateManyWithoutProductNestedInput {
  create: [ProductModelCreateWithoutProductInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutProductInput!]
  upsert: [ProductModelUpsertWithWhereUniqueWithoutProductInput!]
  set: [ProductModelWhereUniqueInput!]
  disconnect: [ProductModelWhereUniqueInput!]
  delete: [ProductModelWhereUniqueInput!]
  connect: [ProductModelWhereUniqueInput!]
  update: [ProductModelUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [ProductModelUpdateManyWithWhereWithoutProductInput!]
  deleteMany: [ProductModelScalarWhereInput!]
}

input ProductModelUpsertWithWhereUniqueWithoutProductInput {
  where: ProductModelWhereUniqueInput!
  update: ProductModelUpdateWithoutProductInput!
  create: ProductModelCreateWithoutProductInput!
}

input ProductModelUpdateWithoutProductInput {
  quantity: IntFieldUpdateOperationsInput
  size: SizesUpdateOneRequiredWithoutProductModelNestedInput
  color: ColorsUpdateOneRequiredWithoutProductModelNestedInput
}

input ColorsUpdateOneRequiredWithoutProductModelNestedInput {
  create: ColorsCreateWithoutProductModelInput
  connectOrCreate: ColorsCreateOrConnectWithoutProductModelInput
  upsert: ColorsUpsertWithoutProductModelInput
  connect: ColorsWhereUniqueInput
  update: ColorsUpdateWithoutProductModelInput
}

input ColorsUpsertWithoutProductModelInput {
  update: ColorsUpdateWithoutProductModelInput!
  create: ColorsCreateWithoutProductModelInput!
}

input ColorsUpdateWithoutProductModelInput {
  id: IntFieldUpdateOperationsInput
  color: StringFieldUpdateOperationsInput
}

input ProductModelUpdateWithWhereUniqueWithoutProductInput {
  where: ProductModelWhereUniqueInput!
  data: ProductModelUpdateWithoutProductInput!
}

input ProductModelUpdateManyWithWhereWithoutProductInput {
  where: ProductModelScalarWhereInput!
  data: ProductModelUpdateManyMutationInput!
}

input ProductsUpdateWithWhereUniqueWithoutFamilyInput {
  where: ProductsWhereUniqueInput!
  data: ProductsUpdateWithoutFamilyInput!
}

input ProductsUpdateManyWithWhereWithoutFamilyInput {
  where: ProductsScalarWhereInput!
  data: ProductsUpdateManyMutationInput!
}

input ProductsScalarWhereInput {
  AND: [ProductsScalarWhereInput!]
  OR: [ProductsScalarWhereInput!]
  NOT: [ProductsScalarWhereInput!]
  product_id: IntFilter
  reference: IntFilter
  name: StringFilter
  buyingPrice: FloatFilter
  sellingPrice: FloatFilter
  description: StringFilter
  picture: StringFilter
  family_id: IntFilter
}

input ProductsUpdateManyMutationInput {
  reference: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  buyingPrice: FloatFieldUpdateOperationsInput
  sellingPrice: FloatFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
}

input ProductModelCreateInput {
  quantity: Int!
  product: ProductsCreateNestedOneWithoutProductModelInput!
  size: SizesCreateNestedOneWithoutProductModelInput!
  color: ColorsCreateNestedOneWithoutProductModelInput!
}

input ProductModelUpdateInput {
  quantity: IntFieldUpdateOperationsInput
  product: ProductsUpdateOneRequiredWithoutProductModelNestedInput
  size: SizesUpdateOneRequiredWithoutProductModelNestedInput
  color: ColorsUpdateOneRequiredWithoutProductModelNestedInput
}

input ProductsCreateInput {
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  family: ProductFamilyCreateNestedOneWithoutProductsInput!
  ProductModel: ProductModelCreateNestedManyWithoutProductInput
  TransactionProduct: TransactionProductCreateNestedManyWithoutProductInput
}

input ProductsUpdateInput {
  reference: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  buyingPrice: FloatFieldUpdateOperationsInput
  sellingPrice: FloatFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
  family: ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
  ProductModel: ProductModelUpdateManyWithoutProductNestedInput
  TransactionProduct: TransactionProductUpdateManyWithoutProductNestedInput
}

input SellersCreateInput {
  seller_name: String!
  seller_phone: String!
  picture: String!
  Transactions: TransactionsCreateNestedManyWithoutSellerInput
}

input TransactionsCreateNestedManyWithoutSellerInput {
  create: [TransactionsCreateWithoutSellerInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutSellerInput!]
  connect: [TransactionsWhereUniqueInput!]
}

input TransactionsCreateWithoutSellerInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  city: CityCreateNestedOneWithoutTransactionsInput!
  transaction_type: TransactionTypesCreateNestedOneWithoutTransactionsInput!
  status: TransactionStatusCreateNestedOneWithoutTransactionsInput
  Payements: PayementsCreateNestedManyWithoutTransactionInput
}

input TransactionsCreateOrConnectWithoutSellerInput {
  where: TransactionsWhereUniqueInput!
  create: TransactionsCreateWithoutSellerInput!
}

input SellersUpdateManyMutationInput {
  seller_name: StringFieldUpdateOperationsInput
  seller_phone: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
}

input SellersUpdateInput {
  seller_name: StringFieldUpdateOperationsInput
  seller_phone: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
  Transactions: TransactionsUpdateManyWithoutSellerNestedInput
}

input TransactionsUpdateManyWithoutSellerNestedInput {
  create: [TransactionsCreateWithoutSellerInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutSellerInput!]
  upsert: [TransactionsUpsertWithWhereUniqueWithoutSellerInput!]
  set: [TransactionsWhereUniqueInput!]
  disconnect: [TransactionsWhereUniqueInput!]
  delete: [TransactionsWhereUniqueInput!]
  connect: [TransactionsWhereUniqueInput!]
  update: [TransactionsUpdateWithWhereUniqueWithoutSellerInput!]
  updateMany: [TransactionsUpdateManyWithWhereWithoutSellerInput!]
  deleteMany: [TransactionsScalarWhereInput!]
}

input TransactionsUpsertWithWhereUniqueWithoutSellerInput {
  where: TransactionsWhereUniqueInput!
  update: TransactionsUpdateWithoutSellerInput!
  create: TransactionsCreateWithoutSellerInput!
}

input TransactionsUpdateWithoutSellerInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  city: CityUpdateOneRequiredWithoutTransactionsNestedInput
  transaction_type: TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  status: TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
  Payements: PayementsUpdateManyWithoutTransactionNestedInput
}

input TransactionsUpdateWithWhereUniqueWithoutSellerInput {
  where: TransactionsWhereUniqueInput!
  data: TransactionsUpdateWithoutSellerInput!
}

input TransactionsUpdateManyWithWhereWithoutSellerInput {
  where: TransactionsScalarWhereInput!
  data: TransactionsUpdateManyMutationInput!
}

input SizesCreateInput {
  id: Int!
  size: String!
  ProductModel: ProductModelCreateNestedManyWithoutSizeInput
}

input ProductModelCreateNestedManyWithoutSizeInput {
  create: [ProductModelCreateWithoutSizeInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutSizeInput!]
  connect: [ProductModelWhereUniqueInput!]
}

input ProductModelCreateWithoutSizeInput {
  quantity: Int!
  product: ProductsCreateNestedOneWithoutProductModelInput!
  color: ColorsCreateNestedOneWithoutProductModelInput!
}

input ProductModelCreateOrConnectWithoutSizeInput {
  where: ProductModelWhereUniqueInput!
  create: ProductModelCreateWithoutSizeInput!
}

input SizesUpdateManyMutationInput {
  id: IntFieldUpdateOperationsInput
  size: StringFieldUpdateOperationsInput
}

input SizesUpdateInput {
  id: IntFieldUpdateOperationsInput
  size: StringFieldUpdateOperationsInput
  ProductModel: ProductModelUpdateManyWithoutSizeNestedInput
}

input ProductModelUpdateManyWithoutSizeNestedInput {
  create: [ProductModelCreateWithoutSizeInput!]
  connectOrCreate: [ProductModelCreateOrConnectWithoutSizeInput!]
  upsert: [ProductModelUpsertWithWhereUniqueWithoutSizeInput!]
  set: [ProductModelWhereUniqueInput!]
  disconnect: [ProductModelWhereUniqueInput!]
  delete: [ProductModelWhereUniqueInput!]
  connect: [ProductModelWhereUniqueInput!]
  update: [ProductModelUpdateWithWhereUniqueWithoutSizeInput!]
  updateMany: [ProductModelUpdateManyWithWhereWithoutSizeInput!]
  deleteMany: [ProductModelScalarWhereInput!]
}

input ProductModelUpsertWithWhereUniqueWithoutSizeInput {
  where: ProductModelWhereUniqueInput!
  update: ProductModelUpdateWithoutSizeInput!
  create: ProductModelCreateWithoutSizeInput!
}

input ProductModelUpdateWithoutSizeInput {
  quantity: IntFieldUpdateOperationsInput
  product: ProductsUpdateOneRequiredWithoutProductModelNestedInput
  color: ColorsUpdateOneRequiredWithoutProductModelNestedInput
}

input ProductModelUpdateWithWhereUniqueWithoutSizeInput {
  where: ProductModelWhereUniqueInput!
  data: ProductModelUpdateWithoutSizeInput!
}

input ProductModelUpdateManyWithWhereWithoutSizeInput {
  where: ProductModelScalarWhereInput!
  data: ProductModelUpdateManyMutationInput!
}

input TransactionProductCreateInput {
  quantity: Int!
  price: Float!
  product_name: String!
  product: ProductsCreateNestedOneWithoutTransactionProductInput!
}

input ProductsCreateNestedOneWithoutTransactionProductInput {
  create: ProductsCreateWithoutTransactionProductInput
  connectOrCreate: ProductsCreateOrConnectWithoutTransactionProductInput
  connect: ProductsWhereUniqueInput
}

input ProductsCreateWithoutTransactionProductInput {
  reference: Int!
  name: String!
  buyingPrice: Float!
  sellingPrice: Float!
  description: String!
  picture: String!
  family: ProductFamilyCreateNestedOneWithoutProductsInput!
  ProductModel: ProductModelCreateNestedManyWithoutProductInput
}

input ProductsCreateOrConnectWithoutTransactionProductInput {
  where: ProductsWhereUniqueInput!
  create: ProductsCreateWithoutTransactionProductInput!
}

input TransactionProductUpdateInput {
  quantity: IntFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product_name: StringFieldUpdateOperationsInput
  product: ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
}

input ProductsUpdateOneRequiredWithoutTransactionProductNestedInput {
  create: ProductsCreateWithoutTransactionProductInput
  connectOrCreate: ProductsCreateOrConnectWithoutTransactionProductInput
  upsert: ProductsUpsertWithoutTransactionProductInput
  connect: ProductsWhereUniqueInput
  update: ProductsUpdateWithoutTransactionProductInput
}

input ProductsUpsertWithoutTransactionProductInput {
  update: ProductsUpdateWithoutTransactionProductInput!
  create: ProductsCreateWithoutTransactionProductInput!
}

input ProductsUpdateWithoutTransactionProductInput {
  reference: IntFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  buyingPrice: FloatFieldUpdateOperationsInput
  sellingPrice: FloatFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  picture: StringFieldUpdateOperationsInput
  family: ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
  ProductModel: ProductModelUpdateManyWithoutProductNestedInput
}

input TransactionStatusCreateInput {
  name: String!
  description: String!
  Transactions: TransactionsCreateNestedManyWithoutStatusInput
}

input TransactionsCreateNestedManyWithoutStatusInput {
  create: [TransactionsCreateWithoutStatusInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutStatusInput!]
  connect: [TransactionsWhereUniqueInput!]
}

input TransactionsCreateWithoutStatusInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  seller: SellersCreateNestedOneWithoutTransactionsInput!
  city: CityCreateNestedOneWithoutTransactionsInput!
  transaction_type: TransactionTypesCreateNestedOneWithoutTransactionsInput!
  Payements: PayementsCreateNestedManyWithoutTransactionInput
}

input TransactionsCreateOrConnectWithoutStatusInput {
  where: TransactionsWhereUniqueInput!
  create: TransactionsCreateWithoutStatusInput!
}

input TransactionStatusUpdateManyMutationInput {
  name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
}

input TransactionStatusUpdateInput {
  name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  Transactions: TransactionsUpdateManyWithoutStatusNestedInput
}

input TransactionsUpdateManyWithoutStatusNestedInput {
  create: [TransactionsCreateWithoutStatusInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutStatusInput!]
  upsert: [TransactionsUpsertWithWhereUniqueWithoutStatusInput!]
  set: [TransactionsWhereUniqueInput!]
  disconnect: [TransactionsWhereUniqueInput!]
  delete: [TransactionsWhereUniqueInput!]
  connect: [TransactionsWhereUniqueInput!]
  update: [TransactionsUpdateWithWhereUniqueWithoutStatusInput!]
  updateMany: [TransactionsUpdateManyWithWhereWithoutStatusInput!]
  deleteMany: [TransactionsScalarWhereInput!]
}

input TransactionsUpsertWithWhereUniqueWithoutStatusInput {
  where: TransactionsWhereUniqueInput!
  update: TransactionsUpdateWithoutStatusInput!
  create: TransactionsCreateWithoutStatusInput!
}

input TransactionsUpdateWithoutStatusInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  seller: SellersUpdateOneRequiredWithoutTransactionsNestedInput
  city: CityUpdateOneRequiredWithoutTransactionsNestedInput
  transaction_type: TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  Payements: PayementsUpdateManyWithoutTransactionNestedInput
}

input TransactionsUpdateWithWhereUniqueWithoutStatusInput {
  where: TransactionsWhereUniqueInput!
  data: TransactionsUpdateWithoutStatusInput!
}

input TransactionsUpdateManyWithWhereWithoutStatusInput {
  where: TransactionsScalarWhereInput!
  data: TransactionsUpdateManyMutationInput!
}

input TransactionTypesCreateInput {
  type_name: String!
  description: String!
  Transactions: TransactionsCreateNestedManyWithoutTransaction_typeInput
}

input TransactionsCreateNestedManyWithoutTransaction_typeInput {
  create: [TransactionsCreateWithoutTransaction_typeInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutTransaction_typeInput!]
  connect: [TransactionsWhereUniqueInput!]
}

input TransactionsCreateWithoutTransaction_typeInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  seller: SellersCreateNestedOneWithoutTransactionsInput!
  city: CityCreateNestedOneWithoutTransactionsInput!
  status: TransactionStatusCreateNestedOneWithoutTransactionsInput
  Payements: PayementsCreateNestedManyWithoutTransactionInput
}

input TransactionsCreateOrConnectWithoutTransaction_typeInput {
  where: TransactionsWhereUniqueInput!
  create: TransactionsCreateWithoutTransaction_typeInput!
}

input TransactionTypesUpdateManyMutationInput {
  type_name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
}

input TransactionTypesUpdateInput {
  type_name: StringFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  Transactions: TransactionsUpdateManyWithoutTransaction_typeNestedInput
}

input TransactionsUpdateManyWithoutTransaction_typeNestedInput {
  create: [TransactionsCreateWithoutTransaction_typeInput!]
  connectOrCreate: [TransactionsCreateOrConnectWithoutTransaction_typeInput!]
  upsert: [TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput!]
  set: [TransactionsWhereUniqueInput!]
  disconnect: [TransactionsWhereUniqueInput!]
  delete: [TransactionsWhereUniqueInput!]
  connect: [TransactionsWhereUniqueInput!]
  update: [TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput!]
  updateMany: [TransactionsUpdateManyWithWhereWithoutTransaction_typeInput!]
  deleteMany: [TransactionsScalarWhereInput!]
}

input TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput {
  where: TransactionsWhereUniqueInput!
  update: TransactionsUpdateWithoutTransaction_typeInput!
  create: TransactionsCreateWithoutTransaction_typeInput!
}

input TransactionsUpdateWithoutTransaction_typeInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  seller: SellersUpdateOneRequiredWithoutTransactionsNestedInput
  city: CityUpdateOneRequiredWithoutTransactionsNestedInput
  status: TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
  Payements: PayementsUpdateManyWithoutTransactionNestedInput
}

input TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput {
  where: TransactionsWhereUniqueInput!
  data: TransactionsUpdateWithoutTransaction_typeInput!
}

input TransactionsUpdateManyWithWhereWithoutTransaction_typeInput {
  where: TransactionsScalarWhereInput!
  data: TransactionsUpdateManyMutationInput!
}

input TransactionsCreateInput {
  transaction_id: Int!
  product_id: Int!
  customer_name: String!
  customer_phone: String!
  address: String!
  quantity: Int!
  date: DateTime!
  remainingPayement: Float!
  totalPayement: Float!
  seller: SellersCreateNestedOneWithoutTransactionsInput!
  city: CityCreateNestedOneWithoutTransactionsInput!
  transaction_type: TransactionTypesCreateNestedOneWithoutTransactionsInput!
  status: TransactionStatusCreateNestedOneWithoutTransactionsInput
  Payements: PayementsCreateNestedManyWithoutTransactionInput
}

input TransactionsUpdateInput {
  transaction_id: IntFieldUpdateOperationsInput
  product_id: IntFieldUpdateOperationsInput
  customer_name: StringFieldUpdateOperationsInput
  customer_phone: StringFieldUpdateOperationsInput
  address: StringFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
  date: DateTimeFieldUpdateOperationsInput
  remainingPayement: FloatFieldUpdateOperationsInput
  totalPayement: FloatFieldUpdateOperationsInput
  seller: SellersUpdateOneRequiredWithoutTransactionsNestedInput
  city: CityUpdateOneRequiredWithoutTransactionsNestedInput
  transaction_type: TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
  status: TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
  Payements: PayementsUpdateManyWithoutTransactionNestedInput
}