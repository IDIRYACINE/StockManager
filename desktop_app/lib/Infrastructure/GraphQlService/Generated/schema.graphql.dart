class Input$CityWhereInput {
  factory Input$CityWhereInput({
    List<Input$CityWhereInput>? AND,
    List<Input$CityWhereInput>? OR,
    List<Input$CityWhereInput>? NOT,
    Input$IntFilter? city_id,
    Input$StringFilter? city_name,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      Input$CityWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$CityWhereInput._(this._$data);

  factory Input$CityWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map(
              (e) => Input$CityWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map(
              (e) => Input$CityWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map(
              (e) => Input$CityWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFilter.fromJson((l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : Input$StringFilter.fromJson((l$city_name as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsListRelationFilter.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$CityWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CityWhereInput>? get AND =>
      (_$data['AND'] as List<Input$CityWhereInput>?);
  List<Input$CityWhereInput>? get OR =>
      (_$data['OR'] as List<Input$CityWhereInput>?);
  List<Input$CityWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$CityWhereInput>?);
  Input$IntFilter? get city_id => (_$data['city_id'] as Input$IntFilter?);
  Input$StringFilter? get city_name =>
      (_$data['city_name'] as Input$StringFilter?);
  Input$TransactionsListRelationFilter? get Transactions =>
      (_$data['Transactions'] as Input$TransactionsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] = l$city_name?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityWhereInput<Input$CityWhereInput> get copyWith =>
      CopyWith$Input$CityWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$city_id = city_id;
    final l$city_name = city_name;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityWhereInput<TRes> {
  factory CopyWith$Input$CityWhereInput(
    Input$CityWhereInput instance,
    TRes Function(Input$CityWhereInput) then,
  ) = _CopyWithImpl$Input$CityWhereInput;

  factory CopyWith$Input$CityWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityWhereInput;

  TRes call({
    List<Input$CityWhereInput>? AND,
    List<Input$CityWhereInput>? OR,
    List<Input$CityWhereInput>? NOT,
    Input$IntFilter? city_id,
    Input$StringFilter? city_name,
    Input$TransactionsListRelationFilter? Transactions,
  });
  TRes AND(
      Iterable<Input$CityWhereInput>? Function(
              Iterable<CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$CityWhereInput>? Function(
              Iterable<CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$CityWhereInput>? Function(
              Iterable<CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get city_id;
  CopyWith$Input$StringFilter<TRes> get city_name;
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions;
}

class _CopyWithImpl$Input$CityWhereInput<TRes>
    implements CopyWith$Input$CityWhereInput<TRes> {
  _CopyWithImpl$Input$CityWhereInput(
    this._instance,
    this._then,
  );

  final Input$CityWhereInput _instance;

  final TRes Function(Input$CityWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? city_id = _undefined,
    Object? city_name = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$CityWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$CityWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$CityWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$CityWhereInput>?),
        if (city_id != _undefined) 'city_id': (city_id as Input$IntFilter?),
        if (city_name != _undefined)
          'city_name': (city_name as Input$StringFilter?),
        if (Transactions != _undefined)
          'Transactions':
              (Transactions as Input$TransactionsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$CityWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$CityWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$CityWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$CityWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$CityWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$CityWhereInput<Input$CityWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$CityWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get city_name {
    final local$city_name = _instance.city_name;
    return local$city_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$city_name, (e) => call(city_name: e));
  }

  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionsListRelationFilter(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$CityWhereInput<TRes>
    implements CopyWith$Input$CityWhereInput<TRes> {
  _CopyWithStubImpl$Input$CityWhereInput(this._res);

  TRes _res;

  call({
    List<Input$CityWhereInput>? AND,
    List<Input$CityWhereInput>? OR,
    List<Input$CityWhereInput>? NOT,
    Input$IntFilter? city_id,
    Input$StringFilter? city_name,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get city_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get city_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions =>
      CopyWith$Input$TransactionsListRelationFilter.stub(_res);
}

class Input$IntFilter {
  factory Input$IntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$IntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$IntFilter._(this._$data);

  factory Input$IntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$IntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IntFilter<Input$IntFilter> get copyWith =>
      CopyWith$Input$IntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFilter<TRes> {
  factory CopyWith$Input$IntFilter(
    Input$IntFilter instance,
    TRes Function(Input$IntFilter) then,
  ) = _CopyWithImpl$Input$IntFilter;

  factory CopyWith$Input$IntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithImpl$Input$IntFilter(
    this._instance,
    this._then,
  );

  final Input$IntFilter _instance;

  final TRes Function(Input$IntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$IntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$IntFilter<TRes>
    implements CopyWith$Input$IntFilter<TRes> {
  _CopyWithStubImpl$Input$IntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$NestedIntFilter {
  factory Input$NestedIntFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      Input$NestedIntFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedIntFilter._(this._$data);

  factory Input$NestedIntFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedIntFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntFilter? get not => (_$data['not'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntFilter<Input$NestedIntFilter> get copyWith =>
      CopyWith$Input$NestedIntFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntFilter<TRes> {
  factory CopyWith$Input$NestedIntFilter(
    Input$NestedIntFilter instance,
    TRes Function(Input$NestedIntFilter) then,
  ) = _CopyWithImpl$Input$NestedIntFilter;

  factory CopyWith$Input$NestedIntFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  });
  CopyWith$Input$NestedIntFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithImpl$Input$NestedIntFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntFilter _instance;

  final TRes Function(Input$NestedIntFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedIntFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined) 'not': (not as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntFilter<TRes>
    implements CopyWith$Input$NestedIntFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedIntFilter<TRes> get not =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$StringFilter {
  factory Input$StringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$StringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$StringFilter._(this._$data);

  factory Input$StringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$StringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringFilter<Input$StringFilter> get copyWith =>
      CopyWith$Input$StringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringFilter<TRes> {
  factory CopyWith$Input$StringFilter(
    Input$StringFilter instance,
    TRes Function(Input$StringFilter) then,
  ) = _CopyWithImpl$Input$StringFilter;

  factory CopyWith$Input$StringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithImpl$Input$StringFilter(
    this._instance,
    this._then,
  );

  final Input$StringFilter _instance;

  final TRes Function(Input$StringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$StringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$StringFilter<TRes>
    implements CopyWith$Input$StringFilter<TRes> {
  _CopyWithStubImpl$Input$StringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$NestedStringFilter {
  factory Input$NestedStringFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      Input$NestedStringFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
      });

  Input$NestedStringFilter._(this._$data);

  factory Input$NestedStringFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedStringFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringFilter? get not =>
      (_$data['not'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringFilter<Input$NestedStringFilter> get copyWith =>
      CopyWith$Input$NestedStringFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringFilter<TRes> {
  factory CopyWith$Input$NestedStringFilter(
    Input$NestedStringFilter instance,
    TRes Function(Input$NestedStringFilter) then,
  ) = _CopyWithImpl$Input$NestedStringFilter;

  factory CopyWith$Input$NestedStringFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  });
  CopyWith$Input$NestedStringFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithImpl$Input$NestedStringFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringFilter _instance;

  final TRes Function(Input$NestedStringFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedStringFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined) 'not': (not as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringFilter<TRes>
    implements CopyWith$Input$NestedStringFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedStringFilter<TRes> get not =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$TransactionsListRelationFilter {
  factory Input$TransactionsListRelationFilter({
    Input$TransactionsWhereInput? every,
    Input$TransactionsWhereInput? some,
    Input$TransactionsWhereInput? none,
  }) =>
      Input$TransactionsListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$TransactionsListRelationFilter._(this._$data);

  factory Input$TransactionsListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$TransactionsWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TransactionsWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TransactionsWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$TransactionsListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereInput? get every =>
      (_$data['every'] as Input$TransactionsWhereInput?);
  Input$TransactionsWhereInput? get some =>
      (_$data['some'] as Input$TransactionsWhereInput?);
  Input$TransactionsWhereInput? get none =>
      (_$data['none'] as Input$TransactionsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsListRelationFilter<
          Input$TransactionsListRelationFilter>
      get copyWith => CopyWith$Input$TransactionsListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsListRelationFilter<TRes> {
  factory CopyWith$Input$TransactionsListRelationFilter(
    Input$TransactionsListRelationFilter instance,
    TRes Function(Input$TransactionsListRelationFilter) then,
  ) = _CopyWithImpl$Input$TransactionsListRelationFilter;

  factory CopyWith$Input$TransactionsListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsListRelationFilter;

  TRes call({
    Input$TransactionsWhereInput? every,
    Input$TransactionsWhereInput? some,
    Input$TransactionsWhereInput? none,
  });
  CopyWith$Input$TransactionsWhereInput<TRes> get every;
  CopyWith$Input$TransactionsWhereInput<TRes> get some;
  CopyWith$Input$TransactionsWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$TransactionsListRelationFilter<TRes>
    implements CopyWith$Input$TransactionsListRelationFilter<TRes> {
  _CopyWithImpl$Input$TransactionsListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$TransactionsListRelationFilter _instance;

  final TRes Function(Input$TransactionsListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$TransactionsListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$TransactionsWhereInput?),
        if (some != _undefined) 'some': (some as Input$TransactionsWhereInput?),
        if (none != _undefined) 'none': (none as Input$TransactionsWhereInput?),
      }));
  CopyWith$Input$TransactionsWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$TransactionsWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$TransactionsWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TransactionsWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereInput(
            local$some, (e) => call(some: e));
  }

  CopyWith$Input$TransactionsWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TransactionsWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereInput(
            local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsListRelationFilter<TRes>
    implements CopyWith$Input$TransactionsListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$TransactionsListRelationFilter(this._res);

  TRes _res;

  call({
    Input$TransactionsWhereInput? every,
    Input$TransactionsWhereInput? some,
    Input$TransactionsWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereInput<TRes> get every =>
      CopyWith$Input$TransactionsWhereInput.stub(_res);
  CopyWith$Input$TransactionsWhereInput<TRes> get some =>
      CopyWith$Input$TransactionsWhereInput.stub(_res);
  CopyWith$Input$TransactionsWhereInput<TRes> get none =>
      CopyWith$Input$TransactionsWhereInput.stub(_res);
}

class Input$TransactionsWhereInput {
  factory Input$TransactionsWhereInput({
    List<Input$TransactionsWhereInput>? AND,
    List<Input$TransactionsWhereInput>? OR,
    List<Input$TransactionsWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$SellersRelationFilter? seller,
    Input$CityRelationFilter? city,
    Input$IntFilter? transaction_type_id,
    Input$TransactionTypesRelationFilter? transaction_type,
    Input$IntFilter? status_id,
    Input$TransactionStatusRelationFilter? status,
    Input$PayementsListRelationFilter? Payements,
  }) =>
      Input$TransactionsWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status_id != null) r'status_id': status_id,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsWhereInput._(this._$data);

  factory Input$TransactionsWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : Input$IntFilter.fromJson((l$seller_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFilter.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFilter.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFilter.fromJson((l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFilter.fromJson((l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFilter.fromJson((l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersRelationFilter.fromJson(
              (l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityRelationFilter.fromJson((l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_type_id as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesRelationFilter.fromJson(
              (l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : Input$IntFilter.fromJson((l$status_id as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusRelationFilter.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsListRelationFilter.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionsWhereInput>?);
  List<Input$TransactionsWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionsWhereInput>?);
  List<Input$TransactionsWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionsWhereInput>?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$IntFilter? get seller_id => (_$data['seller_id'] as Input$IntFilter?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$StringFilter? get customer_name =>
      (_$data['customer_name'] as Input$StringFilter?);
  Input$StringFilter? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFilter?);
  Input$IntFilter? get city_id => (_$data['city_id'] as Input$IntFilter?);
  Input$StringFilter? get address => (_$data['address'] as Input$StringFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Input$DateTimeFilter? get date => (_$data['date'] as Input$DateTimeFilter?);
  Input$FloatFilter? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFilter?);
  Input$FloatFilter? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFilter?);
  Input$SellersRelationFilter? get seller =>
      (_$data['seller'] as Input$SellersRelationFilter?);
  Input$CityRelationFilter? get city =>
      (_$data['city'] as Input$CityRelationFilter?);
  Input$IntFilter? get transaction_type_id =>
      (_$data['transaction_type_id'] as Input$IntFilter?);
  Input$TransactionTypesRelationFilter? get transaction_type =>
      (_$data['transaction_type'] as Input$TransactionTypesRelationFilter?);
  Input$IntFilter? get status_id => (_$data['status_id'] as Input$IntFilter?);
  Input$TransactionStatusRelationFilter? get status =>
      (_$data['status'] as Input$TransactionStatusRelationFilter?);
  Input$PayementsListRelationFilter? get Payements =>
      (_$data['Payements'] as Input$PayementsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] = l$status_id?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsWhereInput<Input$TransactionsWhereInput>
      get copyWith => CopyWith$Input$TransactionsWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type_id = transaction_type_id;
    final l$transaction_type = transaction_type;
    final l$status_id = status_id;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsWhereInput<TRes> {
  factory CopyWith$Input$TransactionsWhereInput(
    Input$TransactionsWhereInput instance,
    TRes Function(Input$TransactionsWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionsWhereInput;

  factory CopyWith$Input$TransactionsWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsWhereInput;

  TRes call({
    List<Input$TransactionsWhereInput>? AND,
    List<Input$TransactionsWhereInput>? OR,
    List<Input$TransactionsWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$SellersRelationFilter? seller,
    Input$CityRelationFilter? city,
    Input$IntFilter? transaction_type_id,
    Input$TransactionTypesRelationFilter? transaction_type,
    Input$IntFilter? status_id,
    Input$TransactionStatusRelationFilter? status,
    Input$PayementsListRelationFilter? Payements,
  });
  TRes AND(
      Iterable<Input$TransactionsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereInput<
                      Input$TransactionsWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereInput<
                      Input$TransactionsWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereInput<
                      Input$TransactionsWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$IntFilter<TRes> get seller_id;
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$StringFilter<TRes> get customer_name;
  CopyWith$Input$StringFilter<TRes> get customer_phone;
  CopyWith$Input$IntFilter<TRes> get city_id;
  CopyWith$Input$StringFilter<TRes> get address;
  CopyWith$Input$IntFilter<TRes> get quantity;
  CopyWith$Input$DateTimeFilter<TRes> get date;
  CopyWith$Input$FloatFilter<TRes> get remainingPayement;
  CopyWith$Input$FloatFilter<TRes> get totalPayement;
  CopyWith$Input$SellersRelationFilter<TRes> get seller;
  CopyWith$Input$CityRelationFilter<TRes> get city;
  CopyWith$Input$IntFilter<TRes> get transaction_type_id;
  CopyWith$Input$TransactionTypesRelationFilter<TRes> get transaction_type;
  CopyWith$Input$IntFilter<TRes> get status_id;
  CopyWith$Input$TransactionStatusRelationFilter<TRes> get status;
  CopyWith$Input$PayementsListRelationFilter<TRes> get Payements;
}

class _CopyWithImpl$Input$TransactionsWhereInput<TRes>
    implements CopyWith$Input$TransactionsWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionsWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsWhereInput _instance;

  final TRes Function(Input$TransactionsWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type_id = _undefined,
    Object? transaction_type = _undefined,
    Object? status_id = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionsWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$TransactionsWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionsWhereInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Input$IntFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Input$StringFilter?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Input$StringFilter?),
        if (city_id != _undefined) 'city_id': (city_id as Input$IntFilter?),
        if (address != _undefined) 'address': (address as Input$StringFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
        if (date != _undefined) 'date': (date as Input$DateTimeFilter?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Input$FloatFilter?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Input$FloatFilter?),
        if (seller != _undefined)
          'seller': (seller as Input$SellersRelationFilter?),
        if (city != _undefined) 'city': (city as Input$CityRelationFilter?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Input$IntFilter?),
        if (transaction_type != _undefined)
          'transaction_type':
              (transaction_type as Input$TransactionTypesRelationFilter?),
        if (status_id != _undefined)
          'status_id': (status_id as Input$IntFilter?),
        if (status != _undefined)
          'status': (status as Input$TransactionStatusRelationFilter?),
        if (Payements != _undefined)
          'Payements': (Payements as Input$PayementsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereInput<
                          Input$TransactionsWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$TransactionsWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereInput<
                          Input$TransactionsWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$TransactionsWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereInput<
                          Input$TransactionsWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$TransactionsWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get seller_id {
    final local$seller_id = _instance.seller_id;
    return local$seller_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$seller_id, (e) => call(seller_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFilter<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$IntFilter<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFilter<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFilter<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersRelationFilter<TRes> get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersRelationFilter.stub(_then(_instance))
        : CopyWith$Input$SellersRelationFilter(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityRelationFilter<TRes> get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityRelationFilter.stub(_then(_instance))
        : CopyWith$Input$CityRelationFilter(local$city, (e) => call(city: e));
  }

  CopyWith$Input$IntFilter<TRes> get transaction_type_id {
    final local$transaction_type_id = _instance.transaction_type_id;
    return local$transaction_type_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_type_id, (e) => call(transaction_type_id: e));
  }

  CopyWith$Input$TransactionTypesRelationFilter<TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionTypesRelationFilter(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$IntFilter<TRes> get status_id {
    final local$status_id = _instance.status_id;
    return local$status_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$status_id, (e) => call(status_id: e));
  }

  CopyWith$Input$TransactionStatusRelationFilter<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionStatusRelationFilter(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsListRelationFilter<TRes> get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$PayementsListRelationFilter(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsWhereInput<TRes>
    implements CopyWith$Input$TransactionsWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionsWhereInput>? AND,
    List<Input$TransactionsWhereInput>? OR,
    List<Input$TransactionsWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$SellersRelationFilter? seller,
    Input$CityRelationFilter? city,
    Input$IntFilter? transaction_type_id,
    Input$TransactionTypesRelationFilter? transaction_type,
    Input$IntFilter? status_id,
    Input$TransactionStatusRelationFilter? status,
    Input$PayementsListRelationFilter? Payements,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get seller_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get customer_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get customer_phone =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get city_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get address =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get date =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get remainingPayement =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get totalPayement =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$SellersRelationFilter<TRes> get seller =>
      CopyWith$Input$SellersRelationFilter.stub(_res);
  CopyWith$Input$CityRelationFilter<TRes> get city =>
      CopyWith$Input$CityRelationFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get transaction_type_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$TransactionTypesRelationFilter<TRes> get transaction_type =>
      CopyWith$Input$TransactionTypesRelationFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get status_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$TransactionStatusRelationFilter<TRes> get status =>
      CopyWith$Input$TransactionStatusRelationFilter.stub(_res);
  CopyWith$Input$PayementsListRelationFilter<TRes> get Payements =>
      CopyWith$Input$PayementsListRelationFilter.stub(_res);
}

class Input$DateTimeFilter {
  factory Input$DateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$DateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$DateTimeFilter._(this._$data);

  factory Input$DateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$DateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFilter<Input$DateTimeFilter> get copyWith =>
      CopyWith$Input$DateTimeFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeFilter<TRes> {
  factory CopyWith$Input$DateTimeFilter(
    Input$DateTimeFilter instance,
    TRes Function(Input$DateTimeFilter) then,
  ) = _CopyWithImpl$Input$DateTimeFilter;

  factory CopyWith$Input$DateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithImpl$Input$DateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeFilter _instance;

  final TRes Function(Input$DateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$DateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeFilter<TRes>
    implements CopyWith$Input$DateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$NestedDateTimeFilter {
  factory Input$NestedDateTimeFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      Input$NestedDateTimeFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedDateTimeFilter._(this._$data);

  factory Input$NestedDateTimeFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    return Input$NestedDateTimeFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeFilter<Input$NestedDateTimeFilter>
      get copyWith => CopyWith$Input$NestedDateTimeFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeFilter(
    Input$NestedDateTimeFilter instance,
    TRes Function(Input$NestedDateTimeFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeFilter;

  factory CopyWith$Input$NestedDateTimeFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  });
  CopyWith$Input$NestedDateTimeFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeFilter _instance;

  final TRes Function(Input$NestedDateTimeFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedDateTimeFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined) 'not': (not as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeFilter<TRes>
    implements CopyWith$Input$NestedDateTimeFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$FloatFilter {
  factory Input$FloatFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  }) =>
      Input$FloatFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$FloatFilter._(this._$data);

  factory Input$FloatFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$FloatFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatFilter? get not =>
      (_$data['not'] as Input$NestedFloatFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FloatFilter<Input$FloatFilter> get copyWith =>
      CopyWith$Input$FloatFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FloatFilter) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatFilter<TRes> {
  factory CopyWith$Input$FloatFilter(
    Input$FloatFilter instance,
    TRes Function(Input$FloatFilter) then,
  ) = _CopyWithImpl$Input$FloatFilter;

  factory CopyWith$Input$FloatFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  });
  CopyWith$Input$NestedFloatFilter<TRes> get not;
}

class _CopyWithImpl$Input$FloatFilter<TRes>
    implements CopyWith$Input$FloatFilter<TRes> {
  _CopyWithImpl$Input$FloatFilter(
    this._instance,
    this._then,
  );

  final Input$FloatFilter _instance;

  final TRes Function(Input$FloatFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$FloatFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined) 'not': (not as Input$NestedFloatFilter?),
      }));
  CopyWith$Input$NestedFloatFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$FloatFilter<TRes>
    implements CopyWith$Input$FloatFilter<TRes> {
  _CopyWithStubImpl$Input$FloatFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedFloatFilter<TRes> get not =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
}

class Input$NestedFloatFilter {
  factory Input$NestedFloatFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  }) =>
      Input$NestedFloatFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
      });

  Input$NestedFloatFilter._(this._$data);

  factory Input$NestedFloatFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$not as Map<String, dynamic>));
    }
    return Input$NestedFloatFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatFilter? get not =>
      (_$data['not'] as Input$NestedFloatFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedFloatFilter<Input$NestedFloatFilter> get copyWith =>
      CopyWith$Input$NestedFloatFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedFloatFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedFloatFilter<TRes> {
  factory CopyWith$Input$NestedFloatFilter(
    Input$NestedFloatFilter instance,
    TRes Function(Input$NestedFloatFilter) then,
  ) = _CopyWithImpl$Input$NestedFloatFilter;

  factory CopyWith$Input$NestedFloatFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedFloatFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  });
  CopyWith$Input$NestedFloatFilter<TRes> get not;
}

class _CopyWithImpl$Input$NestedFloatFilter<TRes>
    implements CopyWith$Input$NestedFloatFilter<TRes> {
  _CopyWithImpl$Input$NestedFloatFilter(
    this._instance,
    this._then,
  );

  final Input$NestedFloatFilter _instance;

  final TRes Function(Input$NestedFloatFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
  }) =>
      _then(Input$NestedFloatFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined) 'not': (not as Input$NestedFloatFilter?),
      }));
  CopyWith$Input$NestedFloatFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$not, (e) => call(not: e));
  }
}

class _CopyWithStubImpl$Input$NestedFloatFilter<TRes>
    implements CopyWith$Input$NestedFloatFilter<TRes> {
  _CopyWithStubImpl$Input$NestedFloatFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatFilter? not,
  }) =>
      _res;
  CopyWith$Input$NestedFloatFilter<TRes> get not =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
}

class Input$SellersRelationFilter {
  factory Input$SellersRelationFilter({
    Input$SellersWhereInput? $is,
    Input$SellersWhereInput? isNot,
  }) =>
      Input$SellersRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$SellersRelationFilter._(this._$data);

  factory Input$SellersRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$SellersWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$SellersWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$SellersRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SellersWhereInput? get $is =>
      (_$data['is'] as Input$SellersWhereInput?);
  Input$SellersWhereInput? get isNot =>
      (_$data['isNot'] as Input$SellersWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersRelationFilter<Input$SellersRelationFilter>
      get copyWith => CopyWith$Input$SellersRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersRelationFilter<TRes> {
  factory CopyWith$Input$SellersRelationFilter(
    Input$SellersRelationFilter instance,
    TRes Function(Input$SellersRelationFilter) then,
  ) = _CopyWithImpl$Input$SellersRelationFilter;

  factory CopyWith$Input$SellersRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersRelationFilter;

  TRes call({
    Input$SellersWhereInput? $is,
    Input$SellersWhereInput? isNot,
  });
  CopyWith$Input$SellersWhereInput<TRes> get $is;
  CopyWith$Input$SellersWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$SellersRelationFilter<TRes>
    implements CopyWith$Input$SellersRelationFilter<TRes> {
  _CopyWithImpl$Input$SellersRelationFilter(
    this._instance,
    this._then,
  );

  final Input$SellersRelationFilter _instance;

  final TRes Function(Input$SellersRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$SellersRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$SellersWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$SellersWhereInput?),
      }));
  CopyWith$Input$SellersWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$SellersWhereInput.stub(_then(_instance))
        : CopyWith$Input$SellersWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$SellersWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$SellersWhereInput.stub(_then(_instance))
        : CopyWith$Input$SellersWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$SellersRelationFilter<TRes>
    implements CopyWith$Input$SellersRelationFilter<TRes> {
  _CopyWithStubImpl$Input$SellersRelationFilter(this._res);

  TRes _res;

  call({
    Input$SellersWhereInput? $is,
    Input$SellersWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$SellersWhereInput<TRes> get $is =>
      CopyWith$Input$SellersWhereInput.stub(_res);
  CopyWith$Input$SellersWhereInput<TRes> get isNot =>
      CopyWith$Input$SellersWhereInput.stub(_res);
}

class Input$SellersWhereInput {
  factory Input$SellersWhereInput({
    List<Input$SellersWhereInput>? AND,
    List<Input$SellersWhereInput>? OR,
    List<Input$SellersWhereInput>? NOT,
    Input$IntFilter? seller_id,
    Input$StringFilter? seller_name,
    Input$StringFilter? seller_phone,
    Input$StringFilter? picture,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      Input$SellersWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$SellersWhereInput._(this._$data);

  factory Input$SellersWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$SellersWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$SellersWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$SellersWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : Input$IntFilter.fromJson((l$seller_id as Map<String, dynamic>));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : Input$StringFilter.fromJson(
              (l$seller_name as Map<String, dynamic>));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : Input$StringFilter.fromJson(
              (l$seller_phone as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFilter.fromJson((l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsListRelationFilter.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$SellersWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SellersWhereInput>? get AND =>
      (_$data['AND'] as List<Input$SellersWhereInput>?);
  List<Input$SellersWhereInput>? get OR =>
      (_$data['OR'] as List<Input$SellersWhereInput>?);
  List<Input$SellersWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$SellersWhereInput>?);
  Input$IntFilter? get seller_id => (_$data['seller_id'] as Input$IntFilter?);
  Input$StringFilter? get seller_name =>
      (_$data['seller_name'] as Input$StringFilter?);
  Input$StringFilter? get seller_phone =>
      (_$data['seller_phone'] as Input$StringFilter?);
  Input$StringFilter? get picture => (_$data['picture'] as Input$StringFilter?);
  Input$TransactionsListRelationFilter? get Transactions =>
      (_$data['Transactions'] as Input$TransactionsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id?.toJson();
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] = l$seller_name?.toJson();
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] = l$seller_phone?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersWhereInput<Input$SellersWhereInput> get copyWith =>
      CopyWith$Input$SellersWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersWhereInput<TRes> {
  factory CopyWith$Input$SellersWhereInput(
    Input$SellersWhereInput instance,
    TRes Function(Input$SellersWhereInput) then,
  ) = _CopyWithImpl$Input$SellersWhereInput;

  factory CopyWith$Input$SellersWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersWhereInput;

  TRes call({
    List<Input$SellersWhereInput>? AND,
    List<Input$SellersWhereInput>? OR,
    List<Input$SellersWhereInput>? NOT,
    Input$IntFilter? seller_id,
    Input$StringFilter? seller_name,
    Input$StringFilter? seller_phone,
    Input$StringFilter? picture,
    Input$TransactionsListRelationFilter? Transactions,
  });
  TRes AND(
      Iterable<Input$SellersWhereInput>? Function(
              Iterable<
                  CopyWith$Input$SellersWhereInput<Input$SellersWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$SellersWhereInput>? Function(
              Iterable<
                  CopyWith$Input$SellersWhereInput<Input$SellersWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$SellersWhereInput>? Function(
              Iterable<
                  CopyWith$Input$SellersWhereInput<Input$SellersWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get seller_id;
  CopyWith$Input$StringFilter<TRes> get seller_name;
  CopyWith$Input$StringFilter<TRes> get seller_phone;
  CopyWith$Input$StringFilter<TRes> get picture;
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions;
}

class _CopyWithImpl$Input$SellersWhereInput<TRes>
    implements CopyWith$Input$SellersWhereInput<TRes> {
  _CopyWithImpl$Input$SellersWhereInput(
    this._instance,
    this._then,
  );

  final Input$SellersWhereInput _instance;

  final TRes Function(Input$SellersWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$SellersWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$SellersWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$SellersWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$SellersWhereInput>?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Input$IntFilter?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Input$StringFilter?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Input$StringFilter?),
        if (picture != _undefined) 'picture': (picture as Input$StringFilter?),
        if (Transactions != _undefined)
          'Transactions':
              (Transactions as Input$TransactionsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$SellersWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersWhereInput<
                          Input$SellersWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$SellersWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$SellersWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersWhereInput<
                          Input$SellersWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$SellersWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$SellersWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersWhereInput<
                          Input$SellersWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$SellersWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get seller_id {
    final local$seller_id = _instance.seller_id;
    return local$seller_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$seller_id, (e) => call(seller_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get seller_name {
    final local$seller_name = _instance.seller_name;
    return local$seller_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$seller_name, (e) => call(seller_name: e));
  }

  CopyWith$Input$StringFilter<TRes> get seller_phone {
    final local$seller_phone = _instance.seller_phone;
    return local$seller_phone == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$seller_phone, (e) => call(seller_phone: e));
  }

  CopyWith$Input$StringFilter<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionsListRelationFilter(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$SellersWhereInput<TRes>
    implements CopyWith$Input$SellersWhereInput<TRes> {
  _CopyWithStubImpl$Input$SellersWhereInput(this._res);

  TRes _res;

  call({
    List<Input$SellersWhereInput>? AND,
    List<Input$SellersWhereInput>? OR,
    List<Input$SellersWhereInput>? NOT,
    Input$IntFilter? seller_id,
    Input$StringFilter? seller_name,
    Input$StringFilter? seller_phone,
    Input$StringFilter? picture,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get seller_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get seller_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get seller_phone =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get picture =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions =>
      CopyWith$Input$TransactionsListRelationFilter.stub(_res);
}

class Input$CityRelationFilter {
  factory Input$CityRelationFilter({
    Input$CityWhereInput? $is,
    Input$CityWhereInput? isNot,
  }) =>
      Input$CityRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$CityRelationFilter._(this._$data);

  factory Input$CityRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$CityWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$CityWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$CityRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CityWhereInput? get $is => (_$data['is'] as Input$CityWhereInput?);
  Input$CityWhereInput? get isNot => (_$data['isNot'] as Input$CityWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityRelationFilter<Input$CityRelationFilter> get copyWith =>
      CopyWith$Input$CityRelationFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityRelationFilter<TRes> {
  factory CopyWith$Input$CityRelationFilter(
    Input$CityRelationFilter instance,
    TRes Function(Input$CityRelationFilter) then,
  ) = _CopyWithImpl$Input$CityRelationFilter;

  factory CopyWith$Input$CityRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$CityRelationFilter;

  TRes call({
    Input$CityWhereInput? $is,
    Input$CityWhereInput? isNot,
  });
  CopyWith$Input$CityWhereInput<TRes> get $is;
  CopyWith$Input$CityWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$CityRelationFilter<TRes>
    implements CopyWith$Input$CityRelationFilter<TRes> {
  _CopyWithImpl$Input$CityRelationFilter(
    this._instance,
    this._then,
  );

  final Input$CityRelationFilter _instance;

  final TRes Function(Input$CityRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$CityRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$CityWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$CityWhereInput?),
      }));
  CopyWith$Input$CityWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$CityWhereInput.stub(_then(_instance))
        : CopyWith$Input$CityWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$CityWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$CityWhereInput.stub(_then(_instance))
        : CopyWith$Input$CityWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$CityRelationFilter<TRes>
    implements CopyWith$Input$CityRelationFilter<TRes> {
  _CopyWithStubImpl$Input$CityRelationFilter(this._res);

  TRes _res;

  call({
    Input$CityWhereInput? $is,
    Input$CityWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$CityWhereInput<TRes> get $is =>
      CopyWith$Input$CityWhereInput.stub(_res);
  CopyWith$Input$CityWhereInput<TRes> get isNot =>
      CopyWith$Input$CityWhereInput.stub(_res);
}

class Input$TransactionTypesRelationFilter {
  factory Input$TransactionTypesRelationFilter({
    Input$TransactionTypesWhereInput? $is,
    Input$TransactionTypesWhereInput? isNot,
  }) =>
      Input$TransactionTypesRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$TransactionTypesRelationFilter._(this._$data);

  factory Input$TransactionTypesRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$TransactionTypesWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$TransactionTypesWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$TransactionTypesRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionTypesWhereInput? get $is =>
      (_$data['is'] as Input$TransactionTypesWhereInput?);
  Input$TransactionTypesWhereInput? get isNot =>
      (_$data['isNot'] as Input$TransactionTypesWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesRelationFilter<
          Input$TransactionTypesRelationFilter>
      get copyWith => CopyWith$Input$TransactionTypesRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesRelationFilter<TRes> {
  factory CopyWith$Input$TransactionTypesRelationFilter(
    Input$TransactionTypesRelationFilter instance,
    TRes Function(Input$TransactionTypesRelationFilter) then,
  ) = _CopyWithImpl$Input$TransactionTypesRelationFilter;

  factory CopyWith$Input$TransactionTypesRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesRelationFilter;

  TRes call({
    Input$TransactionTypesWhereInput? $is,
    Input$TransactionTypesWhereInput? isNot,
  });
  CopyWith$Input$TransactionTypesWhereInput<TRes> get $is;
  CopyWith$Input$TransactionTypesWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$TransactionTypesRelationFilter<TRes>
    implements CopyWith$Input$TransactionTypesRelationFilter<TRes> {
  _CopyWithImpl$Input$TransactionTypesRelationFilter(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesRelationFilter _instance;

  final TRes Function(Input$TransactionTypesRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$TransactionTypesRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$TransactionTypesWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$TransactionTypesWhereInput?),
      }));
  CopyWith$Input$TransactionTypesWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$TransactionTypesWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionTypesWhereInput(
            local$$is, (e) => call($is: e));
  }

  CopyWith$Input$TransactionTypesWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$TransactionTypesWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionTypesWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesRelationFilter<TRes>
    implements CopyWith$Input$TransactionTypesRelationFilter<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesRelationFilter(this._res);

  TRes _res;

  call({
    Input$TransactionTypesWhereInput? $is,
    Input$TransactionTypesWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesWhereInput<TRes> get $is =>
      CopyWith$Input$TransactionTypesWhereInput.stub(_res);
  CopyWith$Input$TransactionTypesWhereInput<TRes> get isNot =>
      CopyWith$Input$TransactionTypesWhereInput.stub(_res);
}

class Input$TransactionTypesWhereInput {
  factory Input$TransactionTypesWhereInput({
    List<Input$TransactionTypesWhereInput>? AND,
    List<Input$TransactionTypesWhereInput>? OR,
    List<Input$TransactionTypesWhereInput>? NOT,
    Input$IntFilter? transaction_type_id,
    Input$StringFilter? type_name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      Input$TransactionTypesWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionTypesWhereInput._(this._$data);

  factory Input$TransactionTypesWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionTypesWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionTypesWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionTypesWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_type_id as Map<String, dynamic>));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : Input$StringFilter.fromJson((l$type_name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsListRelationFilter.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionTypesWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionTypesWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionTypesWhereInput>?);
  List<Input$TransactionTypesWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionTypesWhereInput>?);
  List<Input$TransactionTypesWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionTypesWhereInput>?);
  Input$IntFilter? get transaction_type_id =>
      (_$data['transaction_type_id'] as Input$IntFilter?);
  Input$StringFilter? get type_name =>
      (_$data['type_name'] as Input$StringFilter?);
  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);
  Input$TransactionsListRelationFilter? get Transactions =>
      (_$data['Transactions'] as Input$TransactionsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id?.toJson();
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] = l$type_name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesWhereInput<Input$TransactionTypesWhereInput>
      get copyWith => CopyWith$Input$TransactionTypesWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesWhereInput<TRes> {
  factory CopyWith$Input$TransactionTypesWhereInput(
    Input$TransactionTypesWhereInput instance,
    TRes Function(Input$TransactionTypesWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesWhereInput;

  factory CopyWith$Input$TransactionTypesWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesWhereInput;

  TRes call({
    List<Input$TransactionTypesWhereInput>? AND,
    List<Input$TransactionTypesWhereInput>? OR,
    List<Input$TransactionTypesWhereInput>? NOT,
    Input$IntFilter? transaction_type_id,
    Input$StringFilter? type_name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  });
  TRes AND(
      Iterable<Input$TransactionTypesWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesWhereInput<
                      Input$TransactionTypesWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionTypesWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesWhereInput<
                      Input$TransactionTypesWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionTypesWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesWhereInput<
                      Input$TransactionTypesWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_type_id;
  CopyWith$Input$StringFilter<TRes> get type_name;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions;
}

class _CopyWithImpl$Input$TransactionTypesWhereInput<TRes>
    implements CopyWith$Input$TransactionTypesWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesWhereInput _instance;

  final TRes Function(Input$TransactionTypesWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionTypesWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionTypesWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionTypesWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionTypesWhereInput>?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Input$IntFilter?),
        if (type_name != _undefined)
          'type_name': (type_name as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (Transactions != _undefined)
          'Transactions':
              (Transactions as Input$TransactionsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionTypesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesWhereInput<
                          Input$TransactionTypesWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$TransactionTypesWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionTypesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesWhereInput<
                          Input$TransactionTypesWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$TransactionTypesWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionTypesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesWhereInput<
                          Input$TransactionTypesWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$TransactionTypesWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_type_id {
    final local$transaction_type_id = _instance.transaction_type_id;
    return local$transaction_type_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_type_id, (e) => call(transaction_type_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get type_name {
    final local$type_name = _instance.type_name;
    return local$type_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$type_name, (e) => call(type_name: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionsListRelationFilter(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesWhereInput<TRes>
    implements CopyWith$Input$TransactionTypesWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionTypesWhereInput>? AND,
    List<Input$TransactionTypesWhereInput>? OR,
    List<Input$TransactionTypesWhereInput>? NOT,
    Input$IntFilter? transaction_type_id,
    Input$StringFilter? type_name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_type_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get type_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions =>
      CopyWith$Input$TransactionsListRelationFilter.stub(_res);
}

class Input$TransactionStatusRelationFilter {
  factory Input$TransactionStatusRelationFilter({
    Input$TransactionStatusWhereInput? $is,
    Input$TransactionStatusWhereInput? isNot,
  }) =>
      Input$TransactionStatusRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$TransactionStatusRelationFilter._(this._$data);

  factory Input$TransactionStatusRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$TransactionStatusWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$TransactionStatusWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$TransactionStatusRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionStatusWhereInput? get $is =>
      (_$data['is'] as Input$TransactionStatusWhereInput?);
  Input$TransactionStatusWhereInput? get isNot =>
      (_$data['isNot'] as Input$TransactionStatusWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusRelationFilter<
          Input$TransactionStatusRelationFilter>
      get copyWith => CopyWith$Input$TransactionStatusRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusRelationFilter<TRes> {
  factory CopyWith$Input$TransactionStatusRelationFilter(
    Input$TransactionStatusRelationFilter instance,
    TRes Function(Input$TransactionStatusRelationFilter) then,
  ) = _CopyWithImpl$Input$TransactionStatusRelationFilter;

  factory CopyWith$Input$TransactionStatusRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusRelationFilter;

  TRes call({
    Input$TransactionStatusWhereInput? $is,
    Input$TransactionStatusWhereInput? isNot,
  });
  CopyWith$Input$TransactionStatusWhereInput<TRes> get $is;
  CopyWith$Input$TransactionStatusWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$TransactionStatusRelationFilter<TRes>
    implements CopyWith$Input$TransactionStatusRelationFilter<TRes> {
  _CopyWithImpl$Input$TransactionStatusRelationFilter(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusRelationFilter _instance;

  final TRes Function(Input$TransactionStatusRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$TransactionStatusRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined)
          'is': ($is as Input$TransactionStatusWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$TransactionStatusWhereInput?),
      }));
  CopyWith$Input$TransactionStatusWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$TransactionStatusWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionStatusWhereInput(
            local$$is, (e) => call($is: e));
  }

  CopyWith$Input$TransactionStatusWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$TransactionStatusWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionStatusWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusRelationFilter<TRes>
    implements CopyWith$Input$TransactionStatusRelationFilter<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusRelationFilter(this._res);

  TRes _res;

  call({
    Input$TransactionStatusWhereInput? $is,
    Input$TransactionStatusWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusWhereInput<TRes> get $is =>
      CopyWith$Input$TransactionStatusWhereInput.stub(_res);
  CopyWith$Input$TransactionStatusWhereInput<TRes> get isNot =>
      CopyWith$Input$TransactionStatusWhereInput.stub(_res);
}

class Input$TransactionStatusWhereInput {
  factory Input$TransactionStatusWhereInput({
    List<Input$TransactionStatusWhereInput>? AND,
    List<Input$TransactionStatusWhereInput>? OR,
    List<Input$TransactionStatusWhereInput>? NOT,
    Input$IntFilter? transaction_status_id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      Input$TransactionStatusWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionStatusWhereInput._(this._$data);

  factory Input$TransactionStatusWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionStatusWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_status_id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsListRelationFilter.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionStatusWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionStatusWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionStatusWhereInput>?);
  List<Input$TransactionStatusWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionStatusWhereInput>?);
  List<Input$TransactionStatusWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionStatusWhereInput>?);
  Input$IntFilter? get transaction_status_id =>
      (_$data['transaction_status_id'] as Input$IntFilter?);
  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);
  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);
  Input$TransactionsListRelationFilter? get Transactions =>
      (_$data['Transactions'] as Input$TransactionsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusWhereInput<Input$TransactionStatusWhereInput>
      get copyWith => CopyWith$Input$TransactionStatusWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusWhereInput<TRes> {
  factory CopyWith$Input$TransactionStatusWhereInput(
    Input$TransactionStatusWhereInput instance,
    TRes Function(Input$TransactionStatusWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusWhereInput;

  factory CopyWith$Input$TransactionStatusWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusWhereInput;

  TRes call({
    List<Input$TransactionStatusWhereInput>? AND,
    List<Input$TransactionStatusWhereInput>? OR,
    List<Input$TransactionStatusWhereInput>? NOT,
    Input$IntFilter? transaction_status_id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  });
  TRes AND(
      Iterable<Input$TransactionStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusWhereInput<
                      Input$TransactionStatusWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusWhereInput<
                      Input$TransactionStatusWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionStatusWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusWhereInput<
                      Input$TransactionStatusWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_status_id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions;
}

class _CopyWithImpl$Input$TransactionStatusWhereInput<TRes>
    implements CopyWith$Input$TransactionStatusWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusWhereInput _instance;

  final TRes Function(Input$TransactionStatusWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionStatusWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionStatusWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionStatusWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionStatusWhereInput>?),
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Input$IntFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (Transactions != _undefined)
          'Transactions':
              (Transactions as Input$TransactionsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusWhereInput<
                          Input$TransactionStatusWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$TransactionStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusWhereInput<
                          Input$TransactionStatusWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$TransactionStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionStatusWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusWhereInput<
                          Input$TransactionStatusWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$TransactionStatusWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_status_id {
    final local$transaction_status_id = _instance.transaction_status_id;
    return local$transaction_status_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_status_id, (e) => call(transaction_status_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionsListRelationFilter(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusWhereInput<TRes>
    implements CopyWith$Input$TransactionStatusWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionStatusWhereInput>? AND,
    List<Input$TransactionStatusWhereInput>? OR,
    List<Input$TransactionStatusWhereInput>? NOT,
    Input$IntFilter? transaction_status_id,
    Input$StringFilter? name,
    Input$StringFilter? description,
    Input$TransactionsListRelationFilter? Transactions,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_status_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$TransactionsListRelationFilter<TRes> get Transactions =>
      CopyWith$Input$TransactionsListRelationFilter.stub(_res);
}

class Input$PayementsListRelationFilter {
  factory Input$PayementsListRelationFilter({
    Input$PayementsWhereInput? every,
    Input$PayementsWhereInput? some,
    Input$PayementsWhereInput? none,
  }) =>
      Input$PayementsListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$PayementsListRelationFilter._(this._$data);

  factory Input$PayementsListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$PayementsWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$PayementsWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$PayementsWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$PayementsListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsWhereInput? get every =>
      (_$data['every'] as Input$PayementsWhereInput?);
  Input$PayementsWhereInput? get some =>
      (_$data['some'] as Input$PayementsWhereInput?);
  Input$PayementsWhereInput? get none =>
      (_$data['none'] as Input$PayementsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsListRelationFilter<Input$PayementsListRelationFilter>
      get copyWith => CopyWith$Input$PayementsListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsListRelationFilter<TRes> {
  factory CopyWith$Input$PayementsListRelationFilter(
    Input$PayementsListRelationFilter instance,
    TRes Function(Input$PayementsListRelationFilter) then,
  ) = _CopyWithImpl$Input$PayementsListRelationFilter;

  factory CopyWith$Input$PayementsListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsListRelationFilter;

  TRes call({
    Input$PayementsWhereInput? every,
    Input$PayementsWhereInput? some,
    Input$PayementsWhereInput? none,
  });
  CopyWith$Input$PayementsWhereInput<TRes> get every;
  CopyWith$Input$PayementsWhereInput<TRes> get some;
  CopyWith$Input$PayementsWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$PayementsListRelationFilter<TRes>
    implements CopyWith$Input$PayementsListRelationFilter<TRes> {
  _CopyWithImpl$Input$PayementsListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$PayementsListRelationFilter _instance;

  final TRes Function(Input$PayementsListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$PayementsListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined) 'every': (every as Input$PayementsWhereInput?),
        if (some != _undefined) 'some': (some as Input$PayementsWhereInput?),
        if (none != _undefined) 'none': (none as Input$PayementsWhereInput?),
      }));
  CopyWith$Input$PayementsWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$PayementsWhereInput.stub(_then(_instance))
        : CopyWith$Input$PayementsWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$PayementsWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$PayementsWhereInput.stub(_then(_instance))
        : CopyWith$Input$PayementsWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$PayementsWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$PayementsWhereInput.stub(_then(_instance))
        : CopyWith$Input$PayementsWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$PayementsListRelationFilter<TRes>
    implements CopyWith$Input$PayementsListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$PayementsListRelationFilter(this._res);

  TRes _res;

  call({
    Input$PayementsWhereInput? every,
    Input$PayementsWhereInput? some,
    Input$PayementsWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$PayementsWhereInput<TRes> get every =>
      CopyWith$Input$PayementsWhereInput.stub(_res);
  CopyWith$Input$PayementsWhereInput<TRes> get some =>
      CopyWith$Input$PayementsWhereInput.stub(_res);
  CopyWith$Input$PayementsWhereInput<TRes> get none =>
      CopyWith$Input$PayementsWhereInput.stub(_res);
}

class Input$PayementsWhereInput {
  factory Input$PayementsWhereInput({
    List<Input$PayementsWhereInput>? AND,
    List<Input$PayementsWhereInput>? OR,
    List<Input$PayementsWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
    Input$TransactionsRelationFilter? transaction,
  }) =>
      Input$PayementsWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
        if (transaction != null) r'transaction': transaction,
      });

  Input$PayementsWhereInput._(this._$data);

  factory Input$PayementsWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntFilter.fromJson((l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatFilter.fromJson((l$payement as Map<String, dynamic>));
    }
    if (data.containsKey('transaction')) {
      final l$transaction = data['transaction'];
      result$data['transaction'] = l$transaction == null
          ? null
          : Input$TransactionsRelationFilter.fromJson(
              (l$transaction as Map<String, dynamic>));
    }
    return Input$PayementsWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayementsWhereInput>? get AND =>
      (_$data['AND'] as List<Input$PayementsWhereInput>?);
  List<Input$PayementsWhereInput>? get OR =>
      (_$data['OR'] as List<Input$PayementsWhereInput>?);
  List<Input$PayementsWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$PayementsWhereInput>?);
  Input$IntFilter? get payement_id =>
      (_$data['payement_id'] as Input$IntFilter?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$FloatFilter? get payement => (_$data['payement'] as Input$FloatFilter?);
  Input$TransactionsRelationFilter? get transaction =>
      (_$data['transaction'] as Input$TransactionsRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    if (_$data.containsKey('transaction')) {
      final l$transaction = transaction;
      result$data['transaction'] = l$transaction?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsWhereInput<Input$PayementsWhereInput> get copyWith =>
      CopyWith$Input$PayementsWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    final l$transaction = transaction;
    final lOther$transaction = other.transaction;
    if (_$data.containsKey('transaction') !=
        other._$data.containsKey('transaction')) {
      return false;
    }
    if (l$transaction != lOther$transaction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    final l$transaction = transaction;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
      _$data.containsKey('transaction') ? l$transaction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsWhereInput<TRes> {
  factory CopyWith$Input$PayementsWhereInput(
    Input$PayementsWhereInput instance,
    TRes Function(Input$PayementsWhereInput) then,
  ) = _CopyWithImpl$Input$PayementsWhereInput;

  factory CopyWith$Input$PayementsWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsWhereInput;

  TRes call({
    List<Input$PayementsWhereInput>? AND,
    List<Input$PayementsWhereInput>? OR,
    List<Input$PayementsWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
    Input$TransactionsRelationFilter? transaction,
  });
  TRes AND(
      Iterable<Input$PayementsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereInput<
                      Input$PayementsWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$PayementsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereInput<
                      Input$PayementsWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$PayementsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereInput<
                      Input$PayementsWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get payement_id;
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$FloatFilter<TRes> get payement;
  CopyWith$Input$TransactionsRelationFilter<TRes> get transaction;
}

class _CopyWithImpl$Input$PayementsWhereInput<TRes>
    implements CopyWith$Input$PayementsWhereInput<TRes> {
  _CopyWithImpl$Input$PayementsWhereInput(
    this._instance,
    this._then,
  );

  final Input$PayementsWhereInput _instance;

  final TRes Function(Input$PayementsWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
    Object? transaction = _undefined,
  }) =>
      _then(Input$PayementsWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$PayementsWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$PayementsWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$PayementsWhereInput>?),
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntFilter?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatFilter?),
        if (transaction != _undefined)
          'transaction': (transaction as Input$TransactionsRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$PayementsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereInput<
                          Input$PayementsWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$PayementsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$PayementsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereInput<
                          Input$PayementsWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$PayementsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$PayementsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereInput<
                          Input$PayementsWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$PayementsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$FloatFilter<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$payement, (e) => call(payement: e));
  }

  CopyWith$Input$TransactionsRelationFilter<TRes> get transaction {
    final local$transaction = _instance.transaction;
    return local$transaction == null
        ? CopyWith$Input$TransactionsRelationFilter.stub(_then(_instance))
        : CopyWith$Input$TransactionsRelationFilter(
            local$transaction, (e) => call(transaction: e));
  }
}

class _CopyWithStubImpl$Input$PayementsWhereInput<TRes>
    implements CopyWith$Input$PayementsWhereInput<TRes> {
  _CopyWithStubImpl$Input$PayementsWhereInput(this._res);

  TRes _res;

  call({
    List<Input$PayementsWhereInput>? AND,
    List<Input$PayementsWhereInput>? OR,
    List<Input$PayementsWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
    Input$TransactionsRelationFilter? transaction,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get payement_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get payement =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$TransactionsRelationFilter<TRes> get transaction =>
      CopyWith$Input$TransactionsRelationFilter.stub(_res);
}

class Input$TransactionsRelationFilter {
  factory Input$TransactionsRelationFilter({
    Input$TransactionsWhereInput? $is,
    Input$TransactionsWhereInput? isNot,
  }) =>
      Input$TransactionsRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$TransactionsRelationFilter._(this._$data);

  factory Input$TransactionsRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$TransactionsWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$TransactionsWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$TransactionsRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereInput? get $is =>
      (_$data['is'] as Input$TransactionsWhereInput?);
  Input$TransactionsWhereInput? get isNot =>
      (_$data['isNot'] as Input$TransactionsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsRelationFilter<Input$TransactionsRelationFilter>
      get copyWith => CopyWith$Input$TransactionsRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsRelationFilter<TRes> {
  factory CopyWith$Input$TransactionsRelationFilter(
    Input$TransactionsRelationFilter instance,
    TRes Function(Input$TransactionsRelationFilter) then,
  ) = _CopyWithImpl$Input$TransactionsRelationFilter;

  factory CopyWith$Input$TransactionsRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsRelationFilter;

  TRes call({
    Input$TransactionsWhereInput? $is,
    Input$TransactionsWhereInput? isNot,
  });
  CopyWith$Input$TransactionsWhereInput<TRes> get $is;
  CopyWith$Input$TransactionsWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$TransactionsRelationFilter<TRes>
    implements CopyWith$Input$TransactionsRelationFilter<TRes> {
  _CopyWithImpl$Input$TransactionsRelationFilter(
    this._instance,
    this._then,
  );

  final Input$TransactionsRelationFilter _instance;

  final TRes Function(Input$TransactionsRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$TransactionsRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$TransactionsWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$TransactionsWhereInput?),
      }));
  CopyWith$Input$TransactionsWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$TransactionsWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$TransactionsWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$TransactionsWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsRelationFilter<TRes>
    implements CopyWith$Input$TransactionsRelationFilter<TRes> {
  _CopyWithStubImpl$Input$TransactionsRelationFilter(this._res);

  TRes _res;

  call({
    Input$TransactionsWhereInput? $is,
    Input$TransactionsWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereInput<TRes> get $is =>
      CopyWith$Input$TransactionsWhereInput.stub(_res);
  CopyWith$Input$TransactionsWhereInput<TRes> get isNot =>
      CopyWith$Input$TransactionsWhereInput.stub(_res);
}

class Input$CityOrderByWithRelationInput {
  factory Input$CityOrderByWithRelationInput({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      Input$CityOrderByWithRelationInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$CityOrderByWithRelationInput._(this._$data);

  factory Input$CityOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : fromJson$Enum$SortOrder((l$city_name as String));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsOrderByRelationAggregateInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$CityOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_name => (_$data['city_name'] as Enum$SortOrder?);
  Input$TransactionsOrderByRelationAggregateInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] =
          l$city_name == null ? null : toJson$Enum$SortOrder(l$city_name);
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityOrderByWithRelationInput<
          Input$CityOrderByWithRelationInput>
      get copyWith => CopyWith$Input$CityOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$CityOrderByWithRelationInput(
    Input$CityOrderByWithRelationInput instance,
    TRes Function(Input$CityOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$CityOrderByWithRelationInput;

  factory CopyWith$Input$CityOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  });
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$CityOrderByWithRelationInput<TRes>
    implements CopyWith$Input$CityOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$CityOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$CityOrderByWithRelationInput _instance;

  final TRes Function(Input$CityOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$CityOrderByWithRelationInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (city_name != _undefined)
          'city_name': (city_name as Enum$SortOrder?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsOrderByRelationAggregateInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$CityOrderByWithRelationInput<TRes>
    implements CopyWith$Input$CityOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$CityOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(_res);
}

class Input$TransactionsOrderByRelationAggregateInput {
  factory Input$TransactionsOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$TransactionsOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$TransactionsOrderByRelationAggregateInput._(this._$data);

  factory Input$TransactionsOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$TransactionsOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsOrderByRelationAggregateInput<
          Input$TransactionsOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$TransactionsOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsOrderByRelationAggregateInput(
    Input$TransactionsOrderByRelationAggregateInput instance,
    TRes Function(Input$TransactionsOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsOrderByRelationAggregateInput;

  factory CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$TransactionsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsOrderByRelationAggregateInput _instance;

  final TRes Function(Input$TransactionsOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$TransactionsOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$CityWhereUniqueInput {
  factory Input$CityWhereUniqueInput({int? city_id}) =>
      Input$CityWhereUniqueInput._({
        if (city_id != null) r'city_id': city_id,
      });

  Input$CityWhereUniqueInput._(this._$data);

  factory Input$CityWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = (l$city_id as int?);
    }
    return Input$CityWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get city_id => (_$data['city_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id;
    }
    return result$data;
  }

  CopyWith$Input$CityWhereUniqueInput<Input$CityWhereUniqueInput>
      get copyWith => CopyWith$Input$CityWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    return Object.hashAll(
        [_$data.containsKey('city_id') ? l$city_id : const {}]);
  }
}

abstract class CopyWith$Input$CityWhereUniqueInput<TRes> {
  factory CopyWith$Input$CityWhereUniqueInput(
    Input$CityWhereUniqueInput instance,
    TRes Function(Input$CityWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$CityWhereUniqueInput;

  factory CopyWith$Input$CityWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityWhereUniqueInput;

  TRes call({int? city_id});
}

class _CopyWithImpl$Input$CityWhereUniqueInput<TRes>
    implements CopyWith$Input$CityWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$CityWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$CityWhereUniqueInput _instance;

  final TRes Function(Input$CityWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? city_id = _undefined}) =>
      _then(Input$CityWhereUniqueInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as int?),
      }));
}

class _CopyWithStubImpl$Input$CityWhereUniqueInput<TRes>
    implements CopyWith$Input$CityWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$CityWhereUniqueInput(this._res);

  TRes _res;

  call({int? city_id}) => _res;
}

class Input$TransactionsOrderByWithRelationInput {
  factory Input$TransactionsOrderByWithRelationInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Input$SellersOrderByWithRelationInput? seller,
    Input$CityOrderByWithRelationInput? city,
    Enum$SortOrder? transaction_type_id,
    Input$TransactionTypesOrderByWithRelationInput? transaction_type,
    Enum$SortOrder? status_id,
    Input$TransactionStatusOrderByWithRelationInput? status,
    Input$PayementsOrderByRelationAggregateInput? Payements,
  }) =>
      Input$TransactionsOrderByWithRelationInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status_id != null) r'status_id': status_id,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsOrderByWithRelationInput._(this._$data);

  factory Input$TransactionsOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_name as String));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_phone as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$SortOrder((l$address as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : fromJson$Enum$SortOrder((l$date as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersOrderByWithRelationInput.fromJson(
              (l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityOrderByWithRelationInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesOrderByWithRelationInput.fromJson(
              (l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusOrderByWithRelationInput.fromJson(
              (l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsOrderByRelationAggregateInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_name =>
      (_$data['customer_name'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_phone =>
      (_$data['customer_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get address => (_$data['address'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get date => (_$data['date'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Input$SellersOrderByWithRelationInput? get seller =>
      (_$data['seller'] as Input$SellersOrderByWithRelationInput?);
  Input$CityOrderByWithRelationInput? get city =>
      (_$data['city'] as Input$CityOrderByWithRelationInput?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Input$TransactionTypesOrderByWithRelationInput? get transaction_type =>
      (_$data['transaction_type']
          as Input$TransactionTypesOrderByWithRelationInput?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Input$TransactionStatusOrderByWithRelationInput? get status =>
      (_$data['status'] as Input$TransactionStatusOrderByWithRelationInput?);
  Input$PayementsOrderByRelationAggregateInput? get Payements =>
      (_$data['Payements'] as Input$PayementsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name == null
          ? null
          : toJson$Enum$SortOrder(l$customer_name);
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : toJson$Enum$SortOrder(l$customer_phone);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$SortOrder(l$address);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] =
          l$date == null ? null : toJson$Enum$SortOrder(l$date);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsOrderByWithRelationInput<
          Input$TransactionsOrderByWithRelationInput>
      get copyWith => CopyWith$Input$TransactionsOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type_id = transaction_type_id;
    final l$transaction_type = transaction_type;
    final l$status_id = status_id;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$TransactionsOrderByWithRelationInput(
    Input$TransactionsOrderByWithRelationInput instance,
    TRes Function(Input$TransactionsOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$TransactionsOrderByWithRelationInput;

  factory CopyWith$Input$TransactionsOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Input$SellersOrderByWithRelationInput? seller,
    Input$CityOrderByWithRelationInput? city,
    Enum$SortOrder? transaction_type_id,
    Input$TransactionTypesOrderByWithRelationInput? transaction_type,
    Enum$SortOrder? status_id,
    Input$TransactionStatusOrderByWithRelationInput? status,
    Input$PayementsOrderByRelationAggregateInput? Payements,
  });
  CopyWith$Input$SellersOrderByWithRelationInput<TRes> get seller;
  CopyWith$Input$CityOrderByWithRelationInput<TRes> get city;
  CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes>
      get transaction_type;
  CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> get status;
  CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> get Payements;
}

class _CopyWithImpl$Input$TransactionsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$TransactionsOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsOrderByWithRelationInput _instance;

  final TRes Function(Input$TransactionsOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type_id = _undefined,
    Object? transaction_type = _undefined,
    Object? status_id = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsOrderByWithRelationInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Enum$SortOrder?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (address != _undefined) 'address': (address as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (date != _undefined) 'date': (date as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (seller != _undefined)
          'seller': (seller as Input$SellersOrderByWithRelationInput?),
        if (city != _undefined)
          'city': (city as Input$CityOrderByWithRelationInput?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesOrderByWithRelationInput?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
        if (status != _undefined)
          'status':
              (status as Input$TransactionStatusOrderByWithRelationInput?),
        if (Payements != _undefined)
          'Payements':
              (Payements as Input$PayementsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$SellersOrderByWithRelationInput<TRes> get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$SellersOrderByWithRelationInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityOrderByWithRelationInput<TRes> get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$CityOrderByWithRelationInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesOrderByWithRelationInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusOrderByWithRelationInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsOrderByRelationAggregateInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Input$SellersOrderByWithRelationInput? seller,
    Input$CityOrderByWithRelationInput? city,
    Enum$SortOrder? transaction_type_id,
    Input$TransactionTypesOrderByWithRelationInput? transaction_type,
    Enum$SortOrder? status_id,
    Input$TransactionStatusOrderByWithRelationInput? status,
    Input$PayementsOrderByRelationAggregateInput? Payements,
  }) =>
      _res;
  CopyWith$Input$SellersOrderByWithRelationInput<TRes> get seller =>
      CopyWith$Input$SellersOrderByWithRelationInput.stub(_res);
  CopyWith$Input$CityOrderByWithRelationInput<TRes> get city =>
      CopyWith$Input$CityOrderByWithRelationInput.stub(_res);
  CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesOrderByWithRelationInput.stub(_res);
  CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> get status =>
      CopyWith$Input$TransactionStatusOrderByWithRelationInput.stub(_res);
  CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> get Payements =>
      CopyWith$Input$PayementsOrderByRelationAggregateInput.stub(_res);
}

class Input$SellersOrderByWithRelationInput {
  factory Input$SellersOrderByWithRelationInput({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      Input$SellersOrderByWithRelationInput._({
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$SellersOrderByWithRelationInput._(this._$data);

  factory Input$SellersOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_name as String));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_phone as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsOrderByRelationAggregateInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$SellersOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_name => (_$data['seller_name'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_phone =>
      (_$data['seller_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Input$TransactionsOrderByRelationAggregateInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] =
          l$seller_name == null ? null : toJson$Enum$SortOrder(l$seller_name);
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] =
          l$seller_phone == null ? null : toJson$Enum$SortOrder(l$seller_phone);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersOrderByWithRelationInput<
          Input$SellersOrderByWithRelationInput>
      get copyWith => CopyWith$Input$SellersOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$SellersOrderByWithRelationInput(
    Input$SellersOrderByWithRelationInput instance,
    TRes Function(Input$SellersOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$SellersOrderByWithRelationInput;

  factory CopyWith$Input$SellersOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  });
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$SellersOrderByWithRelationInput<TRes>
    implements CopyWith$Input$SellersOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$SellersOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$SellersOrderByWithRelationInput _instance;

  final TRes Function(Input$SellersOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$SellersOrderByWithRelationInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Enum$SortOrder?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsOrderByRelationAggregateInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$SellersOrderByWithRelationInput<TRes>
    implements CopyWith$Input$SellersOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$SellersOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(_res);
}

class Input$TransactionTypesOrderByWithRelationInput {
  factory Input$TransactionTypesOrderByWithRelationInput({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      Input$TransactionTypesOrderByWithRelationInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionTypesOrderByWithRelationInput._(this._$data);

  factory Input$TransactionTypesOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : fromJson$Enum$SortOrder((l$type_name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsOrderByRelationAggregateInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionTypesOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get type_name => (_$data['type_name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Input$TransactionsOrderByRelationAggregateInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] =
          l$type_name == null ? null : toJson$Enum$SortOrder(l$type_name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesOrderByWithRelationInput<
          Input$TransactionTypesOrderByWithRelationInput>
      get copyWith => CopyWith$Input$TransactionTypesOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$TransactionTypesOrderByWithRelationInput(
    Input$TransactionTypesOrderByWithRelationInput instance,
    TRes Function(Input$TransactionTypesOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesOrderByWithRelationInput;

  factory CopyWith$Input$TransactionTypesOrderByWithRelationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  });
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionTypesOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesOrderByWithRelationInput _instance;

  final TRes Function(Input$TransactionTypesOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionTypesOrderByWithRelationInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (type_name != _undefined)
          'type_name': (type_name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsOrderByRelationAggregateInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionTypesOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(_res);
}

class Input$TransactionStatusOrderByWithRelationInput {
  factory Input$TransactionStatusOrderByWithRelationInput({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      Input$TransactionStatusOrderByWithRelationInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionStatusOrderByWithRelationInput._(this._$data);

  factory Input$TransactionStatusOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsOrderByRelationAggregateInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionStatusOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Input$TransactionsOrderByRelationAggregateInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusOrderByWithRelationInput<
          Input$TransactionStatusOrderByWithRelationInput>
      get copyWith => CopyWith$Input$TransactionStatusOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$TransactionStatusOrderByWithRelationInput(
    Input$TransactionStatusOrderByWithRelationInput instance,
    TRes Function(Input$TransactionStatusOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusOrderByWithRelationInput;

  factory CopyWith$Input$TransactionStatusOrderByWithRelationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  });
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionStatusOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusOrderByWithRelationInput _instance;

  final TRes Function(Input$TransactionStatusOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionStatusOrderByWithRelationInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsOrderByRelationAggregateInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionStatusOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionsOrderByRelationAggregateInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsOrderByRelationAggregateInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsOrderByRelationAggregateInput.stub(_res);
}

class Input$PayementsOrderByRelationAggregateInput {
  factory Input$PayementsOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$PayementsOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$PayementsOrderByRelationAggregateInput._(this._$data);

  factory Input$PayementsOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$PayementsOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$PayementsOrderByRelationAggregateInput<
          Input$PayementsOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$PayementsOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$PayementsOrderByRelationAggregateInput(
    Input$PayementsOrderByRelationAggregateInput instance,
    TRes Function(Input$PayementsOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsOrderByRelationAggregateInput;

  factory CopyWith$Input$PayementsOrderByRelationAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$PayementsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsOrderByRelationAggregateInput _instance;

  final TRes Function(Input$PayementsOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$PayementsOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$PayementsOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$TransactionsWhereUniqueInput {
  factory Input$TransactionsWhereUniqueInput({int? transaction_id}) =>
      Input$TransactionsWhereUniqueInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
      });

  Input$TransactionsWhereUniqueInput._(this._$data);

  factory Input$TransactionsWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = (l$transaction_id as int?);
    }
    return Input$TransactionsWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get transaction_id => (_$data['transaction_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id;
    }
    return result$data;
  }

  CopyWith$Input$TransactionsWhereUniqueInput<
          Input$TransactionsWhereUniqueInput>
      get copyWith => CopyWith$Input$TransactionsWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    return Object.hashAll(
        [_$data.containsKey('transaction_id') ? l$transaction_id : const {}]);
  }
}

abstract class CopyWith$Input$TransactionsWhereUniqueInput<TRes> {
  factory CopyWith$Input$TransactionsWhereUniqueInput(
    Input$TransactionsWhereUniqueInput instance,
    TRes Function(Input$TransactionsWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$TransactionsWhereUniqueInput;

  factory CopyWith$Input$TransactionsWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsWhereUniqueInput;

  TRes call({int? transaction_id});
}

class _CopyWithImpl$Input$TransactionsWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionsWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$TransactionsWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsWhereUniqueInput _instance;

  final TRes Function(Input$TransactionsWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_id = _undefined}) =>
      _then(Input$TransactionsWhereUniqueInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as int?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionsWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsWhereUniqueInput(this._res);

  TRes _res;

  call({int? transaction_id}) => _res;
}

class Input$PayementsOrderByWithRelationInput {
  factory Input$PayementsOrderByWithRelationInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$TransactionsOrderByWithRelationInput? transaction,
  }) =>
      Input$PayementsOrderByWithRelationInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
        if (transaction != null) r'transaction': transaction,
      });

  Input$PayementsOrderByWithRelationInput._(this._$data);

  factory Input$PayementsOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    if (data.containsKey('transaction')) {
      final l$transaction = data['transaction'];
      result$data['transaction'] = l$transaction == null
          ? null
          : Input$TransactionsOrderByWithRelationInput.fromJson(
              (l$transaction as Map<String, dynamic>));
    }
    return Input$PayementsOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Input$TransactionsOrderByWithRelationInput? get transaction =>
      (_$data['transaction'] as Input$TransactionsOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    if (_$data.containsKey('transaction')) {
      final l$transaction = transaction;
      result$data['transaction'] = l$transaction?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsOrderByWithRelationInput<
          Input$PayementsOrderByWithRelationInput>
      get copyWith => CopyWith$Input$PayementsOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    final l$transaction = transaction;
    final lOther$transaction = other.transaction;
    if (_$data.containsKey('transaction') !=
        other._$data.containsKey('transaction')) {
      return false;
    }
    if (l$transaction != lOther$transaction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    final l$transaction = transaction;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
      _$data.containsKey('transaction') ? l$transaction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$PayementsOrderByWithRelationInput(
    Input$PayementsOrderByWithRelationInput instance,
    TRes Function(Input$PayementsOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$PayementsOrderByWithRelationInput;

  factory CopyWith$Input$PayementsOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$TransactionsOrderByWithRelationInput? transaction,
  });
  CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> get transaction;
}

class _CopyWithImpl$Input$PayementsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$PayementsOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$PayementsOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$PayementsOrderByWithRelationInput _instance;

  final TRes Function(Input$PayementsOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
    Object? transaction = _undefined,
  }) =>
      _then(Input$PayementsOrderByWithRelationInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
        if (transaction != _undefined)
          'transaction':
              (transaction as Input$TransactionsOrderByWithRelationInput?),
      }));
  CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> get transaction {
    final local$transaction = _instance.transaction;
    return local$transaction == null
        ? CopyWith$Input$TransactionsOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsOrderByWithRelationInput(
            local$transaction, (e) => call(transaction: e));
  }
}

class _CopyWithStubImpl$Input$PayementsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$PayementsOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$PayementsOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$TransactionsOrderByWithRelationInput? transaction,
  }) =>
      _res;
  CopyWith$Input$TransactionsOrderByWithRelationInput<TRes> get transaction =>
      CopyWith$Input$TransactionsOrderByWithRelationInput.stub(_res);
}

class Input$PayementsWhereUniqueInput {
  factory Input$PayementsWhereUniqueInput(
          {Input$PayementsTransaction_idPayement_idCompoundUniqueInput?
              transaction_id_payement_id}) =>
      Input$PayementsWhereUniqueInput._({
        if (transaction_id_payement_id != null)
          r'transaction_id_payement_id': transaction_id_payement_id,
      });

  Input$PayementsWhereUniqueInput._(this._$data);

  factory Input$PayementsWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id_payement_id')) {
      final l$transaction_id_payement_id = data['transaction_id_payement_id'];
      result$data['transaction_id_payement_id'] =
          l$transaction_id_payement_id == null
              ? null
              : Input$PayementsTransaction_idPayement_idCompoundUniqueInput
                  .fromJson(
                      (l$transaction_id_payement_id as Map<String, dynamic>));
    }
    return Input$PayementsWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsTransaction_idPayement_idCompoundUniqueInput?
      get transaction_id_payement_id => (_$data['transaction_id_payement_id']
          as Input$PayementsTransaction_idPayement_idCompoundUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id_payement_id')) {
      final l$transaction_id_payement_id = transaction_id_payement_id;
      result$data['transaction_id_payement_id'] =
          l$transaction_id_payement_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsWhereUniqueInput<Input$PayementsWhereUniqueInput>
      get copyWith => CopyWith$Input$PayementsWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id_payement_id = transaction_id_payement_id;
    final lOther$transaction_id_payement_id = other.transaction_id_payement_id;
    if (_$data.containsKey('transaction_id_payement_id') !=
        other._$data.containsKey('transaction_id_payement_id')) {
      return false;
    }
    if (l$transaction_id_payement_id != lOther$transaction_id_payement_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id_payement_id = transaction_id_payement_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id_payement_id')
          ? l$transaction_id_payement_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$PayementsWhereUniqueInput<TRes> {
  factory CopyWith$Input$PayementsWhereUniqueInput(
    Input$PayementsWhereUniqueInput instance,
    TRes Function(Input$PayementsWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$PayementsWhereUniqueInput;

  factory CopyWith$Input$PayementsWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsWhereUniqueInput;

  TRes call(
      {Input$PayementsTransaction_idPayement_idCompoundUniqueInput?
          transaction_id_payement_id});
  CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<TRes>
      get transaction_id_payement_id;
}

class _CopyWithImpl$Input$PayementsWhereUniqueInput<TRes>
    implements CopyWith$Input$PayementsWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$PayementsWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$PayementsWhereUniqueInput _instance;

  final TRes Function(Input$PayementsWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_id_payement_id = _undefined}) =>
      _then(Input$PayementsWhereUniqueInput._({
        ..._instance._$data,
        if (transaction_id_payement_id != _undefined)
          'transaction_id_payement_id': (transaction_id_payement_id
              as Input$PayementsTransaction_idPayement_idCompoundUniqueInput?),
      }));
  CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<TRes>
      get transaction_id_payement_id {
    final local$transaction_id_payement_id =
        _instance.transaction_id_payement_id;
    return local$transaction_id_payement_id == null
        ? CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput
            .stub(_then(_instance))
        : CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput(
            local$transaction_id_payement_id,
            (e) => call(transaction_id_payement_id: e));
  }
}

class _CopyWithStubImpl$Input$PayementsWhereUniqueInput<TRes>
    implements CopyWith$Input$PayementsWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$PayementsWhereUniqueInput(this._res);

  TRes _res;

  call(
          {Input$PayementsTransaction_idPayement_idCompoundUniqueInput?
              transaction_id_payement_id}) =>
      _res;
  CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<TRes>
      get transaction_id_payement_id =>
          CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput
              .stub(_res);
}

class Input$PayementsTransaction_idPayement_idCompoundUniqueInput {
  factory Input$PayementsTransaction_idPayement_idCompoundUniqueInput({
    required int transaction_id,
    required int payement_id,
  }) =>
      Input$PayementsTransaction_idPayement_idCompoundUniqueInput._({
        r'transaction_id': transaction_id,
        r'payement_id': payement_id,
      });

  Input$PayementsTransaction_idPayement_idCompoundUniqueInput._(this._$data);

  factory Input$PayementsTransaction_idPayement_idCompoundUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$payement_id = data['payement_id'];
    result$data['payement_id'] = (l$payement_id as int);
    return Input$PayementsTransaction_idPayement_idCompoundUniqueInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get payement_id => (_$data['payement_id'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$payement_id = payement_id;
    result$data['payement_id'] = l$payement_id;
    return result$data;
  }

  CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
          Input$PayementsTransaction_idPayement_idCompoundUniqueInput>
      get copyWith =>
          CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$PayementsTransaction_idPayement_idCompoundUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$payement_id = payement_id;
    return Object.hashAll([
      l$transaction_id,
      l$payement_id,
    ]);
  }
}

abstract class CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
    TRes> {
  factory CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput(
    Input$PayementsTransaction_idPayement_idCompoundUniqueInput instance,
    TRes Function(Input$PayementsTransaction_idPayement_idCompoundUniqueInput)
        then,
  ) = _CopyWithImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput;

  factory CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput;

  TRes call({
    int? transaction_id,
    int? payement_id,
  });
}

class _CopyWithImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
        TRes>
    implements
        CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
            TRes> {
  _CopyWithImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput(
    this._instance,
    this._then,
  );

  final Input$PayementsTransaction_idPayement_idCompoundUniqueInput _instance;

  final TRes Function(
      Input$PayementsTransaction_idPayement_idCompoundUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? payement_id = _undefined,
  }) =>
      _then(Input$PayementsTransaction_idPayement_idCompoundUniqueInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (payement_id != _undefined && payement_id != null)
          'payement_id': (payement_id as int),
      }));
}

class _CopyWithStubImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
        TRes>
    implements
        CopyWith$Input$PayementsTransaction_idPayement_idCompoundUniqueInput<
            TRes> {
  _CopyWithStubImpl$Input$PayementsTransaction_idPayement_idCompoundUniqueInput(
      this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? payement_id,
  }) =>
      _res;
}

class Input$CityOrderByWithAggregationInput {
  factory Input$CityOrderByWithAggregationInput({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$CityCountOrderByAggregateInput? $_count,
    Input$CityAvgOrderByAggregateInput? $_avg,
    Input$CityMaxOrderByAggregateInput? $_max,
    Input$CityMinOrderByAggregateInput? $_min,
    Input$CitySumOrderByAggregateInput? $_sum,
  }) =>
      Input$CityOrderByWithAggregationInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$CityOrderByWithAggregationInput._(this._$data);

  factory Input$CityOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : fromJson$Enum$SortOrder((l$city_name as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$CityCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$CityAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$CityMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$CityMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$CitySumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$CityOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_name => (_$data['city_name'] as Enum$SortOrder?);
  Input$CityCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$CityCountOrderByAggregateInput?);
  Input$CityAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$CityAvgOrderByAggregateInput?);
  Input$CityMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$CityMaxOrderByAggregateInput?);
  Input$CityMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$CityMinOrderByAggregateInput?);
  Input$CitySumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$CitySumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] =
          l$city_name == null ? null : toJson$Enum$SortOrder(l$city_name);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityOrderByWithAggregationInput<
          Input$CityOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$CityOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$CityOrderByWithAggregationInput(
    Input$CityOrderByWithAggregationInput instance,
    TRes Function(Input$CityOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$CityOrderByWithAggregationInput;

  factory CopyWith$Input$CityOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$CityCountOrderByAggregateInput? $_count,
    Input$CityAvgOrderByAggregateInput? $_avg,
    Input$CityMaxOrderByAggregateInput? $_max,
    Input$CityMinOrderByAggregateInput? $_min,
    Input$CitySumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$CityCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$CityAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$CityMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$CityMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$CitySumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$CityOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$CityOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$CityOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$CityOrderByWithAggregationInput _instance;

  final TRes Function(Input$CityOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$CityOrderByWithAggregationInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (city_name != _undefined)
          'city_name': (city_name as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$CityCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$CityAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$CityMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$CityMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$CitySumOrderByAggregateInput?),
      }));
  CopyWith$Input$CityCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$CityCountOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$CityCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$CityAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$CityAvgOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$CityAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$CityMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$CityMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$CityMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$CityMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$CityMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$CityMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$CitySumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$CitySumOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$CitySumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$CityOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$CityOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$CityOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
    Input$CityCountOrderByAggregateInput? $_count,
    Input$CityAvgOrderByAggregateInput? $_avg,
    Input$CityMaxOrderByAggregateInput? $_max,
    Input$CityMinOrderByAggregateInput? $_min,
    Input$CitySumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$CityCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$CityCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$CityAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$CityAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$CityMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$CityMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$CityMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$CityMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$CitySumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$CitySumOrderByAggregateInput.stub(_res);
}

class Input$CityCountOrderByAggregateInput {
  factory Input$CityCountOrderByAggregateInput({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      Input$CityCountOrderByAggregateInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityCountOrderByAggregateInput._(this._$data);

  factory Input$CityCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : fromJson$Enum$SortOrder((l$city_name as String));
    }
    return Input$CityCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_name => (_$data['city_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] =
          l$city_name == null ? null : toJson$Enum$SortOrder(l$city_name);
    }
    return result$data;
  }

  CopyWith$Input$CityCountOrderByAggregateInput<
          Input$CityCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$CityCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$CityCountOrderByAggregateInput(
    Input$CityCountOrderByAggregateInput instance,
    TRes Function(Input$CityCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$CityCountOrderByAggregateInput;

  factory CopyWith$Input$CityCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  });
}

class _CopyWithImpl$Input$CityCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$CityCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$CityCountOrderByAggregateInput _instance;

  final TRes Function(Input$CityCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityCountOrderByAggregateInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (city_name != _undefined)
          'city_name': (city_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$CityCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$CityCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      _res;
}

class Input$CityAvgOrderByAggregateInput {
  factory Input$CityAvgOrderByAggregateInput({Enum$SortOrder? city_id}) =>
      Input$CityAvgOrderByAggregateInput._({
        if (city_id != null) r'city_id': city_id,
      });

  Input$CityAvgOrderByAggregateInput._(this._$data);

  factory Input$CityAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    return Input$CityAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    return result$data;
  }

  CopyWith$Input$CityAvgOrderByAggregateInput<
          Input$CityAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$CityAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    return Object.hashAll(
        [_$data.containsKey('city_id') ? l$city_id : const {}]);
  }
}

abstract class CopyWith$Input$CityAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$CityAvgOrderByAggregateInput(
    Input$CityAvgOrderByAggregateInput instance,
    TRes Function(Input$CityAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$CityAvgOrderByAggregateInput;

  factory CopyWith$Input$CityAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? city_id});
}

class _CopyWithImpl$Input$CityAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$CityAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$CityAvgOrderByAggregateInput _instance;

  final TRes Function(Input$CityAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? city_id = _undefined}) =>
      _then(Input$CityAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$CityAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$CityAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? city_id}) => _res;
}

class Input$CityMaxOrderByAggregateInput {
  factory Input$CityMaxOrderByAggregateInput({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      Input$CityMaxOrderByAggregateInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityMaxOrderByAggregateInput._(this._$data);

  factory Input$CityMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : fromJson$Enum$SortOrder((l$city_name as String));
    }
    return Input$CityMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_name => (_$data['city_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] =
          l$city_name == null ? null : toJson$Enum$SortOrder(l$city_name);
    }
    return result$data;
  }

  CopyWith$Input$CityMaxOrderByAggregateInput<
          Input$CityMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$CityMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$CityMaxOrderByAggregateInput(
    Input$CityMaxOrderByAggregateInput instance,
    TRes Function(Input$CityMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$CityMaxOrderByAggregateInput;

  factory CopyWith$Input$CityMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  });
}

class _CopyWithImpl$Input$CityMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$CityMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$CityMaxOrderByAggregateInput _instance;

  final TRes Function(Input$CityMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (city_name != _undefined)
          'city_name': (city_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$CityMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$CityMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      _res;
}

class Input$CityMinOrderByAggregateInput {
  factory Input$CityMinOrderByAggregateInput({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      Input$CityMinOrderByAggregateInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityMinOrderByAggregateInput._(this._$data);

  factory Input$CityMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : fromJson$Enum$SortOrder((l$city_name as String));
    }
    return Input$CityMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_name => (_$data['city_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] =
          l$city_name == null ? null : toJson$Enum$SortOrder(l$city_name);
    }
    return result$data;
  }

  CopyWith$Input$CityMinOrderByAggregateInput<
          Input$CityMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$CityMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$CityMinOrderByAggregateInput(
    Input$CityMinOrderByAggregateInput instance,
    TRes Function(Input$CityMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$CityMinOrderByAggregateInput;

  factory CopyWith$Input$CityMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  });
}

class _CopyWithImpl$Input$CityMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$CityMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$CityMinOrderByAggregateInput _instance;

  final TRes Function(Input$CityMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityMinOrderByAggregateInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (city_name != _undefined)
          'city_name': (city_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$CityMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$CityMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$CityMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? city_id,
    Enum$SortOrder? city_name,
  }) =>
      _res;
}

class Input$CitySumOrderByAggregateInput {
  factory Input$CitySumOrderByAggregateInput({Enum$SortOrder? city_id}) =>
      Input$CitySumOrderByAggregateInput._({
        if (city_id != null) r'city_id': city_id,
      });

  Input$CitySumOrderByAggregateInput._(this._$data);

  factory Input$CitySumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    return Input$CitySumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    return result$data;
  }

  CopyWith$Input$CitySumOrderByAggregateInput<
          Input$CitySumOrderByAggregateInput>
      get copyWith => CopyWith$Input$CitySumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CitySumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    return Object.hashAll(
        [_$data.containsKey('city_id') ? l$city_id : const {}]);
  }
}

abstract class CopyWith$Input$CitySumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$CitySumOrderByAggregateInput(
    Input$CitySumOrderByAggregateInput instance,
    TRes Function(Input$CitySumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$CitySumOrderByAggregateInput;

  factory CopyWith$Input$CitySumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CitySumOrderByAggregateInput;

  TRes call({Enum$SortOrder? city_id});
}

class _CopyWithImpl$Input$CitySumOrderByAggregateInput<TRes>
    implements CopyWith$Input$CitySumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$CitySumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$CitySumOrderByAggregateInput _instance;

  final TRes Function(Input$CitySumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? city_id = _undefined}) =>
      _then(Input$CitySumOrderByAggregateInput._({
        ..._instance._$data,
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$CitySumOrderByAggregateInput<TRes>
    implements CopyWith$Input$CitySumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$CitySumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? city_id}) => _res;
}

class Input$CityScalarWhereWithAggregatesInput {
  factory Input$CityScalarWhereWithAggregatesInput({
    List<Input$CityScalarWhereWithAggregatesInput>? AND,
    List<Input$CityScalarWhereWithAggregatesInput>? OR,
    List<Input$CityScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? city_name,
  }) =>
      Input$CityScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityScalarWhereWithAggregatesInput._(this._$data);

  factory Input$CityScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$CityScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$CityScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$CityScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$city_name as Map<String, dynamic>));
    }
    return Input$CityScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$CityScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$CityScalarWhereWithAggregatesInput>?);
  List<Input$CityScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$CityScalarWhereWithAggregatesInput>?);
  List<Input$CityScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$CityScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get city_id =>
      (_$data['city_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get city_name =>
      (_$data['city_name'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] = l$city_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityScalarWhereWithAggregatesInput<
          Input$CityScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$CityScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$CityScalarWhereWithAggregatesInput(
    Input$CityScalarWhereWithAggregatesInput instance,
    TRes Function(Input$CityScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$CityScalarWhereWithAggregatesInput;

  factory CopyWith$Input$CityScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$CityScalarWhereWithAggregatesInput>? AND,
    List<Input$CityScalarWhereWithAggregatesInput>? OR,
    List<Input$CityScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? city_name,
  });
  TRes AND(
      Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$CityScalarWhereWithAggregatesInput<
                      Input$CityScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$CityScalarWhereWithAggregatesInput<
                      Input$CityScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$CityScalarWhereWithAggregatesInput<
                      Input$CityScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get city_name;
}

class _CopyWithImpl$Input$CityScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$CityScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$CityScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$CityScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$CityScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$CityScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$CityScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$CityScalarWhereWithAggregatesInput>?),
        if (city_id != _undefined)
          'city_id': (city_id as Input$IntWithAggregatesFilter?),
        if (city_name != _undefined)
          'city_name': (city_name as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$CityScalarWhereWithAggregatesInput<
                          Input$CityScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$CityScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$CityScalarWhereWithAggregatesInput<
                          Input$CityScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$CityScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$CityScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$CityScalarWhereWithAggregatesInput<
                          Input$CityScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$CityScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get city_name {
    final local$city_name = _instance.city_name;
    return local$city_name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$city_name, (e) => call(city_name: e));
  }
}

class _CopyWithStubImpl$Input$CityScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$CityScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$CityScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$CityScalarWhereWithAggregatesInput>? AND,
    List<Input$CityScalarWhereWithAggregatesInput>? OR,
    List<Input$CityScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? city_name,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get city_name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$IntWithAggregatesFilter {
  factory Input$IntWithAggregatesFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  }) =>
      Input$IntWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_sum != null) r'_sum': $_sum,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$IntWithAggregatesFilter._(this._$data);

  factory Input$IntWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    return Input$IntWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedIntWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedFloatFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatFilter?);
  Input$NestedIntFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedIntFilter?);
  Input$NestedIntFilter? get $_min =>
      (_$data['_min'] as Input$NestedIntFilter?);
  Input$NestedIntFilter? get $_max =>
      (_$data['_max'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$IntWithAggregatesFilter<Input$IntWithAggregatesFilter>
      get copyWith => CopyWith$Input$IntWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntWithAggregatesFilter<TRes> {
  factory CopyWith$Input$IntWithAggregatesFilter(
    Input$IntWithAggregatesFilter instance,
    TRes Function(Input$IntWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$IntWithAggregatesFilter;

  factory CopyWith$Input$IntWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$IntWithAggregatesFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  });
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg;
  CopyWith$Input$NestedIntFilter<TRes> get $_sum;
  CopyWith$Input$NestedIntFilter<TRes> get $_min;
  CopyWith$Input$NestedIntFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$IntWithAggregatesFilter<TRes>
    implements CopyWith$Input$IntWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$IntWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$IntWithAggregatesFilter _instance;

  final TRes Function(Input$IntWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_sum = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$IntWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined)
          'not': (not as Input$NestedIntWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_avg != _undefined) '_avg': ($_avg as Input$NestedFloatFilter?),
        if ($_sum != _undefined) '_sum': ($_sum as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$IntWithAggregatesFilter<TRes>
    implements CopyWith$Input$IntWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$IntWithAggregatesFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedIntWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_sum =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_min =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_max =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$NestedIntWithAggregatesFilter {
  factory Input$NestedIntWithAggregatesFilter({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  }) =>
      Input$NestedIntWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_sum != null) r'_sum': $_sum,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$NestedIntWithAggregatesFilter._(this._$data);

  factory Input$NestedIntWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as int?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as int)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as int?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as int?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as int?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as int?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedIntWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    return Input$NestedIntWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get equals => (_$data['equals'] as int?);
  List<int>? get $in => (_$data['in'] as List<int>?);
  List<int>? get notIn => (_$data['notIn'] as List<int>?);
  int? get lt => (_$data['lt'] as int?);
  int? get lte => (_$data['lte'] as int?);
  int? get gt => (_$data['gt'] as int?);
  int? get gte => (_$data['gte'] as int?);
  Input$NestedIntWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedIntWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedFloatFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatFilter?);
  Input$NestedIntFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedIntFilter?);
  Input$NestedIntFilter? get $_min =>
      (_$data['_min'] as Input$NestedIntFilter?);
  Input$NestedIntFilter? get $_max =>
      (_$data['_max'] as Input$NestedIntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedIntWithAggregatesFilter<
          Input$NestedIntWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedIntWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedIntWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedIntWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedIntWithAggregatesFilter(
    Input$NestedIntWithAggregatesFilter instance,
    TRes Function(Input$NestedIntWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedIntWithAggregatesFilter;

  factory CopyWith$Input$NestedIntWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedIntWithAggregatesFilter;

  TRes call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  });
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg;
  CopyWith$Input$NestedIntFilter<TRes> get $_sum;
  CopyWith$Input$NestedIntFilter<TRes> get $_min;
  CopyWith$Input$NestedIntFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$NestedIntWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedIntWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedIntWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedIntWithAggregatesFilter _instance;

  final TRes Function(Input$NestedIntWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_sum = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$NestedIntWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as int?),
        if ($in != _undefined) 'in': ($in as List<int>?),
        if (notIn != _undefined) 'notIn': (notIn as List<int>?),
        if (lt != _undefined) 'lt': (lt as int?),
        if (lte != _undefined) 'lte': (lte as int?),
        if (gt != _undefined) 'gt': (gt as int?),
        if (gte != _undefined) 'gte': (gte as int?),
        if (not != _undefined)
          'not': (not as Input$NestedIntWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_avg != _undefined) '_avg': ($_avg as Input$NestedFloatFilter?),
        if ($_sum != _undefined) '_sum': ($_sum as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedIntFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedIntFilter?),
      }));
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedIntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$NestedIntWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedIntWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedIntWithAggregatesFilter(this._res);

  TRes _res;

  call({
    int? equals,
    List<int>? $in,
    List<int>? notIn,
    int? lt,
    int? lte,
    int? gt,
    int? gte,
    Input$NestedIntWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedIntFilter? $_sum,
    Input$NestedIntFilter? $_min,
    Input$NestedIntFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedIntWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedIntWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_sum =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_min =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_max =>
      CopyWith$Input$NestedIntFilter.stub(_res);
}

class Input$StringWithAggregatesFilter {
  factory Input$StringWithAggregatesFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  }) =>
      Input$StringWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$StringWithAggregatesFilter._(this._$data);

  factory Input$StringWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    return Input$StringWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);
  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$StringWithAggregatesFilter<Input$StringWithAggregatesFilter>
      get copyWith => CopyWith$Input$StringWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$StringWithAggregatesFilter<TRes> {
  factory CopyWith$Input$StringWithAggregatesFilter(
    Input$StringWithAggregatesFilter instance,
    TRes Function(Input$StringWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$StringWithAggregatesFilter;

  factory CopyWith$Input$StringWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$StringWithAggregatesFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  });
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$StringWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$StringWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$StringWithAggregatesFilter _instance;

  final TRes Function(Input$StringWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$StringWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$StringWithAggregatesFilter<TRes>
    implements CopyWith$Input$StringWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$StringWithAggregatesFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);
  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$NestedStringWithAggregatesFilter {
  factory Input$NestedStringWithAggregatesFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  }) =>
      Input$NestedStringWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (contains != null) r'contains': contains,
        if (startsWith != null) r'startsWith': startsWith,
        if (endsWith != null) r'endsWith': endsWith,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$NestedStringWithAggregatesFilter._(this._$data);

  factory Input$NestedStringWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('contains')) {
      final l$contains = data['contains'];
      result$data['contains'] = (l$contains as String?);
    }
    if (data.containsKey('startsWith')) {
      final l$startsWith = data['startsWith'];
      result$data['startsWith'] = (l$startsWith as String?);
    }
    if (data.containsKey('endsWith')) {
      final l$endsWith = data['endsWith'];
      result$data['endsWith'] = (l$endsWith as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedStringWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedStringFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    return Input$NestedStringWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  String? get contains => (_$data['contains'] as String?);
  String? get startsWith => (_$data['startsWith'] as String?);
  String? get endsWith => (_$data['endsWith'] as String?);
  Input$NestedStringWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedStringWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedStringFilter? get $_min =>
      (_$data['_min'] as Input$NestedStringFilter?);
  Input$NestedStringFilter? get $_max =>
      (_$data['_max'] as Input$NestedStringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('contains')) {
      final l$contains = contains;
      result$data['contains'] = l$contains;
    }
    if (_$data.containsKey('startsWith')) {
      final l$startsWith = startsWith;
      result$data['startsWith'] = l$startsWith;
    }
    if (_$data.containsKey('endsWith')) {
      final l$endsWith = endsWith;
      result$data['endsWith'] = l$endsWith;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedStringWithAggregatesFilter<
          Input$NestedStringWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedStringWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedStringWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$contains = contains;
    final lOther$contains = other.contains;
    if (_$data.containsKey('contains') !=
        other._$data.containsKey('contains')) {
      return false;
    }
    if (l$contains != lOther$contains) {
      return false;
    }
    final l$startsWith = startsWith;
    final lOther$startsWith = other.startsWith;
    if (_$data.containsKey('startsWith') !=
        other._$data.containsKey('startsWith')) {
      return false;
    }
    if (l$startsWith != lOther$startsWith) {
      return false;
    }
    final l$endsWith = endsWith;
    final lOther$endsWith = other.endsWith;
    if (_$data.containsKey('endsWith') !=
        other._$data.containsKey('endsWith')) {
      return false;
    }
    if (l$endsWith != lOther$endsWith) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$contains = contains;
    final l$startsWith = startsWith;
    final l$endsWith = endsWith;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('contains') ? l$contains : const {},
      _$data.containsKey('startsWith') ? l$startsWith : const {},
      _$data.containsKey('endsWith') ? l$endsWith : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedStringWithAggregatesFilter(
    Input$NestedStringWithAggregatesFilter instance,
    TRes Function(Input$NestedStringWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedStringWithAggregatesFilter;

  factory CopyWith$Input$NestedStringWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  });
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedStringFilter<TRes> get $_min;
  CopyWith$Input$NestedStringFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$NestedStringWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedStringWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedStringWithAggregatesFilter _instance;

  final TRes Function(Input$NestedStringWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? contains = _undefined,
    Object? startsWith = _undefined,
    Object? endsWith = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$NestedStringWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (contains != _undefined) 'contains': (contains as String?),
        if (startsWith != _undefined) 'startsWith': (startsWith as String?),
        if (endsWith != _undefined) 'endsWith': (endsWith as String?),
        if (not != _undefined)
          'not': (not as Input$NestedStringWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedStringFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedStringFilter?),
      }));
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedStringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedStringFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedStringFilter.stub(_then(_instance))
        : CopyWith$Input$NestedStringFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedStringWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedStringWithAggregatesFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    String? contains,
    String? startsWith,
    String? endsWith,
    Input$NestedStringWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedStringFilter? $_min,
    Input$NestedStringFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedStringWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedStringWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedStringFilter<TRes> get $_min =>
      CopyWith$Input$NestedStringFilter.stub(_res);
  CopyWith$Input$NestedStringFilter<TRes> get $_max =>
      CopyWith$Input$NestedStringFilter.stub(_res);
}

class Input$ColorsWhereInput {
  factory Input$ColorsWhereInput({
    List<Input$ColorsWhereInput>? AND,
    List<Input$ColorsWhereInput>? OR,
    List<Input$ColorsWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? color,
    Input$ProductModelListRelationFilter? ProductModel,
  }) =>
      Input$ColorsWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (color != null) r'color': color,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ColorsWhereInput._(this._$data);

  factory Input$ColorsWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$ColorsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$ColorsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$ColorsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$StringFilter.fromJson((l$color as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelListRelationFilter.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ColorsWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ColorsWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ColorsWhereInput>?);
  List<Input$ColorsWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ColorsWhereInput>?);
  List<Input$ColorsWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ColorsWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get color => (_$data['color'] as Input$StringFilter?);
  Input$ProductModelListRelationFilter? get ProductModel =>
      (_$data['ProductModel'] as Input$ProductModelListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput> get copyWith =>
      CopyWith$Input$ColorsWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$color = color;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsWhereInput<TRes> {
  factory CopyWith$Input$ColorsWhereInput(
    Input$ColorsWhereInput instance,
    TRes Function(Input$ColorsWhereInput) then,
  ) = _CopyWithImpl$Input$ColorsWhereInput;

  factory CopyWith$Input$ColorsWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsWhereInput;

  TRes call({
    List<Input$ColorsWhereInput>? AND,
    List<Input$ColorsWhereInput>? OR,
    List<Input$ColorsWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? color,
    Input$ProductModelListRelationFilter? ProductModel,
  });
  TRes AND(
      Iterable<Input$ColorsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ColorsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ColorsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get color;
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel;
}

class _CopyWithImpl$Input$ColorsWhereInput<TRes>
    implements CopyWith$Input$ColorsWhereInput<TRes> {
  _CopyWithImpl$Input$ColorsWhereInput(
    this._instance,
    this._then,
  );

  final Input$ColorsWhereInput _instance;

  final TRes Function(Input$ColorsWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? color = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ColorsWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$ColorsWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$ColorsWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$ColorsWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (color != _undefined) 'color': (color as Input$StringFilter?),
        if (ProductModel != _undefined)
          'ProductModel':
              (ProductModel as Input$ProductModelListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$ColorsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$ColorsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$ColorsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$ColorsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$ColorsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsWhereInput<Input$ColorsWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$ColorsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$color, (e) => call(color: e));
  }

  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductModelListRelationFilter(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ColorsWhereInput<TRes>
    implements CopyWith$Input$ColorsWhereInput<TRes> {
  _CopyWithStubImpl$Input$ColorsWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ColorsWhereInput>? AND,
    List<Input$ColorsWhereInput>? OR,
    List<Input$ColorsWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? color,
    Input$ProductModelListRelationFilter? ProductModel,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get color =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel =>
      CopyWith$Input$ProductModelListRelationFilter.stub(_res);
}

class Input$ProductModelListRelationFilter {
  factory Input$ProductModelListRelationFilter({
    Input$ProductModelWhereInput? every,
    Input$ProductModelWhereInput? some,
    Input$ProductModelWhereInput? none,
  }) =>
      Input$ProductModelListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$ProductModelListRelationFilter._(this._$data);

  factory Input$ProductModelListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$ProductModelWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ProductModelWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ProductModelWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$ProductModelListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereInput? get every =>
      (_$data['every'] as Input$ProductModelWhereInput?);
  Input$ProductModelWhereInput? get some =>
      (_$data['some'] as Input$ProductModelWhereInput?);
  Input$ProductModelWhereInput? get none =>
      (_$data['none'] as Input$ProductModelWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelListRelationFilter<
          Input$ProductModelListRelationFilter>
      get copyWith => CopyWith$Input$ProductModelListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelListRelationFilter<TRes> {
  factory CopyWith$Input$ProductModelListRelationFilter(
    Input$ProductModelListRelationFilter instance,
    TRes Function(Input$ProductModelListRelationFilter) then,
  ) = _CopyWithImpl$Input$ProductModelListRelationFilter;

  factory CopyWith$Input$ProductModelListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelListRelationFilter;

  TRes call({
    Input$ProductModelWhereInput? every,
    Input$ProductModelWhereInput? some,
    Input$ProductModelWhereInput? none,
  });
  CopyWith$Input$ProductModelWhereInput<TRes> get every;
  CopyWith$Input$ProductModelWhereInput<TRes> get some;
  CopyWith$Input$ProductModelWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$ProductModelListRelationFilter<TRes>
    implements CopyWith$Input$ProductModelListRelationFilter<TRes> {
  _CopyWithImpl$Input$ProductModelListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$ProductModelListRelationFilter _instance;

  final TRes Function(Input$ProductModelListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$ProductModelListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$ProductModelWhereInput?),
        if (some != _undefined) 'some': (some as Input$ProductModelWhereInput?),
        if (none != _undefined) 'none': (none as Input$ProductModelWhereInput?),
      }));
  CopyWith$Input$ProductModelWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$ProductModelWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductModelWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$ProductModelWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ProductModelWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductModelWhereInput(
            local$some, (e) => call(some: e));
  }

  CopyWith$Input$ProductModelWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ProductModelWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductModelWhereInput(
            local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelListRelationFilter<TRes>
    implements CopyWith$Input$ProductModelListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$ProductModelListRelationFilter(this._res);

  TRes _res;

  call({
    Input$ProductModelWhereInput? every,
    Input$ProductModelWhereInput? some,
    Input$ProductModelWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereInput<TRes> get every =>
      CopyWith$Input$ProductModelWhereInput.stub(_res);
  CopyWith$Input$ProductModelWhereInput<TRes> get some =>
      CopyWith$Input$ProductModelWhereInput.stub(_res);
  CopyWith$Input$ProductModelWhereInput<TRes> get none =>
      CopyWith$Input$ProductModelWhereInput.stub(_res);
}

class Input$ProductModelWhereInput {
  factory Input$ProductModelWhereInput({
    List<Input$ProductModelWhereInput>? AND,
    List<Input$ProductModelWhereInput>? OR,
    List<Input$ProductModelWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
    Input$ProductsRelationFilter? product,
    Input$SizesRelationFilter? size,
    Input$ColorsRelationFilter? color,
  }) =>
      Input$ProductModelWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
        if (product != null) r'product': product,
        if (size != null) r'size': size,
        if (color != null) r'color': color,
      });

  Input$ProductModelWhereInput._(this._$data);

  factory Input$ProductModelWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : Input$IntFilter.fromJson((l$color_id as Map<String, dynamic>));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : Input$IntFilter.fromJson((l$size_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsRelationFilter.fromJson(
              (l$product as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$SizesRelationFilter.fromJson(
              (l$size as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$ColorsRelationFilter.fromJson(
              (l$color as Map<String, dynamic>));
    }
    return Input$ProductModelWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductModelWhereInput>?);
  List<Input$ProductModelWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductModelWhereInput>?);
  List<Input$ProductModelWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductModelWhereInput>?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get color_id => (_$data['color_id'] as Input$IntFilter?);
  Input$IntFilter? get size_id => (_$data['size_id'] as Input$IntFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Input$ProductsRelationFilter? get product =>
      (_$data['product'] as Input$ProductsRelationFilter?);
  Input$SizesRelationFilter? get size =>
      (_$data['size'] as Input$SizesRelationFilter?);
  Input$ColorsRelationFilter? get color =>
      (_$data['color'] as Input$ColorsRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] = l$color_id?.toJson();
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] = l$size_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelWhereInput<Input$ProductModelWhereInput>
      get copyWith => CopyWith$Input$ProductModelWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('product') ? l$product : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelWhereInput<TRes> {
  factory CopyWith$Input$ProductModelWhereInput(
    Input$ProductModelWhereInput instance,
    TRes Function(Input$ProductModelWhereInput) then,
  ) = _CopyWithImpl$Input$ProductModelWhereInput;

  factory CopyWith$Input$ProductModelWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelWhereInput;

  TRes call({
    List<Input$ProductModelWhereInput>? AND,
    List<Input$ProductModelWhereInput>? OR,
    List<Input$ProductModelWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
    Input$ProductsRelationFilter? product,
    Input$SizesRelationFilter? size,
    Input$ColorsRelationFilter? color,
  });
  TRes AND(
      Iterable<Input$ProductModelWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereInput<
                      Input$ProductModelWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductModelWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereInput<
                      Input$ProductModelWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductModelWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereInput<
                      Input$ProductModelWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get color_id;
  CopyWith$Input$IntFilter<TRes> get size_id;
  CopyWith$Input$IntFilter<TRes> get quantity;
  CopyWith$Input$ProductsRelationFilter<TRes> get product;
  CopyWith$Input$SizesRelationFilter<TRes> get size;
  CopyWith$Input$ColorsRelationFilter<TRes> get color;
}

class _CopyWithImpl$Input$ProductModelWhereInput<TRes>
    implements CopyWith$Input$ProductModelWhereInput<TRes> {
  _CopyWithImpl$Input$ProductModelWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelWhereInput _instance;

  final TRes Function(Input$ProductModelWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductModelWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$ProductModelWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ProductModelWhereInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (color_id != _undefined) 'color_id': (color_id as Input$IntFilter?),
        if (size_id != _undefined) 'size_id': (size_id as Input$IntFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
        if (product != _undefined)
          'product': (product as Input$ProductsRelationFilter?),
        if (size != _undefined) 'size': (size as Input$SizesRelationFilter?),
        if (color != _undefined)
          'color': (color as Input$ColorsRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductModelWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereInput<
                          Input$ProductModelWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$ProductModelWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductModelWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereInput<
                          Input$ProductModelWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$ProductModelWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductModelWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereInput<
                          Input$ProductModelWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$ProductModelWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get color_id {
    final local$color_id = _instance.color_id;
    return local$color_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$color_id, (e) => call(color_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get size_id {
    final local$size_id = _instance.size_id;
    return local$size_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$size_id, (e) => call(size_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$ProductsRelationFilter<TRes> get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductsRelationFilter(
            local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesRelationFilter<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$SizesRelationFilter.stub(_then(_instance))
        : CopyWith$Input$SizesRelationFilter(local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsRelationFilter<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$ColorsRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ColorsRelationFilter(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelWhereInput<TRes>
    implements CopyWith$Input$ProductModelWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ProductModelWhereInput>? AND,
    List<Input$ProductModelWhereInput>? OR,
    List<Input$ProductModelWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
    Input$ProductsRelationFilter? product,
    Input$SizesRelationFilter? size,
    Input$ColorsRelationFilter? color,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get color_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get size_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$ProductsRelationFilter<TRes> get product =>
      CopyWith$Input$ProductsRelationFilter.stub(_res);
  CopyWith$Input$SizesRelationFilter<TRes> get size =>
      CopyWith$Input$SizesRelationFilter.stub(_res);
  CopyWith$Input$ColorsRelationFilter<TRes> get color =>
      CopyWith$Input$ColorsRelationFilter.stub(_res);
}

class Input$ProductsRelationFilter {
  factory Input$ProductsRelationFilter({
    Input$ProductsWhereInput? $is,
    Input$ProductsWhereInput? isNot,
  }) =>
      Input$ProductsRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$ProductsRelationFilter._(this._$data);

  factory Input$ProductsRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$ProductsWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$ProductsWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$ProductsRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereInput? get $is =>
      (_$data['is'] as Input$ProductsWhereInput?);
  Input$ProductsWhereInput? get isNot =>
      (_$data['isNot'] as Input$ProductsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsRelationFilter<Input$ProductsRelationFilter>
      get copyWith => CopyWith$Input$ProductsRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsRelationFilter<TRes> {
  factory CopyWith$Input$ProductsRelationFilter(
    Input$ProductsRelationFilter instance,
    TRes Function(Input$ProductsRelationFilter) then,
  ) = _CopyWithImpl$Input$ProductsRelationFilter;

  factory CopyWith$Input$ProductsRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsRelationFilter;

  TRes call({
    Input$ProductsWhereInput? $is,
    Input$ProductsWhereInput? isNot,
  });
  CopyWith$Input$ProductsWhereInput<TRes> get $is;
  CopyWith$Input$ProductsWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$ProductsRelationFilter<TRes>
    implements CopyWith$Input$ProductsRelationFilter<TRes> {
  _CopyWithImpl$Input$ProductsRelationFilter(
    this._instance,
    this._then,
  );

  final Input$ProductsRelationFilter _instance;

  final TRes Function(Input$ProductsRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$ProductsRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$ProductsWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$ProductsWhereInput?),
      }));
  CopyWith$Input$ProductsWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$ProductsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$ProductsWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$ProductsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$ProductsRelationFilter<TRes>
    implements CopyWith$Input$ProductsRelationFilter<TRes> {
  _CopyWithStubImpl$Input$ProductsRelationFilter(this._res);

  TRes _res;

  call({
    Input$ProductsWhereInput? $is,
    Input$ProductsWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereInput<TRes> get $is =>
      CopyWith$Input$ProductsWhereInput.stub(_res);
  CopyWith$Input$ProductsWhereInput<TRes> get isNot =>
      CopyWith$Input$ProductsWhereInput.stub(_res);
}

class Input$ProductsWhereInput {
  factory Input$ProductsWhereInput({
    List<Input$ProductsWhereInput>? AND,
    List<Input$ProductsWhereInput>? OR,
    List<Input$ProductsWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
    Input$ProductFamilyRelationFilter? family,
    Input$ProductModelListRelationFilter? ProductModel,
    Input$TransactionProductListRelationFilter? TransactionProduct,
  }) =>
      Input$ProductsWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
        if (family != null) r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsWhereInput._(this._$data);

  factory Input$ProductsWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFilter.fromJson((l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFilter.fromJson((l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFilter.fromJson((l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : Input$IntFilter.fromJson((l$family_id as Map<String, dynamic>));
    }
    if (data.containsKey('family')) {
      final l$family = data['family'];
      result$data['family'] = l$family == null
          ? null
          : Input$ProductFamilyRelationFilter.fromJson(
              (l$family as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelListRelationFilter.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductListRelationFilter.fromJson(
              (l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductsWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductsWhereInput>?);
  List<Input$ProductsWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductsWhereInput>?);
  List<Input$ProductsWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductsWhereInput>?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get reference => (_$data['reference'] as Input$IntFilter?);
  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);
  Input$FloatFilter? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFilter?);
  Input$FloatFilter? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFilter?);
  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);
  Input$StringFilter? get picture => (_$data['picture'] as Input$StringFilter?);
  Input$IntFilter? get family_id => (_$data['family_id'] as Input$IntFilter?);
  Input$ProductFamilyRelationFilter? get family =>
      (_$data['family'] as Input$ProductFamilyRelationFilter?);
  Input$ProductModelListRelationFilter? get ProductModel =>
      (_$data['ProductModel'] as Input$ProductModelListRelationFilter?);
  Input$TransactionProductListRelationFilter? get TransactionProduct =>
      (_$data['TransactionProduct']
          as Input$TransactionProductListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] = l$family_id?.toJson();
    }
    if (_$data.containsKey('family')) {
      final l$family = family;
      result$data['family'] = l$family?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsWhereInput<Input$ProductsWhereInput> get copyWith =>
      CopyWith$Input$ProductsWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (_$data.containsKey('family') != other._$data.containsKey('family')) {
      return false;
    }
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    final l$family = family;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
      _$data.containsKey('family') ? l$family : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsWhereInput<TRes> {
  factory CopyWith$Input$ProductsWhereInput(
    Input$ProductsWhereInput instance,
    TRes Function(Input$ProductsWhereInput) then,
  ) = _CopyWithImpl$Input$ProductsWhereInput;

  factory CopyWith$Input$ProductsWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsWhereInput;

  TRes call({
    List<Input$ProductsWhereInput>? AND,
    List<Input$ProductsWhereInput>? OR,
    List<Input$ProductsWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
    Input$ProductFamilyRelationFilter? family,
    Input$ProductModelListRelationFilter? ProductModel,
    Input$TransactionProductListRelationFilter? TransactionProduct,
  });
  TRes AND(
      Iterable<Input$ProductsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereInput<Input$ProductsWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereInput<Input$ProductsWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductsWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereInput<Input$ProductsWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get reference;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$FloatFilter<TRes> get buyingPrice;
  CopyWith$Input$FloatFilter<TRes> get sellingPrice;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get picture;
  CopyWith$Input$IntFilter<TRes> get family_id;
  CopyWith$Input$ProductFamilyRelationFilter<TRes> get family;
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel;
  CopyWith$Input$TransactionProductListRelationFilter<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsWhereInput<TRes>
    implements CopyWith$Input$ProductsWhereInput<TRes> {
  _CopyWithImpl$Input$ProductsWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductsWhereInput _instance;

  final TRes Function(Input$ProductsWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$ProductsWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$ProductsWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$ProductsWhereInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (reference != _undefined)
          'reference': (reference as Input$IntFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Input$FloatFilter?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Input$FloatFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (picture != _undefined) 'picture': (picture as Input$StringFilter?),
        if (family_id != _undefined)
          'family_id': (family_id as Input$IntFilter?),
        if (family != _undefined)
          'family': (family as Input$ProductFamilyRelationFilter?),
        if (ProductModel != _undefined)
          'ProductModel':
              (ProductModel as Input$ProductModelListRelationFilter?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereInput<
                          Input$ProductsWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$ProductsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$ProductsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereInput<
                          Input$ProductsWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$ProductsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$ProductsWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereInput<
                          Input$ProductsWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$ProductsWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFilter<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFilter<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$IntFilter<TRes> get family_id {
    final local$family_id = _instance.family_id;
    return local$family_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$family_id, (e) => call(family_id: e));
  }

  CopyWith$Input$ProductFamilyRelationFilter<TRes> get family {
    final local$family = _instance.family;
    return local$family == null
        ? CopyWith$Input$ProductFamilyRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductFamilyRelationFilter(
            local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductModelListRelationFilter(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductListRelationFilter<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductListRelationFilter.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductListRelationFilter(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsWhereInput<TRes>
    implements CopyWith$Input$ProductsWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductsWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ProductsWhereInput>? AND,
    List<Input$ProductsWhereInput>? OR,
    List<Input$ProductsWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
    Input$ProductFamilyRelationFilter? family,
    Input$ProductModelListRelationFilter? ProductModel,
    Input$TransactionProductListRelationFilter? TransactionProduct,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get reference =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get buyingPrice =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get sellingPrice =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get picture =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get family_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$ProductFamilyRelationFilter<TRes> get family =>
      CopyWith$Input$ProductFamilyRelationFilter.stub(_res);
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel =>
      CopyWith$Input$ProductModelListRelationFilter.stub(_res);
  CopyWith$Input$TransactionProductListRelationFilter<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductListRelationFilter.stub(_res);
}

class Input$ProductFamilyRelationFilter {
  factory Input$ProductFamilyRelationFilter({
    Input$ProductFamilyWhereInput? $is,
    Input$ProductFamilyWhereInput? isNot,
  }) =>
      Input$ProductFamilyRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$ProductFamilyRelationFilter._(this._$data);

  factory Input$ProductFamilyRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$ProductFamilyWhereInput.fromJson(
              (l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$ProductFamilyWhereInput.fromJson(
              (l$isNot as Map<String, dynamic>));
    }
    return Input$ProductFamilyRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductFamilyWhereInput? get $is =>
      (_$data['is'] as Input$ProductFamilyWhereInput?);
  Input$ProductFamilyWhereInput? get isNot =>
      (_$data['isNot'] as Input$ProductFamilyWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyRelationFilter<Input$ProductFamilyRelationFilter>
      get copyWith => CopyWith$Input$ProductFamilyRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyRelationFilter<TRes> {
  factory CopyWith$Input$ProductFamilyRelationFilter(
    Input$ProductFamilyRelationFilter instance,
    TRes Function(Input$ProductFamilyRelationFilter) then,
  ) = _CopyWithImpl$Input$ProductFamilyRelationFilter;

  factory CopyWith$Input$ProductFamilyRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyRelationFilter;

  TRes call({
    Input$ProductFamilyWhereInput? $is,
    Input$ProductFamilyWhereInput? isNot,
  });
  CopyWith$Input$ProductFamilyWhereInput<TRes> get $is;
  CopyWith$Input$ProductFamilyWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$ProductFamilyRelationFilter<TRes>
    implements CopyWith$Input$ProductFamilyRelationFilter<TRes> {
  _CopyWithImpl$Input$ProductFamilyRelationFilter(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyRelationFilter _instance;

  final TRes Function(Input$ProductFamilyRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$ProductFamilyRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$ProductFamilyWhereInput?),
        if (isNot != _undefined)
          'isNot': (isNot as Input$ProductFamilyWhereInput?),
      }));
  CopyWith$Input$ProductFamilyWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$ProductFamilyWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductFamilyWhereInput(
            local$$is, (e) => call($is: e));
  }

  CopyWith$Input$ProductFamilyWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$ProductFamilyWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductFamilyWhereInput(
            local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyRelationFilter<TRes>
    implements CopyWith$Input$ProductFamilyRelationFilter<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyRelationFilter(this._res);

  TRes _res;

  call({
    Input$ProductFamilyWhereInput? $is,
    Input$ProductFamilyWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyWhereInput<TRes> get $is =>
      CopyWith$Input$ProductFamilyWhereInput.stub(_res);
  CopyWith$Input$ProductFamilyWhereInput<TRes> get isNot =>
      CopyWith$Input$ProductFamilyWhereInput.stub(_res);
}

class Input$ProductFamilyWhereInput {
  factory Input$ProductFamilyWhereInput({
    List<Input$ProductFamilyWhereInput>? AND,
    List<Input$ProductFamilyWhereInput>? OR,
    List<Input$ProductFamilyWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? name,
    Input$ProductsListRelationFilter? Products,
  }) =>
      Input$ProductFamilyWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (Products != null) r'Products': Products,
      });

  Input$ProductFamilyWhereInput._(this._$data);

  factory Input$ProductFamilyWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductFamilyWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductFamilyWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ProductFamilyWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('Products')) {
      final l$Products = data['Products'];
      result$data['Products'] = l$Products == null
          ? null
          : Input$ProductsListRelationFilter.fromJson(
              (l$Products as Map<String, dynamic>));
    }
    return Input$ProductFamilyWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductFamilyWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductFamilyWhereInput>?);
  List<Input$ProductFamilyWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductFamilyWhereInput>?);
  List<Input$ProductFamilyWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductFamilyWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);
  Input$ProductsListRelationFilter? get Products =>
      (_$data['Products'] as Input$ProductsListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('Products')) {
      final l$Products = Products;
      result$data['Products'] = l$Products?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyWhereInput<Input$ProductFamilyWhereInput>
      get copyWith => CopyWith$Input$ProductFamilyWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$Products = Products;
    final lOther$Products = other.Products;
    if (_$data.containsKey('Products') !=
        other._$data.containsKey('Products')) {
      return false;
    }
    if (l$Products != lOther$Products) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    final l$Products = Products;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('Products') ? l$Products : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyWhereInput<TRes> {
  factory CopyWith$Input$ProductFamilyWhereInput(
    Input$ProductFamilyWhereInput instance,
    TRes Function(Input$ProductFamilyWhereInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyWhereInput;

  factory CopyWith$Input$ProductFamilyWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyWhereInput;

  TRes call({
    List<Input$ProductFamilyWhereInput>? AND,
    List<Input$ProductFamilyWhereInput>? OR,
    List<Input$ProductFamilyWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? name,
    Input$ProductsListRelationFilter? Products,
  });
  TRes AND(
      Iterable<Input$ProductFamilyWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyWhereInput<
                      Input$ProductFamilyWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductFamilyWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyWhereInput<
                      Input$ProductFamilyWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductFamilyWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyWhereInput<
                      Input$ProductFamilyWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$ProductsListRelationFilter<TRes> get Products;
}

class _CopyWithImpl$Input$ProductFamilyWhereInput<TRes>
    implements CopyWith$Input$ProductFamilyWhereInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyWhereInput _instance;

  final TRes Function(Input$ProductFamilyWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
    Object? Products = _undefined,
  }) =>
      _then(Input$ProductFamilyWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductFamilyWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductFamilyWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ProductFamilyWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (Products != _undefined)
          'Products': (Products as Input$ProductsListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductFamilyWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyWhereInput<
                          Input$ProductFamilyWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$ProductFamilyWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductFamilyWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyWhereInput<
                          Input$ProductFamilyWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$ProductFamilyWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductFamilyWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyWhereInput<
                          Input$ProductFamilyWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$ProductFamilyWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$ProductsListRelationFilter<TRes> get Products {
    final local$Products = _instance.Products;
    return local$Products == null
        ? CopyWith$Input$ProductsListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductsListRelationFilter(
            local$Products, (e) => call(Products: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyWhereInput<TRes>
    implements CopyWith$Input$ProductFamilyWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ProductFamilyWhereInput>? AND,
    List<Input$ProductFamilyWhereInput>? OR,
    List<Input$ProductFamilyWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? name,
    Input$ProductsListRelationFilter? Products,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$ProductsListRelationFilter<TRes> get Products =>
      CopyWith$Input$ProductsListRelationFilter.stub(_res);
}

class Input$ProductsListRelationFilter {
  factory Input$ProductsListRelationFilter({
    Input$ProductsWhereInput? every,
    Input$ProductsWhereInput? some,
    Input$ProductsWhereInput? none,
  }) =>
      Input$ProductsListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$ProductsListRelationFilter._(this._$data);

  factory Input$ProductsListRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$ProductsWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$ProductsWhereInput.fromJson((l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$ProductsWhereInput.fromJson((l$none as Map<String, dynamic>));
    }
    return Input$ProductsListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereInput? get every =>
      (_$data['every'] as Input$ProductsWhereInput?);
  Input$ProductsWhereInput? get some =>
      (_$data['some'] as Input$ProductsWhereInput?);
  Input$ProductsWhereInput? get none =>
      (_$data['none'] as Input$ProductsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsListRelationFilter<Input$ProductsListRelationFilter>
      get copyWith => CopyWith$Input$ProductsListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsListRelationFilter<TRes> {
  factory CopyWith$Input$ProductsListRelationFilter(
    Input$ProductsListRelationFilter instance,
    TRes Function(Input$ProductsListRelationFilter) then,
  ) = _CopyWithImpl$Input$ProductsListRelationFilter;

  factory CopyWith$Input$ProductsListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsListRelationFilter;

  TRes call({
    Input$ProductsWhereInput? every,
    Input$ProductsWhereInput? some,
    Input$ProductsWhereInput? none,
  });
  CopyWith$Input$ProductsWhereInput<TRes> get every;
  CopyWith$Input$ProductsWhereInput<TRes> get some;
  CopyWith$Input$ProductsWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$ProductsListRelationFilter<TRes>
    implements CopyWith$Input$ProductsListRelationFilter<TRes> {
  _CopyWithImpl$Input$ProductsListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$ProductsListRelationFilter _instance;

  final TRes Function(Input$ProductsListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$ProductsListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined) 'every': (every as Input$ProductsWhereInput?),
        if (some != _undefined) 'some': (some as Input$ProductsWhereInput?),
        if (none != _undefined) 'none': (none as Input$ProductsWhereInput?),
      }));
  CopyWith$Input$ProductsWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$ProductsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereInput(local$every, (e) => call(every: e));
  }

  CopyWith$Input$ProductsWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$ProductsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereInput(local$some, (e) => call(some: e));
  }

  CopyWith$Input$ProductsWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$ProductsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereInput(local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$ProductsListRelationFilter<TRes>
    implements CopyWith$Input$ProductsListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$ProductsListRelationFilter(this._res);

  TRes _res;

  call({
    Input$ProductsWhereInput? every,
    Input$ProductsWhereInput? some,
    Input$ProductsWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereInput<TRes> get every =>
      CopyWith$Input$ProductsWhereInput.stub(_res);
  CopyWith$Input$ProductsWhereInput<TRes> get some =>
      CopyWith$Input$ProductsWhereInput.stub(_res);
  CopyWith$Input$ProductsWhereInput<TRes> get none =>
      CopyWith$Input$ProductsWhereInput.stub(_res);
}

class Input$TransactionProductListRelationFilter {
  factory Input$TransactionProductListRelationFilter({
    Input$TransactionProductWhereInput? every,
    Input$TransactionProductWhereInput? some,
    Input$TransactionProductWhereInput? none,
  }) =>
      Input$TransactionProductListRelationFilter._({
        if (every != null) r'every': every,
        if (some != null) r'some': some,
        if (none != null) r'none': none,
      });

  Input$TransactionProductListRelationFilter._(this._$data);

  factory Input$TransactionProductListRelationFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('every')) {
      final l$every = data['every'];
      result$data['every'] = l$every == null
          ? null
          : Input$TransactionProductWhereInput.fromJson(
              (l$every as Map<String, dynamic>));
    }
    if (data.containsKey('some')) {
      final l$some = data['some'];
      result$data['some'] = l$some == null
          ? null
          : Input$TransactionProductWhereInput.fromJson(
              (l$some as Map<String, dynamic>));
    }
    if (data.containsKey('none')) {
      final l$none = data['none'];
      result$data['none'] = l$none == null
          ? null
          : Input$TransactionProductWhereInput.fromJson(
              (l$none as Map<String, dynamic>));
    }
    return Input$TransactionProductListRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionProductWhereInput? get every =>
      (_$data['every'] as Input$TransactionProductWhereInput?);
  Input$TransactionProductWhereInput? get some =>
      (_$data['some'] as Input$TransactionProductWhereInput?);
  Input$TransactionProductWhereInput? get none =>
      (_$data['none'] as Input$TransactionProductWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('every')) {
      final l$every = every;
      result$data['every'] = l$every?.toJson();
    }
    if (_$data.containsKey('some')) {
      final l$some = some;
      result$data['some'] = l$some?.toJson();
    }
    if (_$data.containsKey('none')) {
      final l$none = none;
      result$data['none'] = l$none?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductListRelationFilter<
          Input$TransactionProductListRelationFilter>
      get copyWith => CopyWith$Input$TransactionProductListRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductListRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$every = every;
    final lOther$every = other.every;
    if (_$data.containsKey('every') != other._$data.containsKey('every')) {
      return false;
    }
    if (l$every != lOther$every) {
      return false;
    }
    final l$some = some;
    final lOther$some = other.some;
    if (_$data.containsKey('some') != other._$data.containsKey('some')) {
      return false;
    }
    if (l$some != lOther$some) {
      return false;
    }
    final l$none = none;
    final lOther$none = other.none;
    if (_$data.containsKey('none') != other._$data.containsKey('none')) {
      return false;
    }
    if (l$none != lOther$none) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$every = every;
    final l$some = some;
    final l$none = none;
    return Object.hashAll([
      _$data.containsKey('every') ? l$every : const {},
      _$data.containsKey('some') ? l$some : const {},
      _$data.containsKey('none') ? l$none : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductListRelationFilter<TRes> {
  factory CopyWith$Input$TransactionProductListRelationFilter(
    Input$TransactionProductListRelationFilter instance,
    TRes Function(Input$TransactionProductListRelationFilter) then,
  ) = _CopyWithImpl$Input$TransactionProductListRelationFilter;

  factory CopyWith$Input$TransactionProductListRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductListRelationFilter;

  TRes call({
    Input$TransactionProductWhereInput? every,
    Input$TransactionProductWhereInput? some,
    Input$TransactionProductWhereInput? none,
  });
  CopyWith$Input$TransactionProductWhereInput<TRes> get every;
  CopyWith$Input$TransactionProductWhereInput<TRes> get some;
  CopyWith$Input$TransactionProductWhereInput<TRes> get none;
}

class _CopyWithImpl$Input$TransactionProductListRelationFilter<TRes>
    implements CopyWith$Input$TransactionProductListRelationFilter<TRes> {
  _CopyWithImpl$Input$TransactionProductListRelationFilter(
    this._instance,
    this._then,
  );

  final Input$TransactionProductListRelationFilter _instance;

  final TRes Function(Input$TransactionProductListRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? every = _undefined,
    Object? some = _undefined,
    Object? none = _undefined,
  }) =>
      _then(Input$TransactionProductListRelationFilter._({
        ..._instance._$data,
        if (every != _undefined)
          'every': (every as Input$TransactionProductWhereInput?),
        if (some != _undefined)
          'some': (some as Input$TransactionProductWhereInput?),
        if (none != _undefined)
          'none': (none as Input$TransactionProductWhereInput?),
      }));
  CopyWith$Input$TransactionProductWhereInput<TRes> get every {
    final local$every = _instance.every;
    return local$every == null
        ? CopyWith$Input$TransactionProductWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionProductWhereInput(
            local$every, (e) => call(every: e));
  }

  CopyWith$Input$TransactionProductWhereInput<TRes> get some {
    final local$some = _instance.some;
    return local$some == null
        ? CopyWith$Input$TransactionProductWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionProductWhereInput(
            local$some, (e) => call(some: e));
  }

  CopyWith$Input$TransactionProductWhereInput<TRes> get none {
    final local$none = _instance.none;
    return local$none == null
        ? CopyWith$Input$TransactionProductWhereInput.stub(_then(_instance))
        : CopyWith$Input$TransactionProductWhereInput(
            local$none, (e) => call(none: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductListRelationFilter<TRes>
    implements CopyWith$Input$TransactionProductListRelationFilter<TRes> {
  _CopyWithStubImpl$Input$TransactionProductListRelationFilter(this._res);

  TRes _res;

  call({
    Input$TransactionProductWhereInput? every,
    Input$TransactionProductWhereInput? some,
    Input$TransactionProductWhereInput? none,
  }) =>
      _res;
  CopyWith$Input$TransactionProductWhereInput<TRes> get every =>
      CopyWith$Input$TransactionProductWhereInput.stub(_res);
  CopyWith$Input$TransactionProductWhereInput<TRes> get some =>
      CopyWith$Input$TransactionProductWhereInput.stub(_res);
  CopyWith$Input$TransactionProductWhereInput<TRes> get none =>
      CopyWith$Input$TransactionProductWhereInput.stub(_res);
}

class Input$TransactionProductWhereInput {
  factory Input$TransactionProductWhereInput({
    List<Input$TransactionProductWhereInput>? AND,
    List<Input$TransactionProductWhereInput>? OR,
    List<Input$TransactionProductWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
    Input$ProductsRelationFilter? product,
  }) =>
      Input$TransactionProductWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
        if (product != null) r'product': product,
      });

  Input$TransactionProductWhereInput._(this._$data);

  factory Input$TransactionProductWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatFilter.fromJson((l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringFilter.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsRelationFilter.fromJson(
              (l$product as Map<String, dynamic>));
    }
    return Input$TransactionProductWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionProductWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionProductWhereInput>?);
  List<Input$TransactionProductWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionProductWhereInput>?);
  List<Input$TransactionProductWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionProductWhereInput>?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Input$FloatFilter? get price => (_$data['price'] as Input$FloatFilter?);
  Input$StringFilter? get product_name =>
      (_$data['product_name'] as Input$StringFilter?);
  Input$ProductsRelationFilter? get product =>
      (_$data['product'] as Input$ProductsRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductWhereInput<
          Input$TransactionProductWhereInput>
      get copyWith => CopyWith$Input$TransactionProductWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    final l$product = product;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
      _$data.containsKey('product') ? l$product : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductWhereInput<TRes> {
  factory CopyWith$Input$TransactionProductWhereInput(
    Input$TransactionProductWhereInput instance,
    TRes Function(Input$TransactionProductWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionProductWhereInput;

  factory CopyWith$Input$TransactionProductWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductWhereInput;

  TRes call({
    List<Input$TransactionProductWhereInput>? AND,
    List<Input$TransactionProductWhereInput>? OR,
    List<Input$TransactionProductWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
    Input$ProductsRelationFilter? product,
  });
  TRes AND(
      Iterable<Input$TransactionProductWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereInput<
                      Input$TransactionProductWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionProductWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereInput<
                      Input$TransactionProductWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionProductWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereInput<
                      Input$TransactionProductWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get quantity;
  CopyWith$Input$FloatFilter<TRes> get price;
  CopyWith$Input$StringFilter<TRes> get product_name;
  CopyWith$Input$ProductsRelationFilter<TRes> get product;
}

class _CopyWithImpl$Input$TransactionProductWhereInput<TRes>
    implements CopyWith$Input$TransactionProductWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionProductWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductWhereInput _instance;

  final TRes Function(Input$TransactionProductWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
    Object? product = _undefined,
  }) =>
      _then(Input$TransactionProductWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionProductWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionProductWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionProductWhereInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
        if (price != _undefined) 'price': (price as Input$FloatFilter?),
        if (product_name != _undefined)
          'product_name': (product_name as Input$StringFilter?),
        if (product != _undefined)
          'product': (product as Input$ProductsRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionProductWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereInput<
                          Input$TransactionProductWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$TransactionProductWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionProductWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereInput<
                          Input$TransactionProductWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$TransactionProductWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionProductWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereInput<
                          Input$TransactionProductWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$TransactionProductWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatFilter<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringFilter<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$product_name, (e) => call(product_name: e));
  }

  CopyWith$Input$ProductsRelationFilter<TRes> get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductsRelationFilter(
            local$product, (e) => call(product: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductWhereInput<TRes>
    implements CopyWith$Input$TransactionProductWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionProductWhereInput>? AND,
    List<Input$TransactionProductWhereInput>? OR,
    List<Input$TransactionProductWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
    Input$ProductsRelationFilter? product,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get price =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get product_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$ProductsRelationFilter<TRes> get product =>
      CopyWith$Input$ProductsRelationFilter.stub(_res);
}

class Input$SizesRelationFilter {
  factory Input$SizesRelationFilter({
    Input$SizesWhereInput? $is,
    Input$SizesWhereInput? isNot,
  }) =>
      Input$SizesRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$SizesRelationFilter._(this._$data);

  factory Input$SizesRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$SizesWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$SizesWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$SizesRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SizesWhereInput? get $is => (_$data['is'] as Input$SizesWhereInput?);
  Input$SizesWhereInput? get isNot =>
      (_$data['isNot'] as Input$SizesWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesRelationFilter<Input$SizesRelationFilter> get copyWith =>
      CopyWith$Input$SizesRelationFilter(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesRelationFilter<TRes> {
  factory CopyWith$Input$SizesRelationFilter(
    Input$SizesRelationFilter instance,
    TRes Function(Input$SizesRelationFilter) then,
  ) = _CopyWithImpl$Input$SizesRelationFilter;

  factory CopyWith$Input$SizesRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesRelationFilter;

  TRes call({
    Input$SizesWhereInput? $is,
    Input$SizesWhereInput? isNot,
  });
  CopyWith$Input$SizesWhereInput<TRes> get $is;
  CopyWith$Input$SizesWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$SizesRelationFilter<TRes>
    implements CopyWith$Input$SizesRelationFilter<TRes> {
  _CopyWithImpl$Input$SizesRelationFilter(
    this._instance,
    this._then,
  );

  final Input$SizesRelationFilter _instance;

  final TRes Function(Input$SizesRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$SizesRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$SizesWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$SizesWhereInput?),
      }));
  CopyWith$Input$SizesWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$SizesWhereInput.stub(_then(_instance))
        : CopyWith$Input$SizesWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$SizesWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$SizesWhereInput.stub(_then(_instance))
        : CopyWith$Input$SizesWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$SizesRelationFilter<TRes>
    implements CopyWith$Input$SizesRelationFilter<TRes> {
  _CopyWithStubImpl$Input$SizesRelationFilter(this._res);

  TRes _res;

  call({
    Input$SizesWhereInput? $is,
    Input$SizesWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$SizesWhereInput<TRes> get $is =>
      CopyWith$Input$SizesWhereInput.stub(_res);
  CopyWith$Input$SizesWhereInput<TRes> get isNot =>
      CopyWith$Input$SizesWhereInput.stub(_res);
}

class Input$SizesWhereInput {
  factory Input$SizesWhereInput({
    List<Input$SizesWhereInput>? AND,
    List<Input$SizesWhereInput>? OR,
    List<Input$SizesWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? size,
    Input$ProductModelListRelationFilter? ProductModel,
  }) =>
      Input$SizesWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (size != null) r'size': size,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$SizesWhereInput._(this._$data);

  factory Input$SizesWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$SizesWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$SizesWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$SizesWhereInput.fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFilter.fromJson((l$id as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$StringFilter.fromJson((l$size as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelListRelationFilter.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$SizesWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SizesWhereInput>? get AND =>
      (_$data['AND'] as List<Input$SizesWhereInput>?);
  List<Input$SizesWhereInput>? get OR =>
      (_$data['OR'] as List<Input$SizesWhereInput>?);
  List<Input$SizesWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$SizesWhereInput>?);
  Input$IntFilter? get id => (_$data['id'] as Input$IntFilter?);
  Input$StringFilter? get size => (_$data['size'] as Input$StringFilter?);
  Input$ProductModelListRelationFilter? get ProductModel =>
      (_$data['ProductModel'] as Input$ProductModelListRelationFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesWhereInput<Input$SizesWhereInput> get copyWith =>
      CopyWith$Input$SizesWhereInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesWhereInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$size = size;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesWhereInput<TRes> {
  factory CopyWith$Input$SizesWhereInput(
    Input$SizesWhereInput instance,
    TRes Function(Input$SizesWhereInput) then,
  ) = _CopyWithImpl$Input$SizesWhereInput;

  factory CopyWith$Input$SizesWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesWhereInput;

  TRes call({
    List<Input$SizesWhereInput>? AND,
    List<Input$SizesWhereInput>? OR,
    List<Input$SizesWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? size,
    Input$ProductModelListRelationFilter? ProductModel,
  });
  TRes AND(
      Iterable<Input$SizesWhereInput>? Function(
              Iterable<CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$SizesWhereInput>? Function(
              Iterable<CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$SizesWhereInput>? Function(
              Iterable<CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get id;
  CopyWith$Input$StringFilter<TRes> get size;
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel;
}

class _CopyWithImpl$Input$SizesWhereInput<TRes>
    implements CopyWith$Input$SizesWhereInput<TRes> {
  _CopyWithImpl$Input$SizesWhereInput(
    this._instance,
    this._then,
  );

  final Input$SizesWhereInput _instance;

  final TRes Function(Input$SizesWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? size = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$SizesWhereInput._({
        ..._instance._$data,
        if (AND != _undefined) 'AND': (AND as List<Input$SizesWhereInput>?),
        if (OR != _undefined) 'OR': (OR as List<Input$SizesWhereInput>?),
        if (NOT != _undefined) 'NOT': (NOT as List<Input$SizesWhereInput>?),
        if (id != _undefined) 'id': (id as Input$IntFilter?),
        if (size != _undefined) 'size': (size as Input$StringFilter?),
        if (ProductModel != _undefined)
          'ProductModel':
              (ProductModel as Input$ProductModelListRelationFilter?),
      }));
  TRes AND(
          Iterable<Input$SizesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) => CopyWith$Input$SizesWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$SizesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) => CopyWith$Input$SizesWhereInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$SizesWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesWhereInput<Input$SizesWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) => CopyWith$Input$SizesWhereInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFilter<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$size, (e) => call(size: e));
  }

  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelListRelationFilter.stub(_then(_instance))
        : CopyWith$Input$ProductModelListRelationFilter(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$SizesWhereInput<TRes>
    implements CopyWith$Input$SizesWhereInput<TRes> {
  _CopyWithStubImpl$Input$SizesWhereInput(this._res);

  TRes _res;

  call({
    List<Input$SizesWhereInput>? AND,
    List<Input$SizesWhereInput>? OR,
    List<Input$SizesWhereInput>? NOT,
    Input$IntFilter? id,
    Input$StringFilter? size,
    Input$ProductModelListRelationFilter? ProductModel,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get id => CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get size =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$ProductModelListRelationFilter<TRes> get ProductModel =>
      CopyWith$Input$ProductModelListRelationFilter.stub(_res);
}

class Input$ColorsRelationFilter {
  factory Input$ColorsRelationFilter({
    Input$ColorsWhereInput? $is,
    Input$ColorsWhereInput? isNot,
  }) =>
      Input$ColorsRelationFilter._({
        if ($is != null) r'is': $is,
        if (isNot != null) r'isNot': isNot,
      });

  Input$ColorsRelationFilter._(this._$data);

  factory Input$ColorsRelationFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('is')) {
      final l$$is = data['is'];
      result$data['is'] = l$$is == null
          ? null
          : Input$ColorsWhereInput.fromJson((l$$is as Map<String, dynamic>));
    }
    if (data.containsKey('isNot')) {
      final l$isNot = data['isNot'];
      result$data['isNot'] = l$isNot == null
          ? null
          : Input$ColorsWhereInput.fromJson((l$isNot as Map<String, dynamic>));
    }
    return Input$ColorsRelationFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ColorsWhereInput? get $is => (_$data['is'] as Input$ColorsWhereInput?);
  Input$ColorsWhereInput? get isNot =>
      (_$data['isNot'] as Input$ColorsWhereInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('is')) {
      final l$$is = $is;
      result$data['is'] = l$$is?.toJson();
    }
    if (_$data.containsKey('isNot')) {
      final l$isNot = isNot;
      result$data['isNot'] = l$isNot?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsRelationFilter<Input$ColorsRelationFilter>
      get copyWith => CopyWith$Input$ColorsRelationFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsRelationFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$is = $is;
    final lOther$$is = other.$is;
    if (_$data.containsKey('is') != other._$data.containsKey('is')) {
      return false;
    }
    if (l$$is != lOther$$is) {
      return false;
    }
    final l$isNot = isNot;
    final lOther$isNot = other.isNot;
    if (_$data.containsKey('isNot') != other._$data.containsKey('isNot')) {
      return false;
    }
    if (l$isNot != lOther$isNot) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$is = $is;
    final l$isNot = isNot;
    return Object.hashAll([
      _$data.containsKey('is') ? l$$is : const {},
      _$data.containsKey('isNot') ? l$isNot : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsRelationFilter<TRes> {
  factory CopyWith$Input$ColorsRelationFilter(
    Input$ColorsRelationFilter instance,
    TRes Function(Input$ColorsRelationFilter) then,
  ) = _CopyWithImpl$Input$ColorsRelationFilter;

  factory CopyWith$Input$ColorsRelationFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsRelationFilter;

  TRes call({
    Input$ColorsWhereInput? $is,
    Input$ColorsWhereInput? isNot,
  });
  CopyWith$Input$ColorsWhereInput<TRes> get $is;
  CopyWith$Input$ColorsWhereInput<TRes> get isNot;
}

class _CopyWithImpl$Input$ColorsRelationFilter<TRes>
    implements CopyWith$Input$ColorsRelationFilter<TRes> {
  _CopyWithImpl$Input$ColorsRelationFilter(
    this._instance,
    this._then,
  );

  final Input$ColorsRelationFilter _instance;

  final TRes Function(Input$ColorsRelationFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $is = _undefined,
    Object? isNot = _undefined,
  }) =>
      _then(Input$ColorsRelationFilter._({
        ..._instance._$data,
        if ($is != _undefined) 'is': ($is as Input$ColorsWhereInput?),
        if (isNot != _undefined) 'isNot': (isNot as Input$ColorsWhereInput?),
      }));
  CopyWith$Input$ColorsWhereInput<TRes> get $is {
    final local$$is = _instance.$is;
    return local$$is == null
        ? CopyWith$Input$ColorsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ColorsWhereInput(local$$is, (e) => call($is: e));
  }

  CopyWith$Input$ColorsWhereInput<TRes> get isNot {
    final local$isNot = _instance.isNot;
    return local$isNot == null
        ? CopyWith$Input$ColorsWhereInput.stub(_then(_instance))
        : CopyWith$Input$ColorsWhereInput(local$isNot, (e) => call(isNot: e));
  }
}

class _CopyWithStubImpl$Input$ColorsRelationFilter<TRes>
    implements CopyWith$Input$ColorsRelationFilter<TRes> {
  _CopyWithStubImpl$Input$ColorsRelationFilter(this._res);

  TRes _res;

  call({
    Input$ColorsWhereInput? $is,
    Input$ColorsWhereInput? isNot,
  }) =>
      _res;
  CopyWith$Input$ColorsWhereInput<TRes> get $is =>
      CopyWith$Input$ColorsWhereInput.stub(_res);
  CopyWith$Input$ColorsWhereInput<TRes> get isNot =>
      CopyWith$Input$ColorsWhereInput.stub(_res);
}

class Input$ColorsOrderByWithRelationInput {
  factory Input$ColorsOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  }) =>
      Input$ColorsOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ColorsOrderByWithRelationInput._(this._$data);

  factory Input$ColorsOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] =
          l$color == null ? null : fromJson$Enum$SortOrder((l$color as String));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelOrderByRelationAggregateInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ColorsOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get color => (_$data['color'] as Enum$SortOrder?);
  Input$ProductModelOrderByRelationAggregateInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$SortOrder(l$color);
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsOrderByWithRelationInput<
          Input$ColorsOrderByWithRelationInput>
      get copyWith => CopyWith$Input$ColorsOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$ColorsOrderByWithRelationInput(
    Input$ColorsOrderByWithRelationInput instance,
    TRes Function(Input$ColorsOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$ColorsOrderByWithRelationInput;

  factory CopyWith$Input$ColorsOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  });
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$ColorsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ColorsOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$ColorsOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$ColorsOrderByWithRelationInput _instance;

  final TRes Function(Input$ColorsOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ColorsOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (color != _undefined) 'color': (color as Enum$SortOrder?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelOrderByRelationAggregateInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ColorsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ColorsOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$ColorsOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(_res);
}

class Input$ProductModelOrderByRelationAggregateInput {
  factory Input$ProductModelOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$ProductModelOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$ProductModelOrderByRelationAggregateInput._(this._$data);

  factory Input$ProductModelOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$ProductModelOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelOrderByRelationAggregateInput<
          Input$ProductModelOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$ProductModelOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelOrderByRelationAggregateInput(
    Input$ProductModelOrderByRelationAggregateInput instance,
    TRes Function(Input$ProductModelOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelOrderByRelationAggregateInput;

  factory CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$ProductModelOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelOrderByRelationAggregateInput _instance;

  final TRes Function(Input$ProductModelOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$ProductModelOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$ColorsWhereUniqueInput {
  factory Input$ColorsWhereUniqueInput({int? id}) =>
      Input$ColorsWhereUniqueInput._({
        if (id != null) r'id': id,
      });

  Input$ColorsWhereUniqueInput._(this._$data);

  factory Input$ColorsWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    return Input$ColorsWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$ColorsWhereUniqueInput<Input$ColorsWhereUniqueInput>
      get copyWith => CopyWith$Input$ColorsWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ColorsWhereUniqueInput<TRes> {
  factory CopyWith$Input$ColorsWhereUniqueInput(
    Input$ColorsWhereUniqueInput instance,
    TRes Function(Input$ColorsWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$ColorsWhereUniqueInput;

  factory CopyWith$Input$ColorsWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsWhereUniqueInput;

  TRes call({int? id});
}

class _CopyWithImpl$Input$ColorsWhereUniqueInput<TRes>
    implements CopyWith$Input$ColorsWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$ColorsWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$ColorsWhereUniqueInput _instance;

  final TRes Function(Input$ColorsWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) => _then(Input$ColorsWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
      }));
}

class _CopyWithStubImpl$Input$ColorsWhereUniqueInput<TRes>
    implements CopyWith$Input$ColorsWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$ColorsWhereUniqueInput(this._res);

  TRes _res;

  call({int? id}) => _res;
}

class Input$ProductsOrderByWithRelationInput {
  factory Input$ProductsOrderByWithRelationInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductFamilyOrderByWithRelationInput? family,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
    Input$TransactionProductOrderByRelationAggregateInput? TransactionProduct,
  }) =>
      Input$ProductsOrderByWithRelationInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
        if (family != null) r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsOrderByWithRelationInput._(this._$data);

  factory Input$ProductsOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    if (data.containsKey('family')) {
      final l$family = data['family'];
      result$data['family'] = l$family == null
          ? null
          : Input$ProductFamilyOrderByWithRelationInput.fromJson(
              (l$family as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelOrderByRelationAggregateInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductOrderByRelationAggregateInput.fromJson(
              (l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Input$ProductFamilyOrderByWithRelationInput? get family =>
      (_$data['family'] as Input$ProductFamilyOrderByWithRelationInput?);
  Input$ProductModelOrderByRelationAggregateInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelOrderByRelationAggregateInput?);
  Input$TransactionProductOrderByRelationAggregateInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    if (_$data.containsKey('family')) {
      final l$family = family;
      result$data['family'] = l$family?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsOrderByWithRelationInput<
          Input$ProductsOrderByWithRelationInput>
      get copyWith => CopyWith$Input$ProductsOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (_$data.containsKey('family') != other._$data.containsKey('family')) {
      return false;
    }
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    final l$family = family;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
      _$data.containsKey('family') ? l$family : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$ProductsOrderByWithRelationInput(
    Input$ProductsOrderByWithRelationInput instance,
    TRes Function(Input$ProductsOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$ProductsOrderByWithRelationInput;

  factory CopyWith$Input$ProductsOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductFamilyOrderByWithRelationInput? family,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
    Input$TransactionProductOrderByRelationAggregateInput? TransactionProduct,
  });
  CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> get family;
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel;
  CopyWith$Input$TransactionProductOrderByRelationAggregateInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductsOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$ProductsOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$ProductsOrderByWithRelationInput _instance;

  final TRes Function(Input$ProductsOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsOrderByWithRelationInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
        if (family != _undefined)
          'family': (family as Input$ProductFamilyOrderByWithRelationInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelOrderByRelationAggregateInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> get family {
    final local$family = _instance.family;
    return local$family == null
        ? CopyWith$Input$ProductFamilyOrderByWithRelationInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyOrderByWithRelationInput(
            local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelOrderByRelationAggregateInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductOrderByRelationAggregateInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductOrderByRelationAggregateInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductsOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$ProductsOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductFamilyOrderByWithRelationInput? family,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
    Input$TransactionProductOrderByRelationAggregateInput? TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> get family =>
      CopyWith$Input$ProductFamilyOrderByWithRelationInput.stub(_res);
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(_res);
  CopyWith$Input$TransactionProductOrderByRelationAggregateInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductOrderByRelationAggregateInput.stub(
              _res);
}

class Input$ProductFamilyOrderByWithRelationInput {
  factory Input$ProductFamilyOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductsOrderByRelationAggregateInput? Products,
  }) =>
      Input$ProductFamilyOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if (Products != null) r'Products': Products,
      });

  Input$ProductFamilyOrderByWithRelationInput._(this._$data);

  factory Input$ProductFamilyOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('Products')) {
      final l$Products = data['Products'];
      result$data['Products'] = l$Products == null
          ? null
          : Input$ProductsOrderByRelationAggregateInput.fromJson(
              (l$Products as Map<String, dynamic>));
    }
    return Input$ProductFamilyOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Input$ProductsOrderByRelationAggregateInput? get Products =>
      (_$data['Products'] as Input$ProductsOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('Products')) {
      final l$Products = Products;
      result$data['Products'] = l$Products?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyOrderByWithRelationInput<
          Input$ProductFamilyOrderByWithRelationInput>
      get copyWith => CopyWith$Input$ProductFamilyOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$Products = Products;
    final lOther$Products = other.Products;
    if (_$data.containsKey('Products') !=
        other._$data.containsKey('Products')) {
      return false;
    }
    if (l$Products != lOther$Products) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$Products = Products;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('Products') ? l$Products : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$ProductFamilyOrderByWithRelationInput(
    Input$ProductFamilyOrderByWithRelationInput instance,
    TRes Function(Input$ProductFamilyOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyOrderByWithRelationInput;

  factory CopyWith$Input$ProductFamilyOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductsOrderByRelationAggregateInput? Products,
  });
  CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> get Products;
}

class _CopyWithImpl$Input$ProductFamilyOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyOrderByWithRelationInput _instance;

  final TRes Function(Input$ProductFamilyOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? Products = _undefined,
  }) =>
      _then(Input$ProductFamilyOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (Products != _undefined)
          'Products':
              (Products as Input$ProductsOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> get Products {
    final local$Products = _instance.Products;
    return local$Products == null
        ? CopyWith$Input$ProductsOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsOrderByRelationAggregateInput(
            local$Products, (e) => call(Products: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductFamilyOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductsOrderByRelationAggregateInput? Products,
  }) =>
      _res;
  CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> get Products =>
      CopyWith$Input$ProductsOrderByRelationAggregateInput.stub(_res);
}

class Input$ProductsOrderByRelationAggregateInput {
  factory Input$ProductsOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$ProductsOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$ProductsOrderByRelationAggregateInput._(this._$data);

  factory Input$ProductsOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$ProductsOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$ProductsOrderByRelationAggregateInput<
          Input$ProductsOrderByRelationAggregateInput>
      get copyWith => CopyWith$Input$ProductsOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> {
  factory CopyWith$Input$ProductsOrderByRelationAggregateInput(
    Input$ProductsOrderByRelationAggregateInput instance,
    TRes Function(Input$ProductsOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsOrderByRelationAggregateInput;

  factory CopyWith$Input$ProductsOrderByRelationAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$ProductsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsOrderByRelationAggregateInput _instance;

  final TRes Function(Input$ProductsOrderByRelationAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$ProductsOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsOrderByRelationAggregateInput<TRes>
    implements CopyWith$Input$ProductsOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsOrderByRelationAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$TransactionProductOrderByRelationAggregateInput {
  factory Input$TransactionProductOrderByRelationAggregateInput(
          {Enum$SortOrder? $_count}) =>
      Input$TransactionProductOrderByRelationAggregateInput._({
        if ($_count != null) r'_count': $_count,
      });

  Input$TransactionProductOrderByRelationAggregateInput._(this._$data);

  factory Input$TransactionProductOrderByRelationAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : fromJson$Enum$SortOrder((l$$_count as String));
    }
    return Input$TransactionProductOrderByRelationAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get $_count => (_$data['_count'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] =
          l$$_count == null ? null : toJson$Enum$SortOrder(l$$_count);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductOrderByRelationAggregateInput<
          Input$TransactionProductOrderByRelationAggregateInput>
      get copyWith =>
          CopyWith$Input$TransactionProductOrderByRelationAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductOrderByRelationAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$_count = $_count;
    return Object.hashAll(
        [_$data.containsKey('_count') ? l$$_count : const {}]);
  }
}

abstract class CopyWith$Input$TransactionProductOrderByRelationAggregateInput<
    TRes> {
  factory CopyWith$Input$TransactionProductOrderByRelationAggregateInput(
    Input$TransactionProductOrderByRelationAggregateInput instance,
    TRes Function(Input$TransactionProductOrderByRelationAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductOrderByRelationAggregateInput;

  factory CopyWith$Input$TransactionProductOrderByRelationAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductOrderByRelationAggregateInput;

  TRes call({Enum$SortOrder? $_count});
}

class _CopyWithImpl$Input$TransactionProductOrderByRelationAggregateInput<TRes>
    implements
        CopyWith$Input$TransactionProductOrderByRelationAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductOrderByRelationAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductOrderByRelationAggregateInput _instance;

  final TRes Function(Input$TransactionProductOrderByRelationAggregateInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $_count = _undefined}) =>
      _then(Input$TransactionProductOrderByRelationAggregateInput._({
        ..._instance._$data,
        if ($_count != _undefined) '_count': ($_count as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductOrderByRelationAggregateInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductOrderByRelationAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductOrderByRelationAggregateInput(
      this._res);

  TRes _res;

  call({Enum$SortOrder? $_count}) => _res;
}

class Input$ProductsWhereUniqueInput {
  factory Input$ProductsWhereUniqueInput({int? product_id}) =>
      Input$ProductsWhereUniqueInput._({
        if (product_id != null) r'product_id': product_id,
      });

  Input$ProductsWhereUniqueInput._(this._$data);

  factory Input$ProductsWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = (l$product_id as int?);
    }
    return Input$ProductsWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get product_id => (_$data['product_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id;
    }
    return result$data;
  }

  CopyWith$Input$ProductsWhereUniqueInput<Input$ProductsWhereUniqueInput>
      get copyWith => CopyWith$Input$ProductsWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    return Object.hashAll(
        [_$data.containsKey('product_id') ? l$product_id : const {}]);
  }
}

abstract class CopyWith$Input$ProductsWhereUniqueInput<TRes> {
  factory CopyWith$Input$ProductsWhereUniqueInput(
    Input$ProductsWhereUniqueInput instance,
    TRes Function(Input$ProductsWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$ProductsWhereUniqueInput;

  factory CopyWith$Input$ProductsWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsWhereUniqueInput;

  TRes call({int? product_id});
}

class _CopyWithImpl$Input$ProductsWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductsWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$ProductsWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$ProductsWhereUniqueInput _instance;

  final TRes Function(Input$ProductsWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? product_id = _undefined}) =>
      _then(Input$ProductsWhereUniqueInput._({
        ..._instance._$data,
        if (product_id != _undefined) 'product_id': (product_id as int?),
      }));
}

class _CopyWithStubImpl$Input$ProductsWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductsWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$ProductsWhereUniqueInput(this._res);

  TRes _res;

  call({int? product_id}) => _res;
}

class Input$ProductModelOrderByWithRelationInput {
  factory Input$ProductModelOrderByWithRelationInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductsOrderByWithRelationInput? product,
    Input$SizesOrderByWithRelationInput? size,
    Input$ColorsOrderByWithRelationInput? color,
  }) =>
      Input$ProductModelOrderByWithRelationInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
        if (product != null) r'product': product,
        if (size != null) r'size': size,
        if (color != null) r'color': color,
      });

  Input$ProductModelOrderByWithRelationInput._(this._$data);

  factory Input$ProductModelOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsOrderByWithRelationInput.fromJson(
              (l$product as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$SizesOrderByWithRelationInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$ColorsOrderByWithRelationInput.fromJson(
              (l$color as Map<String, dynamic>));
    }
    return Input$ProductModelOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Input$ProductsOrderByWithRelationInput? get product =>
      (_$data['product'] as Input$ProductsOrderByWithRelationInput?);
  Input$SizesOrderByWithRelationInput? get size =>
      (_$data['size'] as Input$SizesOrderByWithRelationInput?);
  Input$ColorsOrderByWithRelationInput? get color =>
      (_$data['color'] as Input$ColorsOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelOrderByWithRelationInput<
          Input$ProductModelOrderByWithRelationInput>
      get copyWith => CopyWith$Input$ProductModelOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('product') ? l$product : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$ProductModelOrderByWithRelationInput(
    Input$ProductModelOrderByWithRelationInput instance,
    TRes Function(Input$ProductModelOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$ProductModelOrderByWithRelationInput;

  factory CopyWith$Input$ProductModelOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductsOrderByWithRelationInput? product,
    Input$SizesOrderByWithRelationInput? size,
    Input$ColorsOrderByWithRelationInput? color,
  });
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product;
  CopyWith$Input$SizesOrderByWithRelationInput<TRes> get size;
  CopyWith$Input$ColorsOrderByWithRelationInput<TRes> get color;
}

class _CopyWithImpl$Input$ProductModelOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductModelOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$ProductModelOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelOrderByWithRelationInput _instance;

  final TRes Function(Input$ProductModelOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelOrderByWithRelationInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (product != _undefined)
          'product': (product as Input$ProductsOrderByWithRelationInput?),
        if (size != _undefined)
          'size': (size as Input$SizesOrderByWithRelationInput?),
        if (color != _undefined)
          'color': (color as Input$ColorsOrderByWithRelationInput?),
      }));
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$ProductsOrderByWithRelationInput(
            local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesOrderByWithRelationInput<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$SizesOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$SizesOrderByWithRelationInput(
            local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsOrderByWithRelationInput<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$ColorsOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$ColorsOrderByWithRelationInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelOrderByWithRelationInput<TRes>
    implements CopyWith$Input$ProductModelOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductsOrderByWithRelationInput? product,
    Input$SizesOrderByWithRelationInput? size,
    Input$ColorsOrderByWithRelationInput? color,
  }) =>
      _res;
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product =>
      CopyWith$Input$ProductsOrderByWithRelationInput.stub(_res);
  CopyWith$Input$SizesOrderByWithRelationInput<TRes> get size =>
      CopyWith$Input$SizesOrderByWithRelationInput.stub(_res);
  CopyWith$Input$ColorsOrderByWithRelationInput<TRes> get color =>
      CopyWith$Input$ColorsOrderByWithRelationInput.stub(_res);
}

class Input$SizesOrderByWithRelationInput {
  factory Input$SizesOrderByWithRelationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  }) =>
      Input$SizesOrderByWithRelationInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$SizesOrderByWithRelationInput._(this._$data);

  factory Input$SizesOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$Enum$SortOrder((l$size as String));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelOrderByRelationAggregateInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$SizesOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get size => (_$data['size'] as Enum$SortOrder?);
  Input$ProductModelOrderByRelationAggregateInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelOrderByRelationAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] =
          l$size == null ? null : toJson$Enum$SortOrder(l$size);
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesOrderByWithRelationInput<
          Input$SizesOrderByWithRelationInput>
      get copyWith => CopyWith$Input$SizesOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$SizesOrderByWithRelationInput(
    Input$SizesOrderByWithRelationInput instance,
    TRes Function(Input$SizesOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$SizesOrderByWithRelationInput;

  factory CopyWith$Input$SizesOrderByWithRelationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  });
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$SizesOrderByWithRelationInput<TRes>
    implements CopyWith$Input$SizesOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$SizesOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$SizesOrderByWithRelationInput _instance;

  final TRes Function(Input$SizesOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$SizesOrderByWithRelationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (size != _undefined) 'size': (size as Enum$SortOrder?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelOrderByRelationAggregateInput?),
      }));
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelOrderByRelationAggregateInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$SizesOrderByWithRelationInput<TRes>
    implements CopyWith$Input$SizesOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$SizesOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$ProductModelOrderByRelationAggregateInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$ProductModelOrderByRelationAggregateInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelOrderByRelationAggregateInput.stub(_res);
}

class Input$ProductModelWhereUniqueInput {
  factory Input$ProductModelWhereUniqueInput(
          {Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?
              product_id_color_id_size_id}) =>
      Input$ProductModelWhereUniqueInput._({
        if (product_id_color_id_size_id != null)
          r'product_id_color_id_size_id': product_id_color_id_size_id,
      });

  Input$ProductModelWhereUniqueInput._(this._$data);

  factory Input$ProductModelWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id_color_id_size_id')) {
      final l$product_id_color_id_size_id = data['product_id_color_id_size_id'];
      result$data['product_id_color_id_size_id'] =
          l$product_id_color_id_size_id == null
              ? null
              : Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput
                  .fromJson(
                      (l$product_id_color_id_size_id as Map<String, dynamic>));
    }
    return Input$ProductModelWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?
      get product_id_color_id_size_id => (_$data['product_id_color_id_size_id']
          as Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id_color_id_size_id')) {
      final l$product_id_color_id_size_id = product_id_color_id_size_id;
      result$data['product_id_color_id_size_id'] =
          l$product_id_color_id_size_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelWhereUniqueInput<
          Input$ProductModelWhereUniqueInput>
      get copyWith => CopyWith$Input$ProductModelWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id_color_id_size_id = product_id_color_id_size_id;
    final lOther$product_id_color_id_size_id =
        other.product_id_color_id_size_id;
    if (_$data.containsKey('product_id_color_id_size_id') !=
        other._$data.containsKey('product_id_color_id_size_id')) {
      return false;
    }
    if (l$product_id_color_id_size_id != lOther$product_id_color_id_size_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id_color_id_size_id = product_id_color_id_size_id;
    return Object.hashAll([
      _$data.containsKey('product_id_color_id_size_id')
          ? l$product_id_color_id_size_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$ProductModelWhereUniqueInput<TRes> {
  factory CopyWith$Input$ProductModelWhereUniqueInput(
    Input$ProductModelWhereUniqueInput instance,
    TRes Function(Input$ProductModelWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$ProductModelWhereUniqueInput;

  factory CopyWith$Input$ProductModelWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelWhereUniqueInput;

  TRes call(
      {Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?
          product_id_color_id_size_id});
  CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<TRes>
      get product_id_color_id_size_id;
}

class _CopyWithImpl$Input$ProductModelWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductModelWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$ProductModelWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelWhereUniqueInput _instance;

  final TRes Function(Input$ProductModelWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? product_id_color_id_size_id = _undefined}) =>
      _then(Input$ProductModelWhereUniqueInput._({
        ..._instance._$data,
        if (product_id_color_id_size_id != _undefined)
          'product_id_color_id_size_id': (product_id_color_id_size_id
              as Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?),
      }));
  CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<TRes>
      get product_id_color_id_size_id {
    final local$product_id_color_id_size_id =
        _instance.product_id_color_id_size_id;
    return local$product_id_color_id_size_id == null
        ? CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput(
            local$product_id_color_id_size_id,
            (e) => call(product_id_color_id_size_id: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductModelWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelWhereUniqueInput(this._res);

  TRes _res;

  call(
          {Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput?
              product_id_color_id_size_id}) =>
      _res;
  CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<TRes>
      get product_id_color_id_size_id =>
          CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput
              .stub(_res);
}

class Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput {
  factory Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput({
    required int product_id,
    required int color_id,
    required int size_id,
  }) =>
      Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput._({
        r'product_id': product_id,
        r'color_id': color_id,
        r'size_id': size_id,
      });

  Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput._(this._$data);

  factory Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$color_id = data['color_id'];
    result$data['color_id'] = (l$color_id as int);
    final l$size_id = data['size_id'];
    result$data['size_id'] = (l$size_id as int);
    return Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  int get product_id => (_$data['product_id'] as int);
  int get color_id => (_$data['color_id'] as int);
  int get size_id => (_$data['size_id'] as int);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$color_id = color_id;
    result$data['color_id'] = l$color_id;
    final l$size_id = size_id;
    result$data['size_id'] = l$size_id;
    return result$data;
  }

  CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
          Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput>
      get copyWith =>
          CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (l$size_id != lOther$size_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    return Object.hashAll([
      l$product_id,
      l$color_id,
      l$size_id,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
    TRes> {
  factory CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput(
    Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput instance,
    TRes Function(
            Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput;

  factory CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput;

  TRes call({
    int? product_id,
    int? color_id,
    int? size_id,
  });
}

class _CopyWithImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
        TRes>
    implements
        CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput
      _instance;

  final TRes Function(
      Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
  }) =>
      _then(Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput._({
        ..._instance._$data,
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (color_id != _undefined && color_id != null)
          'color_id': (color_id as int),
        if (size_id != _undefined && size_id != null)
          'size_id': (size_id as int),
      }));
}

class _CopyWithStubImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
        TRes>
    implements
        CopyWith$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelProduct_idColor_idSize_idCompoundUniqueInput(
      this._res);

  TRes _res;

  call({
    int? product_id,
    int? color_id,
    int? size_id,
  }) =>
      _res;
}

class Input$TransactionProductOrderByWithRelationInput {
  factory Input$TransactionProductOrderByWithRelationInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$ProductsOrderByWithRelationInput? product,
  }) =>
      Input$TransactionProductOrderByWithRelationInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
        if (product != null) r'product': product,
      });

  Input$TransactionProductOrderByWithRelationInput._(this._$data);

  factory Input$TransactionProductOrderByWithRelationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : fromJson$Enum$SortOrder((l$product_name as String));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsOrderByWithRelationInput.fromJson(
              (l$product as Map<String, dynamic>));
    }
    return Input$TransactionProductOrderByWithRelationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Enum$SortOrder? get product_name =>
      (_$data['product_name'] as Enum$SortOrder?);
  Input$ProductsOrderByWithRelationInput? get product =>
      (_$data['product'] as Input$ProductsOrderByWithRelationInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] =
          l$product_name == null ? null : toJson$Enum$SortOrder(l$product_name);
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductOrderByWithRelationInput<
          Input$TransactionProductOrderByWithRelationInput>
      get copyWith => CopyWith$Input$TransactionProductOrderByWithRelationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductOrderByWithRelationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    final l$product = product;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
      _$data.containsKey('product') ? l$product : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductOrderByWithRelationInput<TRes> {
  factory CopyWith$Input$TransactionProductOrderByWithRelationInput(
    Input$TransactionProductOrderByWithRelationInput instance,
    TRes Function(Input$TransactionProductOrderByWithRelationInput) then,
  ) = _CopyWithImpl$Input$TransactionProductOrderByWithRelationInput;

  factory CopyWith$Input$TransactionProductOrderByWithRelationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductOrderByWithRelationInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$ProductsOrderByWithRelationInput? product,
  });
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product;
}

class _CopyWithImpl$Input$TransactionProductOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionProductOrderByWithRelationInput<TRes> {
  _CopyWithImpl$Input$TransactionProductOrderByWithRelationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductOrderByWithRelationInput _instance;

  final TRes Function(Input$TransactionProductOrderByWithRelationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
    Object? product = _undefined,
  }) =>
      _then(Input$TransactionProductOrderByWithRelationInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
        if (product_name != _undefined)
          'product_name': (product_name as Enum$SortOrder?),
        if (product != _undefined)
          'product': (product as Input$ProductsOrderByWithRelationInput?),
      }));
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsOrderByWithRelationInput.stub(_then(_instance))
        : CopyWith$Input$ProductsOrderByWithRelationInput(
            local$product, (e) => call(product: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductOrderByWithRelationInput<TRes>
    implements CopyWith$Input$TransactionProductOrderByWithRelationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductOrderByWithRelationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$ProductsOrderByWithRelationInput? product,
  }) =>
      _res;
  CopyWith$Input$ProductsOrderByWithRelationInput<TRes> get product =>
      CopyWith$Input$ProductsOrderByWithRelationInput.stub(_res);
}

class Input$TransactionProductWhereUniqueInput {
  factory Input$TransactionProductWhereUniqueInput({int? transaction_id}) =>
      Input$TransactionProductWhereUniqueInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
      });

  Input$TransactionProductWhereUniqueInput._(this._$data);

  factory Input$TransactionProductWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = (l$transaction_id as int?);
    }
    return Input$TransactionProductWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get transaction_id => (_$data['transaction_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id;
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductWhereUniqueInput<
          Input$TransactionProductWhereUniqueInput>
      get copyWith => CopyWith$Input$TransactionProductWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    return Object.hashAll(
        [_$data.containsKey('transaction_id') ? l$transaction_id : const {}]);
  }
}

abstract class CopyWith$Input$TransactionProductWhereUniqueInput<TRes> {
  factory CopyWith$Input$TransactionProductWhereUniqueInput(
    Input$TransactionProductWhereUniqueInput instance,
    TRes Function(Input$TransactionProductWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$TransactionProductWhereUniqueInput;

  factory CopyWith$Input$TransactionProductWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductWhereUniqueInput;

  TRes call({int? transaction_id});
}

class _CopyWithImpl$Input$TransactionProductWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionProductWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$TransactionProductWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductWhereUniqueInput _instance;

  final TRes Function(Input$TransactionProductWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_id = _undefined}) =>
      _then(Input$TransactionProductWhereUniqueInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as int?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionProductWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductWhereUniqueInput(this._res);

  TRes _res;

  call({int? transaction_id}) => _res;
}

class Input$ColorsOrderByWithAggregationInput {
  factory Input$ColorsOrderByWithAggregationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ColorsCountOrderByAggregateInput? $_count,
    Input$ColorsAvgOrderByAggregateInput? $_avg,
    Input$ColorsMaxOrderByAggregateInput? $_max,
    Input$ColorsMinOrderByAggregateInput? $_min,
    Input$ColorsSumOrderByAggregateInput? $_sum,
  }) =>
      Input$ColorsOrderByWithAggregationInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$ColorsOrderByWithAggregationInput._(this._$data);

  factory Input$ColorsOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] =
          l$color == null ? null : fromJson$Enum$SortOrder((l$color as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$ColorsCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$ColorsAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$ColorsMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$ColorsMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$ColorsSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$ColorsOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get color => (_$data['color'] as Enum$SortOrder?);
  Input$ColorsCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$ColorsCountOrderByAggregateInput?);
  Input$ColorsAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$ColorsAvgOrderByAggregateInput?);
  Input$ColorsMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$ColorsMaxOrderByAggregateInput?);
  Input$ColorsMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$ColorsMinOrderByAggregateInput?);
  Input$ColorsSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$ColorsSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$SortOrder(l$color);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsOrderByWithAggregationInput<
          Input$ColorsOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$ColorsOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$ColorsOrderByWithAggregationInput(
    Input$ColorsOrderByWithAggregationInput instance,
    TRes Function(Input$ColorsOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$ColorsOrderByWithAggregationInput;

  factory CopyWith$Input$ColorsOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ColorsCountOrderByAggregateInput? $_count,
    Input$ColorsAvgOrderByAggregateInput? $_avg,
    Input$ColorsMaxOrderByAggregateInput? $_max,
    Input$ColorsMinOrderByAggregateInput? $_min,
    Input$ColorsSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$ColorsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ColorsOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$ColorsOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$ColorsOrderByWithAggregationInput _instance;

  final TRes Function(Input$ColorsOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$ColorsOrderByWithAggregationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (color != _undefined) 'color': (color as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$ColorsCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$ColorsAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$ColorsMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$ColorsMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$ColorsSumOrderByAggregateInput?),
      }));
  CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$ColorsCountOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ColorsCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$ColorsAvgOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ColorsAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$ColorsMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ColorsMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$ColorsMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ColorsMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$ColorsSumOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ColorsSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$ColorsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ColorsOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$ColorsOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
    Input$ColorsCountOrderByAggregateInput? $_count,
    Input$ColorsAvgOrderByAggregateInput? $_avg,
    Input$ColorsMaxOrderByAggregateInput? $_max,
    Input$ColorsMinOrderByAggregateInput? $_min,
    Input$ColorsSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$ColorsCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$ColorsAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$ColorsMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$ColorsMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$ColorsSumOrderByAggregateInput.stub(_res);
}

class Input$ColorsCountOrderByAggregateInput {
  factory Input$ColorsCountOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      Input$ColorsCountOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsCountOrderByAggregateInput._(this._$data);

  factory Input$ColorsCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] =
          l$color == null ? null : fromJson$Enum$SortOrder((l$color as String));
    }
    return Input$ColorsCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get color => (_$data['color'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$SortOrder(l$color);
    }
    return result$data;
  }

  CopyWith$Input$ColorsCountOrderByAggregateInput<
          Input$ColorsCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$ColorsCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ColorsCountOrderByAggregateInput(
    Input$ColorsCountOrderByAggregateInput instance,
    TRes Function(Input$ColorsCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ColorsCountOrderByAggregateInput;

  factory CopyWith$Input$ColorsCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  });
}

class _CopyWithImpl$Input$ColorsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ColorsCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsCountOrderByAggregateInput _instance;

  final TRes Function(Input$ColorsCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsCountOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (color != _undefined) 'color': (color as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ColorsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      _res;
}

class Input$ColorsAvgOrderByAggregateInput {
  factory Input$ColorsAvgOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$ColorsAvgOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$ColorsAvgOrderByAggregateInput._(this._$data);

  factory Input$ColorsAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$ColorsAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$ColorsAvgOrderByAggregateInput<
          Input$ColorsAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$ColorsAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ColorsAvgOrderByAggregateInput(
    Input$ColorsAvgOrderByAggregateInput instance,
    TRes Function(Input$ColorsAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ColorsAvgOrderByAggregateInput;

  factory CopyWith$Input$ColorsAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$ColorsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ColorsAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsAvgOrderByAggregateInput _instance;

  final TRes Function(Input$ColorsAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$ColorsAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ColorsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$ColorsMaxOrderByAggregateInput {
  factory Input$ColorsMaxOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      Input$ColorsMaxOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsMaxOrderByAggregateInput._(this._$data);

  factory Input$ColorsMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] =
          l$color == null ? null : fromJson$Enum$SortOrder((l$color as String));
    }
    return Input$ColorsMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get color => (_$data['color'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$SortOrder(l$color);
    }
    return result$data;
  }

  CopyWith$Input$ColorsMaxOrderByAggregateInput<
          Input$ColorsMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$ColorsMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ColorsMaxOrderByAggregateInput(
    Input$ColorsMaxOrderByAggregateInput instance,
    TRes Function(Input$ColorsMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ColorsMaxOrderByAggregateInput;

  factory CopyWith$Input$ColorsMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  });
}

class _CopyWithImpl$Input$ColorsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ColorsMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsMaxOrderByAggregateInput _instance;

  final TRes Function(Input$ColorsMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (color != _undefined) 'color': (color as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ColorsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      _res;
}

class Input$ColorsMinOrderByAggregateInput {
  factory Input$ColorsMinOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      Input$ColorsMinOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsMinOrderByAggregateInput._(this._$data);

  factory Input$ColorsMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] =
          l$color == null ? null : fromJson$Enum$SortOrder((l$color as String));
    }
    return Input$ColorsMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get color => (_$data['color'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] =
          l$color == null ? null : toJson$Enum$SortOrder(l$color);
    }
    return result$data;
  }

  CopyWith$Input$ColorsMinOrderByAggregateInput<
          Input$ColorsMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$ColorsMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ColorsMinOrderByAggregateInput(
    Input$ColorsMinOrderByAggregateInput instance,
    TRes Function(Input$ColorsMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ColorsMinOrderByAggregateInput;

  factory CopyWith$Input$ColorsMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  });
}

class _CopyWithImpl$Input$ColorsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ColorsMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsMinOrderByAggregateInput _instance;

  final TRes Function(Input$ColorsMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsMinOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (color != _undefined) 'color': (color as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ColorsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? color,
  }) =>
      _res;
}

class Input$ColorsSumOrderByAggregateInput {
  factory Input$ColorsSumOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$ColorsSumOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$ColorsSumOrderByAggregateInput._(this._$data);

  factory Input$ColorsSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$ColorsSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$ColorsSumOrderByAggregateInput<
          Input$ColorsSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$ColorsSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ColorsSumOrderByAggregateInput(
    Input$ColorsSumOrderByAggregateInput instance,
    TRes Function(Input$ColorsSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ColorsSumOrderByAggregateInput;

  factory CopyWith$Input$ColorsSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsSumOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$ColorsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ColorsSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsSumOrderByAggregateInput _instance;

  final TRes Function(Input$ColorsSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$ColorsSumOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ColorsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ColorsSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsSumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$ColorsScalarWhereWithAggregatesInput {
  factory Input$ColorsScalarWhereWithAggregatesInput({
    List<Input$ColorsScalarWhereWithAggregatesInput>? AND,
    List<Input$ColorsScalarWhereWithAggregatesInput>? OR,
    List<Input$ColorsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? color,
  }) =>
      Input$ColorsScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsScalarWhereWithAggregatesInput._(this._$data);

  factory Input$ColorsScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ColorsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ColorsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ColorsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$color as Map<String, dynamic>));
    }
    return Input$ColorsScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ColorsScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$ColorsScalarWhereWithAggregatesInput>?);
  List<Input$ColorsScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$ColorsScalarWhereWithAggregatesInput>?);
  List<Input$ColorsScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$ColorsScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get id =>
      (_$data['id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get color =>
      (_$data['color'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
          Input$ColorsScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$ColorsScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$ColorsScalarWhereWithAggregatesInput(
    Input$ColorsScalarWhereWithAggregatesInput instance,
    TRes Function(Input$ColorsScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$ColorsScalarWhereWithAggregatesInput;

  factory CopyWith$Input$ColorsScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$ColorsScalarWhereWithAggregatesInput>? AND,
    List<Input$ColorsScalarWhereWithAggregatesInput>? OR,
    List<Input$ColorsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? color,
  });
  TRes AND(
      Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                      Input$ColorsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                      Input$ColorsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                      Input$ColorsScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get color;
}

class _CopyWithImpl$Input$ColorsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ColorsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$ColorsScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$ColorsScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$ColorsScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ColorsScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ColorsScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ColorsScalarWhereWithAggregatesInput>?),
        if (id != _undefined) 'id': (id as Input$IntWithAggregatesFilter?),
        if (color != _undefined)
          'color': (color as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                          Input$ColorsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$ColorsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                          Input$ColorsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$ColorsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ColorsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ColorsScalarWhereWithAggregatesInput<
                          Input$ColorsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$ColorsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ColorsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ColorsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$ColorsScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$ColorsScalarWhereWithAggregatesInput>? AND,
    List<Input$ColorsScalarWhereWithAggregatesInput>? OR,
    List<Input$ColorsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? color,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get color =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$PayementsOrderByWithAggregationInput {
  factory Input$PayementsOrderByWithAggregationInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$PayementsCountOrderByAggregateInput? $_count,
    Input$PayementsAvgOrderByAggregateInput? $_avg,
    Input$PayementsMaxOrderByAggregateInput? $_max,
    Input$PayementsMinOrderByAggregateInput? $_min,
    Input$PayementsSumOrderByAggregateInput? $_sum,
  }) =>
      Input$PayementsOrderByWithAggregationInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$PayementsOrderByWithAggregationInput._(this._$data);

  factory Input$PayementsOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$PayementsCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$PayementsAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$PayementsMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$PayementsMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$PayementsSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$PayementsOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Input$PayementsCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$PayementsCountOrderByAggregateInput?);
  Input$PayementsAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$PayementsAvgOrderByAggregateInput?);
  Input$PayementsMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$PayementsMaxOrderByAggregateInput?);
  Input$PayementsMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$PayementsMinOrderByAggregateInput?);
  Input$PayementsSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$PayementsSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsOrderByWithAggregationInput<
          Input$PayementsOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$PayementsOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$PayementsOrderByWithAggregationInput(
    Input$PayementsOrderByWithAggregationInput instance,
    TRes Function(Input$PayementsOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$PayementsOrderByWithAggregationInput;

  factory CopyWith$Input$PayementsOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$PayementsCountOrderByAggregateInput? $_count,
    Input$PayementsAvgOrderByAggregateInput? $_avg,
    Input$PayementsMaxOrderByAggregateInput? $_max,
    Input$PayementsMinOrderByAggregateInput? $_min,
    Input$PayementsSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$PayementsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$PayementsOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$PayementsOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$PayementsOrderByWithAggregationInput _instance;

  final TRes Function(Input$PayementsOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$PayementsOrderByWithAggregationInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$PayementsCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$PayementsAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$PayementsMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$PayementsMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$PayementsSumOrderByAggregateInput?),
      }));
  CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$PayementsCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$PayementsAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$PayementsMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$PayementsMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$PayementsSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$PayementsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$PayementsOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$PayementsOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
    Input$PayementsCountOrderByAggregateInput? $_count,
    Input$PayementsAvgOrderByAggregateInput? $_avg,
    Input$PayementsMaxOrderByAggregateInput? $_max,
    Input$PayementsMinOrderByAggregateInput? $_min,
    Input$PayementsSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$PayementsCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$PayementsAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$PayementsMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$PayementsMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$PayementsSumOrderByAggregateInput.stub(_res);
}

class Input$PayementsCountOrderByAggregateInput {
  factory Input$PayementsCountOrderByAggregateInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      Input$PayementsCountOrderByAggregateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsCountOrderByAggregateInput._(this._$data);

  factory Input$PayementsCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    return Input$PayementsCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    return result$data;
  }

  CopyWith$Input$PayementsCountOrderByAggregateInput<
          Input$PayementsCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$PayementsCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$PayementsCountOrderByAggregateInput(
    Input$PayementsCountOrderByAggregateInput instance,
    TRes Function(Input$PayementsCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsCountOrderByAggregateInput;

  factory CopyWith$Input$PayementsCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  });
}

class _CopyWithImpl$Input$PayementsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsCountOrderByAggregateInput _instance;

  final TRes Function(Input$PayementsCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsCountOrderByAggregateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      _res;
}

class Input$PayementsAvgOrderByAggregateInput {
  factory Input$PayementsAvgOrderByAggregateInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      Input$PayementsAvgOrderByAggregateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsAvgOrderByAggregateInput._(this._$data);

  factory Input$PayementsAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    return Input$PayementsAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    return result$data;
  }

  CopyWith$Input$PayementsAvgOrderByAggregateInput<
          Input$PayementsAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$PayementsAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$PayementsAvgOrderByAggregateInput(
    Input$PayementsAvgOrderByAggregateInput instance,
    TRes Function(Input$PayementsAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsAvgOrderByAggregateInput;

  factory CopyWith$Input$PayementsAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  });
}

class _CopyWithImpl$Input$PayementsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsAvgOrderByAggregateInput _instance;

  final TRes Function(Input$PayementsAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      _res;
}

class Input$PayementsMaxOrderByAggregateInput {
  factory Input$PayementsMaxOrderByAggregateInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      Input$PayementsMaxOrderByAggregateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsMaxOrderByAggregateInput._(this._$data);

  factory Input$PayementsMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    return Input$PayementsMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    return result$data;
  }

  CopyWith$Input$PayementsMaxOrderByAggregateInput<
          Input$PayementsMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$PayementsMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$PayementsMaxOrderByAggregateInput(
    Input$PayementsMaxOrderByAggregateInput instance,
    TRes Function(Input$PayementsMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsMaxOrderByAggregateInput;

  factory CopyWith$Input$PayementsMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  });
}

class _CopyWithImpl$Input$PayementsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsMaxOrderByAggregateInput _instance;

  final TRes Function(Input$PayementsMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      _res;
}

class Input$PayementsMinOrderByAggregateInput {
  factory Input$PayementsMinOrderByAggregateInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      Input$PayementsMinOrderByAggregateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsMinOrderByAggregateInput._(this._$data);

  factory Input$PayementsMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    return Input$PayementsMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    return result$data;
  }

  CopyWith$Input$PayementsMinOrderByAggregateInput<
          Input$PayementsMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$PayementsMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$PayementsMinOrderByAggregateInput(
    Input$PayementsMinOrderByAggregateInput instance,
    TRes Function(Input$PayementsMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsMinOrderByAggregateInput;

  factory CopyWith$Input$PayementsMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  });
}

class _CopyWithImpl$Input$PayementsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsMinOrderByAggregateInput _instance;

  final TRes Function(Input$PayementsMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsMinOrderByAggregateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      _res;
}

class Input$PayementsSumOrderByAggregateInput {
  factory Input$PayementsSumOrderByAggregateInput({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      Input$PayementsSumOrderByAggregateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsSumOrderByAggregateInput._(this._$data);

  factory Input$PayementsSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : fromJson$Enum$SortOrder((l$payement_id as String));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : fromJson$Enum$SortOrder((l$payement as String));
    }
    return Input$PayementsSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get payement_id => (_$data['payement_id'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get payement => (_$data['payement'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] =
          l$payement_id == null ? null : toJson$Enum$SortOrder(l$payement_id);
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] =
          l$payement == null ? null : toJson$Enum$SortOrder(l$payement);
    }
    return result$data;
  }

  CopyWith$Input$PayementsSumOrderByAggregateInput<
          Input$PayementsSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$PayementsSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$PayementsSumOrderByAggregateInput(
    Input$PayementsSumOrderByAggregateInput instance,
    TRes Function(Input$PayementsSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$PayementsSumOrderByAggregateInput;

  factory CopyWith$Input$PayementsSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  });
}

class _CopyWithImpl$Input$PayementsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$PayementsSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsSumOrderByAggregateInput _instance;

  final TRes Function(Input$PayementsSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsSumOrderByAggregateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Enum$SortOrder?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (payement != _undefined) 'payement': (payement as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$PayementsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$PayementsSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? payement_id,
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? payement,
  }) =>
      _res;
}

class Input$PayementsScalarWhereWithAggregatesInput {
  factory Input$PayementsScalarWhereWithAggregatesInput({
    List<Input$PayementsScalarWhereWithAggregatesInput>? AND,
    List<Input$PayementsScalarWhereWithAggregatesInput>? OR,
    List<Input$PayementsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? payement_id,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$FloatWithAggregatesFilter? payement,
  }) =>
      Input$PayementsScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsScalarWhereWithAggregatesInput._(this._$data);

  factory Input$PayementsScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$payement as Map<String, dynamic>));
    }
    return Input$PayementsScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayementsScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$PayementsScalarWhereWithAggregatesInput>?);
  List<Input$PayementsScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$PayementsScalarWhereWithAggregatesInput>?);
  List<Input$PayementsScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$PayementsScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get payement_id =>
      (_$data['payement_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get payement =>
      (_$data['payement'] as Input$FloatWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
          Input$PayementsScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$PayementsScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$PayementsScalarWhereWithAggregatesInput(
    Input$PayementsScalarWhereWithAggregatesInput instance,
    TRes Function(Input$PayementsScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$PayementsScalarWhereWithAggregatesInput;

  factory CopyWith$Input$PayementsScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$PayementsScalarWhereWithAggregatesInput>? AND,
    List<Input$PayementsScalarWhereWithAggregatesInput>? OR,
    List<Input$PayementsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? payement_id,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$FloatWithAggregatesFilter? payement,
  });
  TRes AND(
      Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                      Input$PayementsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                      Input$PayementsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                      Input$PayementsScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get payement_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get payement;
}

class _CopyWithImpl$Input$PayementsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$PayementsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$PayementsScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$PayementsScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$PayementsScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$PayementsScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$PayementsScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$PayementsScalarWhereWithAggregatesInput>?),
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntWithAggregatesFilter?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntWithAggregatesFilter?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                          Input$PayementsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$PayementsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                          Input$PayementsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$PayementsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$PayementsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereWithAggregatesInput<
                          Input$PayementsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$PayementsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$payement, (e) => call(payement: e));
  }
}

class _CopyWithStubImpl$Input$PayementsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$PayementsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$PayementsScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$PayementsScalarWhereWithAggregatesInput>? AND,
    List<Input$PayementsScalarWhereWithAggregatesInput>? OR,
    List<Input$PayementsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? payement_id,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$FloatWithAggregatesFilter? payement,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get payement_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get payement =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
}

class Input$FloatWithAggregatesFilter {
  factory Input$FloatWithAggregatesFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  }) =>
      Input$FloatWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_sum != null) r'_sum': $_sum,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$FloatWithAggregatesFilter._(this._$data);

  factory Input$FloatWithAggregatesFilter.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    return Input$FloatWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedFloatWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedFloatFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_min =>
      (_$data['_min'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_max =>
      (_$data['_max'] as Input$NestedFloatFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$FloatWithAggregatesFilter<Input$FloatWithAggregatesFilter>
      get copyWith => CopyWith$Input$FloatWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatWithAggregatesFilter<TRes> {
  factory CopyWith$Input$FloatWithAggregatesFilter(
    Input$FloatWithAggregatesFilter instance,
    TRes Function(Input$FloatWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$FloatWithAggregatesFilter;

  factory CopyWith$Input$FloatWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatWithAggregatesFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  });
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg;
  CopyWith$Input$NestedFloatFilter<TRes> get $_sum;
  CopyWith$Input$NestedFloatFilter<TRes> get $_min;
  CopyWith$Input$NestedFloatFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$FloatWithAggregatesFilter<TRes>
    implements CopyWith$Input$FloatWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$FloatWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$FloatWithAggregatesFilter _instance;

  final TRes Function(Input$FloatWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_sum = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$FloatWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined)
          'not': (not as Input$NestedFloatWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_avg != _undefined) '_avg': ($_avg as Input$NestedFloatFilter?),
        if ($_sum != _undefined) '_sum': ($_sum as Input$NestedFloatFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedFloatFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedFloatFilter?),
      }));
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$FloatWithAggregatesFilter<TRes>
    implements CopyWith$Input$FloatWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$FloatWithAggregatesFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedFloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_sum =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_min =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_max =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
}

class Input$NestedFloatWithAggregatesFilter {
  factory Input$NestedFloatWithAggregatesFilter({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  }) =>
      Input$NestedFloatWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_sum != null) r'_sum': $_sum,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$NestedFloatWithAggregatesFilter._(this._$data);

  factory Input$NestedFloatWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as num?)?.toDouble();
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as num).toDouble()).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] = (l$notIn as List<dynamic>?)
          ?.map((e) => (e as num).toDouble())
          .toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as num?)?.toDouble();
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as num?)?.toDouble();
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as num?)?.toDouble();
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as num?)?.toDouble();
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedFloatWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_sum as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedFloatFilter.fromJson((l$$_max as Map<String, dynamic>));
    }
    return Input$NestedFloatWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get equals => (_$data['equals'] as double?);
  List<double>? get $in => (_$data['in'] as List<double>?);
  List<double>? get notIn => (_$data['notIn'] as List<double>?);
  double? get lt => (_$data['lt'] as double?);
  double? get lte => (_$data['lte'] as double?);
  double? get gt => (_$data['gt'] as double?);
  double? get gte => (_$data['gte'] as double?);
  Input$NestedFloatWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedFloatWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedFloatFilter? get $_avg =>
      (_$data['_avg'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_sum =>
      (_$data['_sum'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_min =>
      (_$data['_min'] as Input$NestedFloatFilter?);
  Input$NestedFloatFilter? get $_max =>
      (_$data['_max'] as Input$NestedFloatFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedFloatWithAggregatesFilter<
          Input$NestedFloatWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedFloatWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedFloatWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_sum = $_sum;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedFloatWithAggregatesFilter(
    Input$NestedFloatWithAggregatesFilter instance,
    TRes Function(Input$NestedFloatWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedFloatWithAggregatesFilter;

  factory CopyWith$Input$NestedFloatWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedFloatWithAggregatesFilter;

  TRes call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  });
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg;
  CopyWith$Input$NestedFloatFilter<TRes> get $_sum;
  CopyWith$Input$NestedFloatFilter<TRes> get $_min;
  CopyWith$Input$NestedFloatFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$NestedFloatWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedFloatWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedFloatWithAggregatesFilter _instance;

  final TRes Function(Input$NestedFloatWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_sum = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$NestedFloatWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as double?),
        if ($in != _undefined) 'in': ($in as List<double>?),
        if (notIn != _undefined) 'notIn': (notIn as List<double>?),
        if (lt != _undefined) 'lt': (lt as double?),
        if (lte != _undefined) 'lte': (lte as double?),
        if (gt != _undefined) 'gt': (gt as double?),
        if (gte != _undefined) 'gte': (gte as double?),
        if (not != _undefined)
          'not': (not as Input$NestedFloatWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_avg != _undefined) '_avg': ($_avg as Input$NestedFloatFilter?),
        if ($_sum != _undefined) '_sum': ($_sum as Input$NestedFloatFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedFloatFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedFloatFilter?),
      }));
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedFloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_sum, (e) => call($_sum: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedFloatFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedFloatFilter.stub(_then(_instance))
        : CopyWith$Input$NestedFloatFilter(local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$NestedFloatWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedFloatWithAggregatesFilter(this._res);

  TRes _res;

  call({
    double? equals,
    List<double>? $in,
    List<double>? notIn,
    double? lt,
    double? lte,
    double? gt,
    double? gte,
    Input$NestedFloatWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedFloatFilter? $_avg,
    Input$NestedFloatFilter? $_sum,
    Input$NestedFloatFilter? $_min,
    Input$NestedFloatFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedFloatWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedFloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_avg =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_sum =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_min =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
  CopyWith$Input$NestedFloatFilter<TRes> get $_max =>
      CopyWith$Input$NestedFloatFilter.stub(_res);
}

class Input$ProductFamilyWhereUniqueInput {
  factory Input$ProductFamilyWhereUniqueInput({int? id}) =>
      Input$ProductFamilyWhereUniqueInput._({
        if (id != null) r'id': id,
      });

  Input$ProductFamilyWhereUniqueInput._(this._$data);

  factory Input$ProductFamilyWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    return Input$ProductFamilyWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyWhereUniqueInput<
          Input$ProductFamilyWhereUniqueInput>
      get copyWith => CopyWith$Input$ProductFamilyWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> {
  factory CopyWith$Input$ProductFamilyWhereUniqueInput(
    Input$ProductFamilyWhereUniqueInput instance,
    TRes Function(Input$ProductFamilyWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyWhereUniqueInput;

  factory CopyWith$Input$ProductFamilyWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyWhereUniqueInput;

  TRes call({int? id});
}

class _CopyWithImpl$Input$ProductFamilyWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyWhereUniqueInput _instance;

  final TRes Function(Input$ProductFamilyWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$ProductFamilyWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyWhereUniqueInput<TRes>
    implements CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyWhereUniqueInput(this._res);

  TRes _res;

  call({int? id}) => _res;
}

class Input$ProductFamilyOrderByWithAggregationInput {
  factory Input$ProductFamilyOrderByWithAggregationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductFamilyCountOrderByAggregateInput? $_count,
    Input$ProductFamilyAvgOrderByAggregateInput? $_avg,
    Input$ProductFamilyMaxOrderByAggregateInput? $_max,
    Input$ProductFamilyMinOrderByAggregateInput? $_min,
    Input$ProductFamilySumOrderByAggregateInput? $_sum,
  }) =>
      Input$ProductFamilyOrderByWithAggregationInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$ProductFamilyOrderByWithAggregationInput._(this._$data);

  factory Input$ProductFamilyOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$ProductFamilyCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$ProductFamilyAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$ProductFamilyMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$ProductFamilyMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$ProductFamilySumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$ProductFamilyOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Input$ProductFamilyCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$ProductFamilyCountOrderByAggregateInput?);
  Input$ProductFamilyAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$ProductFamilyAvgOrderByAggregateInput?);
  Input$ProductFamilyMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$ProductFamilyMaxOrderByAggregateInput?);
  Input$ProductFamilyMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$ProductFamilyMinOrderByAggregateInput?);
  Input$ProductFamilySumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$ProductFamilySumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyOrderByWithAggregationInput<
          Input$ProductFamilyOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$ProductFamilyOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$ProductFamilyOrderByWithAggregationInput(
    Input$ProductFamilyOrderByWithAggregationInput instance,
    TRes Function(Input$ProductFamilyOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyOrderByWithAggregationInput;

  factory CopyWith$Input$ProductFamilyOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductFamilyCountOrderByAggregateInput? $_count,
    Input$ProductFamilyAvgOrderByAggregateInput? $_avg,
    Input$ProductFamilyMaxOrderByAggregateInput? $_max,
    Input$ProductFamilyMinOrderByAggregateInput? $_min,
    Input$ProductFamilySumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$ProductFamilyOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductFamilyOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyOrderByWithAggregationInput _instance;

  final TRes Function(Input$ProductFamilyOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$ProductFamilyOrderByWithAggregationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$ProductFamilyCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$ProductFamilyAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$ProductFamilyMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$ProductFamilyMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$ProductFamilySumOrderByAggregateInput?),
      }));
  CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$ProductFamilyCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$ProductFamilyAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$ProductFamilyMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$ProductFamilyMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$ProductFamilySumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilySumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductFamilyOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
    Input$ProductFamilyCountOrderByAggregateInput? $_count,
    Input$ProductFamilyAvgOrderByAggregateInput? $_avg,
    Input$ProductFamilyMaxOrderByAggregateInput? $_max,
    Input$ProductFamilyMinOrderByAggregateInput? $_min,
    Input$ProductFamilySumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$ProductFamilyCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$ProductFamilyAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$ProductFamilyMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$ProductFamilyMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$ProductFamilySumOrderByAggregateInput.stub(_res);
}

class Input$ProductFamilyCountOrderByAggregateInput {
  factory Input$ProductFamilyCountOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      Input$ProductFamilyCountOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
      });

  Input$ProductFamilyCountOrderByAggregateInput._(this._$data);

  factory Input$ProductFamilyCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    return Input$ProductFamilyCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyCountOrderByAggregateInput<
          Input$ProductFamilyCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductFamilyCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductFamilyCountOrderByAggregateInput(
    Input$ProductFamilyCountOrderByAggregateInput instance,
    TRes Function(Input$ProductFamilyCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyCountOrderByAggregateInput;

  factory CopyWith$Input$ProductFamilyCountOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  });
}

class _CopyWithImpl$Input$ProductFamilyCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyCountOrderByAggregateInput _instance;

  final TRes Function(Input$ProductFamilyCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ProductFamilyCountOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      _res;
}

class Input$ProductFamilyAvgOrderByAggregateInput {
  factory Input$ProductFamilyAvgOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$ProductFamilyAvgOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$ProductFamilyAvgOrderByAggregateInput._(this._$data);

  factory Input$ProductFamilyAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$ProductFamilyAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<
          Input$ProductFamilyAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductFamilyAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductFamilyAvgOrderByAggregateInput(
    Input$ProductFamilyAvgOrderByAggregateInput instance,
    TRes Function(Input$ProductFamilyAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyAvgOrderByAggregateInput;

  factory CopyWith$Input$ProductFamilyAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$ProductFamilyAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyAvgOrderByAggregateInput _instance;

  final TRes Function(Input$ProductFamilyAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$ProductFamilyAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$ProductFamilyMaxOrderByAggregateInput {
  factory Input$ProductFamilyMaxOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      Input$ProductFamilyMaxOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
      });

  Input$ProductFamilyMaxOrderByAggregateInput._(this._$data);

  factory Input$ProductFamilyMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    return Input$ProductFamilyMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<
          Input$ProductFamilyMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductFamilyMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductFamilyMaxOrderByAggregateInput(
    Input$ProductFamilyMaxOrderByAggregateInput instance,
    TRes Function(Input$ProductFamilyMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyMaxOrderByAggregateInput;

  factory CopyWith$Input$ProductFamilyMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  });
}

class _CopyWithImpl$Input$ProductFamilyMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyMaxOrderByAggregateInput _instance;

  final TRes Function(Input$ProductFamilyMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ProductFamilyMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      _res;
}

class Input$ProductFamilyMinOrderByAggregateInput {
  factory Input$ProductFamilyMinOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      Input$ProductFamilyMinOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (name != null) r'name': name,
      });

  Input$ProductFamilyMinOrderByAggregateInput._(this._$data);

  factory Input$ProductFamilyMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    return Input$ProductFamilyMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyMinOrderByAggregateInput<
          Input$ProductFamilyMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductFamilyMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductFamilyMinOrderByAggregateInput(
    Input$ProductFamilyMinOrderByAggregateInput instance,
    TRes Function(Input$ProductFamilyMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyMinOrderByAggregateInput;

  factory CopyWith$Input$ProductFamilyMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  });
}

class _CopyWithImpl$Input$ProductFamilyMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyMinOrderByAggregateInput _instance;

  final TRes Function(Input$ProductFamilyMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ProductFamilyMinOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilyMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? name,
  }) =>
      _res;
}

class Input$ProductFamilySumOrderByAggregateInput {
  factory Input$ProductFamilySumOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$ProductFamilySumOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$ProductFamilySumOrderByAggregateInput._(this._$data);

  factory Input$ProductFamilySumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$ProductFamilySumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilySumOrderByAggregateInput<
          Input$ProductFamilySumOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductFamilySumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilySumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductFamilySumOrderByAggregateInput(
    Input$ProductFamilySumOrderByAggregateInput instance,
    TRes Function(Input$ProductFamilySumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilySumOrderByAggregateInput;

  factory CopyWith$Input$ProductFamilySumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilySumOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$ProductFamilySumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilySumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilySumOrderByAggregateInput _instance;

  final TRes Function(Input$ProductFamilySumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$ProductFamilySumOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilySumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductFamilySumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilySumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$ProductFamilyScalarWhereWithAggregatesInput {
  factory Input$ProductFamilyScalarWhereWithAggregatesInput({
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? name,
  }) =>
      Input$ProductFamilyScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (name != null) r'name': name,
      });

  Input$ProductFamilyScalarWhereWithAggregatesInput._(this._$data);

  factory Input$ProductFamilyScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$ProductFamilyScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$ProductFamilyScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$ProductFamilyScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$name as Map<String, dynamic>));
    }
    return Input$ProductFamilyScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductFamilyScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?);
  List<Input$ProductFamilyScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR']
          as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?);
  List<Input$ProductFamilyScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get id =>
      (_$data['id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get name =>
      (_$data['name'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
          Input$ProductFamilyScalarWhereWithAggregatesInput>
      get copyWith =>
          CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$name = name;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('name') ? l$name : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
    TRes> {
  factory CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput(
    Input$ProductFamilyScalarWhereWithAggregatesInput instance,
    TRes Function(Input$ProductFamilyScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyScalarWhereWithAggregatesInput;

  factory CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? name,
  });
  TRes AND(
      Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                      Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                      Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                      Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name;
}

class _CopyWithImpl$Input$ProductFamilyScalarWhereWithAggregatesInput<TRes>
    implements
        CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$ProductFamilyScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? name = _undefined,
  }) =>
      _then(Input$ProductFamilyScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND':
              (AND as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR':
              (OR as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT':
              (NOT as List<Input$ProductFamilyScalarWhereWithAggregatesInput>?),
        if (id != _undefined) 'id': (id as Input$IntWithAggregatesFilter?),
        if (name != _undefined)
          'name': (name as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                          Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                          Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductFamilyScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<
                          Input$ProductFamilyScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$name, (e) => call(name: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyScalarWhereWithAggregatesInput<TRes>
    implements
        CopyWith$Input$ProductFamilyScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyScalarWhereWithAggregatesInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductFamilyScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? name,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$ProductModelOrderByWithAggregationInput {
  factory Input$ProductModelOrderByWithAggregationInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductModelCountOrderByAggregateInput? $_count,
    Input$ProductModelAvgOrderByAggregateInput? $_avg,
    Input$ProductModelMaxOrderByAggregateInput? $_max,
    Input$ProductModelMinOrderByAggregateInput? $_min,
    Input$ProductModelSumOrderByAggregateInput? $_sum,
  }) =>
      Input$ProductModelOrderByWithAggregationInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$ProductModelOrderByWithAggregationInput._(this._$data);

  factory Input$ProductModelOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$ProductModelCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$ProductModelAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$ProductModelMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$ProductModelMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$ProductModelSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$ProductModelOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Input$ProductModelCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$ProductModelCountOrderByAggregateInput?);
  Input$ProductModelAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$ProductModelAvgOrderByAggregateInput?);
  Input$ProductModelMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$ProductModelMaxOrderByAggregateInput?);
  Input$ProductModelMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$ProductModelMinOrderByAggregateInput?);
  Input$ProductModelSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$ProductModelSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelOrderByWithAggregationInput<
          Input$ProductModelOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$ProductModelOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$ProductModelOrderByWithAggregationInput(
    Input$ProductModelOrderByWithAggregationInput instance,
    TRes Function(Input$ProductModelOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$ProductModelOrderByWithAggregationInput;

  factory CopyWith$Input$ProductModelOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductModelCountOrderByAggregateInput? $_count,
    Input$ProductModelAvgOrderByAggregateInput? $_avg,
    Input$ProductModelMaxOrderByAggregateInput? $_max,
    Input$ProductModelMinOrderByAggregateInput? $_min,
    Input$ProductModelSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$ProductModelOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductModelOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$ProductModelOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelOrderByWithAggregationInput _instance;

  final TRes Function(Input$ProductModelOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$ProductModelOrderByWithAggregationInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$ProductModelCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$ProductModelAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$ProductModelMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$ProductModelMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$ProductModelSumOrderByAggregateInput?),
      }));
  CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$ProductModelCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$ProductModelAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$ProductModelMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$ProductModelMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$ProductModelSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductModelOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
    Input$ProductModelCountOrderByAggregateInput? $_count,
    Input$ProductModelAvgOrderByAggregateInput? $_avg,
    Input$ProductModelMaxOrderByAggregateInput? $_max,
    Input$ProductModelMinOrderByAggregateInput? $_min,
    Input$ProductModelSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$ProductModelCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$ProductModelAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$ProductModelMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$ProductModelMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$ProductModelSumOrderByAggregateInput.stub(_res);
}

class Input$ProductModelCountOrderByAggregateInput {
  factory Input$ProductModelCountOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      Input$ProductModelCountOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelCountOrderByAggregateInput._(this._$data);

  factory Input$ProductModelCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    return Input$ProductModelCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelCountOrderByAggregateInput<
          Input$ProductModelCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductModelCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelCountOrderByAggregateInput(
    Input$ProductModelCountOrderByAggregateInput instance,
    TRes Function(Input$ProductModelCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelCountOrderByAggregateInput;

  factory CopyWith$Input$ProductModelCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  });
}

class _CopyWithImpl$Input$ProductModelCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCountOrderByAggregateInput _instance;

  final TRes Function(Input$ProductModelCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelCountOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      _res;
}

class Input$ProductModelAvgOrderByAggregateInput {
  factory Input$ProductModelAvgOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      Input$ProductModelAvgOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelAvgOrderByAggregateInput._(this._$data);

  factory Input$ProductModelAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    return Input$ProductModelAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelAvgOrderByAggregateInput<
          Input$ProductModelAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductModelAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelAvgOrderByAggregateInput(
    Input$ProductModelAvgOrderByAggregateInput instance,
    TRes Function(Input$ProductModelAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelAvgOrderByAggregateInput;

  factory CopyWith$Input$ProductModelAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  });
}

class _CopyWithImpl$Input$ProductModelAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelAvgOrderByAggregateInput _instance;

  final TRes Function(Input$ProductModelAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      _res;
}

class Input$ProductModelMaxOrderByAggregateInput {
  factory Input$ProductModelMaxOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      Input$ProductModelMaxOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelMaxOrderByAggregateInput._(this._$data);

  factory Input$ProductModelMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    return Input$ProductModelMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelMaxOrderByAggregateInput<
          Input$ProductModelMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductModelMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelMaxOrderByAggregateInput(
    Input$ProductModelMaxOrderByAggregateInput instance,
    TRes Function(Input$ProductModelMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelMaxOrderByAggregateInput;

  factory CopyWith$Input$ProductModelMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  });
}

class _CopyWithImpl$Input$ProductModelMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelMaxOrderByAggregateInput _instance;

  final TRes Function(Input$ProductModelMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      _res;
}

class Input$ProductModelMinOrderByAggregateInput {
  factory Input$ProductModelMinOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      Input$ProductModelMinOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelMinOrderByAggregateInput._(this._$data);

  factory Input$ProductModelMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    return Input$ProductModelMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelMinOrderByAggregateInput<
          Input$ProductModelMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductModelMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelMinOrderByAggregateInput(
    Input$ProductModelMinOrderByAggregateInput instance,
    TRes Function(Input$ProductModelMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelMinOrderByAggregateInput;

  factory CopyWith$Input$ProductModelMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  });
}

class _CopyWithImpl$Input$ProductModelMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelMinOrderByAggregateInput _instance;

  final TRes Function(Input$ProductModelMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelMinOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      _res;
}

class Input$ProductModelSumOrderByAggregateInput {
  factory Input$ProductModelSumOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      Input$ProductModelSumOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelSumOrderByAggregateInput._(this._$data);

  factory Input$ProductModelSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : fromJson$Enum$SortOrder((l$color_id as String));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : fromJson$Enum$SortOrder((l$size_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    return Input$ProductModelSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get color_id => (_$data['color_id'] as Enum$SortOrder?);
  Enum$SortOrder? get size_id => (_$data['size_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] =
          l$color_id == null ? null : toJson$Enum$SortOrder(l$color_id);
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] =
          l$size_id == null ? null : toJson$Enum$SortOrder(l$size_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    return result$data;
  }

  CopyWith$Input$ProductModelSumOrderByAggregateInput<
          Input$ProductModelSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductModelSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductModelSumOrderByAggregateInput(
    Input$ProductModelSumOrderByAggregateInput instance,
    TRes Function(Input$ProductModelSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductModelSumOrderByAggregateInput;

  factory CopyWith$Input$ProductModelSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  });
}

class _CopyWithImpl$Input$ProductModelSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductModelSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelSumOrderByAggregateInput _instance;

  final TRes Function(Input$ProductModelSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelSumOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (color_id != _undefined) 'color_id': (color_id as Enum$SortOrder?),
        if (size_id != _undefined) 'size_id': (size_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductModelSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductModelSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? color_id,
    Enum$SortOrder? size_id,
    Enum$SortOrder? quantity,
  }) =>
      _res;
}

class Input$ProductModelScalarWhereWithAggregatesInput {
  factory Input$ProductModelScalarWhereWithAggregatesInput({
    List<Input$ProductModelScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? color_id,
    Input$IntWithAggregatesFilter? size_id,
    Input$IntWithAggregatesFilter? quantity,
  }) =>
      Input$ProductModelScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelScalarWhereWithAggregatesInput._(this._$data);

  factory Input$ProductModelScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$color_id as Map<String, dynamic>));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$size_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    return Input$ProductModelScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$ProductModelScalarWhereWithAggregatesInput>?);
  List<Input$ProductModelScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$ProductModelScalarWhereWithAggregatesInput>?);
  List<Input$ProductModelScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$ProductModelScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get product_id =>
      (_$data['product_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get color_id =>
      (_$data['color_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get size_id =>
      (_$data['size_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get quantity =>
      (_$data['quantity'] as Input$IntWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] = l$color_id?.toJson();
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] = l$size_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
          Input$ProductModelScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$ProductModelScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$ProductModelScalarWhereWithAggregatesInput(
    Input$ProductModelScalarWhereWithAggregatesInput instance,
    TRes Function(Input$ProductModelScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$ProductModelScalarWhereWithAggregatesInput;

  factory CopyWith$Input$ProductModelScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$ProductModelScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? color_id,
    Input$IntWithAggregatesFilter? size_id,
    Input$IntWithAggregatesFilter? quantity,
  });
  TRes AND(
      Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                      Input$ProductModelScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                      Input$ProductModelScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                      Input$ProductModelScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get color_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get size_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity;
}

class _CopyWithImpl$Input$ProductModelScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$ProductModelScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$ProductModelScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND':
              (AND as List<Input$ProductModelScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductModelScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT':
              (NOT as List<Input$ProductModelScalarWhereWithAggregatesInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntWithAggregatesFilter?),
        if (color_id != _undefined)
          'color_id': (color_id as Input$IntWithAggregatesFilter?),
        if (size_id != _undefined)
          'size_id': (size_id as Input$IntWithAggregatesFilter?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                          Input$ProductModelScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$ProductModelScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                          Input$ProductModelScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$ProductModelScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductModelScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<
                          Input$ProductModelScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$ProductModelScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get color_id {
    final local$color_id = _instance.color_id;
    return local$color_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$color_id, (e) => call(color_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get size_id {
    final local$size_id = _instance.size_id;
    return local$size_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$size_id, (e) => call(size_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$quantity, (e) => call(quantity: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ProductModelScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$ProductModelScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductModelScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? color_id,
    Input$IntWithAggregatesFilter? size_id,
    Input$IntWithAggregatesFilter? quantity,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get color_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get size_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
}

class Input$ProductsOrderByWithAggregationInput {
  factory Input$ProductsOrderByWithAggregationInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductsCountOrderByAggregateInput? $_count,
    Input$ProductsAvgOrderByAggregateInput? $_avg,
    Input$ProductsMaxOrderByAggregateInput? $_max,
    Input$ProductsMinOrderByAggregateInput? $_min,
    Input$ProductsSumOrderByAggregateInput? $_sum,
  }) =>
      Input$ProductsOrderByWithAggregationInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$ProductsOrderByWithAggregationInput._(this._$data);

  factory Input$ProductsOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$ProductsCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$ProductsAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$ProductsMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$ProductsMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$ProductsSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$ProductsOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Input$ProductsCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$ProductsCountOrderByAggregateInput?);
  Input$ProductsAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$ProductsAvgOrderByAggregateInput?);
  Input$ProductsMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$ProductsMaxOrderByAggregateInput?);
  Input$ProductsMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$ProductsMinOrderByAggregateInput?);
  Input$ProductsSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$ProductsSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsOrderByWithAggregationInput<
          Input$ProductsOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$ProductsOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$ProductsOrderByWithAggregationInput(
    Input$ProductsOrderByWithAggregationInput instance,
    TRes Function(Input$ProductsOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$ProductsOrderByWithAggregationInput;

  factory CopyWith$Input$ProductsOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductsCountOrderByAggregateInput? $_count,
    Input$ProductsAvgOrderByAggregateInput? $_avg,
    Input$ProductsMaxOrderByAggregateInput? $_max,
    Input$ProductsMinOrderByAggregateInput? $_min,
    Input$ProductsSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$ProductsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductsOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$ProductsOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$ProductsOrderByWithAggregationInput _instance;

  final TRes Function(Input$ProductsOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$ProductsOrderByWithAggregationInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$ProductsCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$ProductsAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$ProductsMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$ProductsMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$ProductsSumOrderByAggregateInput?),
      }));
  CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$ProductsCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$ProductsAvgOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ProductsAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$ProductsMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ProductsMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$ProductsMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ProductsMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$ProductsSumOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$ProductsSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$ProductsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$ProductsOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$ProductsOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
    Input$ProductsCountOrderByAggregateInput? $_count,
    Input$ProductsAvgOrderByAggregateInput? $_avg,
    Input$ProductsMaxOrderByAggregateInput? $_max,
    Input$ProductsMinOrderByAggregateInput? $_min,
    Input$ProductsSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$ProductsCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$ProductsAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$ProductsMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$ProductsMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$ProductsSumOrderByAggregateInput.stub(_res);
}

class Input$ProductsCountOrderByAggregateInput {
  factory Input$ProductsCountOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      Input$ProductsCountOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsCountOrderByAggregateInput._(this._$data);

  factory Input$ProductsCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    return Input$ProductsCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    return result$data;
  }

  CopyWith$Input$ProductsCountOrderByAggregateInput<
          Input$ProductsCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductsCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductsCountOrderByAggregateInput(
    Input$ProductsCountOrderByAggregateInput instance,
    TRes Function(Input$ProductsCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsCountOrderByAggregateInput;

  factory CopyWith$Input$ProductsCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  });
}

class _CopyWithImpl$Input$ProductsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCountOrderByAggregateInput _instance;

  final TRes Function(Input$ProductsCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsCountOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      _res;
}

class Input$ProductsAvgOrderByAggregateInput {
  factory Input$ProductsAvgOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  }) =>
      Input$ProductsAvgOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsAvgOrderByAggregateInput._(this._$data);

  factory Input$ProductsAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    return Input$ProductsAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    return result$data;
  }

  CopyWith$Input$ProductsAvgOrderByAggregateInput<
          Input$ProductsAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductsAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductsAvgOrderByAggregateInput(
    Input$ProductsAvgOrderByAggregateInput instance,
    TRes Function(Input$ProductsAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsAvgOrderByAggregateInput;

  factory CopyWith$Input$ProductsAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  });
}

class _CopyWithImpl$Input$ProductsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsAvgOrderByAggregateInput _instance;

  final TRes Function(Input$ProductsAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  }) =>
      _res;
}

class Input$ProductsMaxOrderByAggregateInput {
  factory Input$ProductsMaxOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      Input$ProductsMaxOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsMaxOrderByAggregateInput._(this._$data);

  factory Input$ProductsMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    return Input$ProductsMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    return result$data;
  }

  CopyWith$Input$ProductsMaxOrderByAggregateInput<
          Input$ProductsMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductsMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductsMaxOrderByAggregateInput(
    Input$ProductsMaxOrderByAggregateInput instance,
    TRes Function(Input$ProductsMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsMaxOrderByAggregateInput;

  factory CopyWith$Input$ProductsMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  });
}

class _CopyWithImpl$Input$ProductsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsMaxOrderByAggregateInput _instance;

  final TRes Function(Input$ProductsMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      _res;
}

class Input$ProductsMinOrderByAggregateInput {
  factory Input$ProductsMinOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      Input$ProductsMinOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsMinOrderByAggregateInput._(this._$data);

  factory Input$ProductsMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    return Input$ProductsMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    return result$data;
  }

  CopyWith$Input$ProductsMinOrderByAggregateInput<
          Input$ProductsMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductsMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductsMinOrderByAggregateInput(
    Input$ProductsMinOrderByAggregateInput instance,
    TRes Function(Input$ProductsMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsMinOrderByAggregateInput;

  factory CopyWith$Input$ProductsMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  });
}

class _CopyWithImpl$Input$ProductsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsMinOrderByAggregateInput _instance;

  final TRes Function(Input$ProductsMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsMinOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? name,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? description,
    Enum$SortOrder? picture,
    Enum$SortOrder? family_id,
  }) =>
      _res;
}

class Input$ProductsSumOrderByAggregateInput {
  factory Input$ProductsSumOrderByAggregateInput({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  }) =>
      Input$ProductsSumOrderByAggregateInput._({
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsSumOrderByAggregateInput._(this._$data);

  factory Input$ProductsSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : fromJson$Enum$SortOrder((l$reference as String));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$buyingPrice as String));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : fromJson$Enum$SortOrder((l$sellingPrice as String));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : fromJson$Enum$SortOrder((l$family_id as String));
    }
    return Input$ProductsSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get reference => (_$data['reference'] as Enum$SortOrder?);
  Enum$SortOrder? get buyingPrice => (_$data['buyingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get sellingPrice =>
      (_$data['sellingPrice'] as Enum$SortOrder?);
  Enum$SortOrder? get family_id => (_$data['family_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] =
          l$reference == null ? null : toJson$Enum$SortOrder(l$reference);
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] =
          l$buyingPrice == null ? null : toJson$Enum$SortOrder(l$buyingPrice);
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] =
          l$sellingPrice == null ? null : toJson$Enum$SortOrder(l$sellingPrice);
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] =
          l$family_id == null ? null : toJson$Enum$SortOrder(l$family_id);
    }
    return result$data;
  }

  CopyWith$Input$ProductsSumOrderByAggregateInput<
          Input$ProductsSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$ProductsSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$product_id = product_id;
    final l$reference = reference;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$ProductsSumOrderByAggregateInput(
    Input$ProductsSumOrderByAggregateInput instance,
    TRes Function(Input$ProductsSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$ProductsSumOrderByAggregateInput;

  factory CopyWith$Input$ProductsSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  });
}

class _CopyWithImpl$Input$ProductsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$ProductsSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsSumOrderByAggregateInput _instance;

  final TRes Function(Input$ProductsSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsSumOrderByAggregateInput._({
        ..._instance._$data,
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (reference != _undefined)
          'reference': (reference as Enum$SortOrder?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Enum$SortOrder?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Enum$SortOrder?),
        if (family_id != _undefined)
          'family_id': (family_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$ProductsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$ProductsSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? product_id,
    Enum$SortOrder? reference,
    Enum$SortOrder? buyingPrice,
    Enum$SortOrder? sellingPrice,
    Enum$SortOrder? family_id,
  }) =>
      _res;
}

class Input$ProductsScalarWhereWithAggregatesInput {
  factory Input$ProductsScalarWhereWithAggregatesInput({
    List<Input$ProductsScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductsScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? reference,
    Input$StringWithAggregatesFilter? name,
    Input$FloatWithAggregatesFilter? buyingPrice,
    Input$FloatWithAggregatesFilter? sellingPrice,
    Input$StringWithAggregatesFilter? description,
    Input$StringWithAggregatesFilter? picture,
    Input$IntWithAggregatesFilter? family_id,
  }) =>
      Input$ProductsScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsScalarWhereWithAggregatesInput._(this._$data);

  factory Input$ProductsScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$family_id as Map<String, dynamic>));
    }
    return Input$ProductsScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductsScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$ProductsScalarWhereWithAggregatesInput>?);
  List<Input$ProductsScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$ProductsScalarWhereWithAggregatesInput>?);
  List<Input$ProductsScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductsScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get product_id =>
      (_$data['product_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get reference =>
      (_$data['reference'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get name =>
      (_$data['name'] as Input$StringWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get description =>
      (_$data['description'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get picture =>
      (_$data['picture'] as Input$StringWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get family_id =>
      (_$data['family_id'] as Input$IntWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] = l$family_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
          Input$ProductsScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$ProductsScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$ProductsScalarWhereWithAggregatesInput(
    Input$ProductsScalarWhereWithAggregatesInput instance,
    TRes Function(Input$ProductsScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$ProductsScalarWhereWithAggregatesInput;

  factory CopyWith$Input$ProductsScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$ProductsScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductsScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? reference,
    Input$StringWithAggregatesFilter? name,
    Input$FloatWithAggregatesFilter? buyingPrice,
    Input$FloatWithAggregatesFilter? sellingPrice,
    Input$StringWithAggregatesFilter? description,
    Input$StringWithAggregatesFilter? picture,
    Input$IntWithAggregatesFilter? family_id,
  });
  TRes AND(
      Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                      Input$ProductsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                      Input$ProductsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                      Input$ProductsScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get reference;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get buyingPrice;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get sellingPrice;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get family_id;
}

class _CopyWithImpl$Input$ProductsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ProductsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$ProductsScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$ProductsScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$ProductsScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductsScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductsScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ProductsScalarWhereWithAggregatesInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntWithAggregatesFilter?),
        if (reference != _undefined)
          'reference': (reference as Input$IntWithAggregatesFilter?),
        if (name != _undefined)
          'name': (name as Input$StringWithAggregatesFilter?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Input$FloatWithAggregatesFilter?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Input$FloatWithAggregatesFilter?),
        if (description != _undefined)
          'description': (description as Input$StringWithAggregatesFilter?),
        if (picture != _undefined)
          'picture': (picture as Input$StringWithAggregatesFilter?),
        if (family_id != _undefined)
          'family_id': (family_id as Input$IntWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                          Input$ProductsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$ProductsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                          Input$ProductsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$ProductsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereWithAggregatesInput<
                          Input$ProductsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$ProductsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get family_id {
    final local$family_id = _instance.family_id;
    return local$family_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$family_id, (e) => call(family_id: e));
  }
}

class _CopyWithStubImpl$Input$ProductsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$ProductsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$ProductsScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$ProductsScalarWhereWithAggregatesInput>? AND,
    List<Input$ProductsScalarWhereWithAggregatesInput>? OR,
    List<Input$ProductsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? reference,
    Input$StringWithAggregatesFilter? name,
    Input$FloatWithAggregatesFilter? buyingPrice,
    Input$FloatWithAggregatesFilter? sellingPrice,
    Input$StringWithAggregatesFilter? description,
    Input$StringWithAggregatesFilter? picture,
    Input$IntWithAggregatesFilter? family_id,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get reference =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get buyingPrice =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get sellingPrice =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get family_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
}

class Input$SellersWhereUniqueInput {
  factory Input$SellersWhereUniqueInput({int? seller_id}) =>
      Input$SellersWhereUniqueInput._({
        if (seller_id != null) r'seller_id': seller_id,
      });

  Input$SellersWhereUniqueInput._(this._$data);

  factory Input$SellersWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = (l$seller_id as int?);
    }
    return Input$SellersWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get seller_id => (_$data['seller_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id;
    }
    return result$data;
  }

  CopyWith$Input$SellersWhereUniqueInput<Input$SellersWhereUniqueInput>
      get copyWith => CopyWith$Input$SellersWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    return Object.hashAll(
        [_$data.containsKey('seller_id') ? l$seller_id : const {}]);
  }
}

abstract class CopyWith$Input$SellersWhereUniqueInput<TRes> {
  factory CopyWith$Input$SellersWhereUniqueInput(
    Input$SellersWhereUniqueInput instance,
    TRes Function(Input$SellersWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$SellersWhereUniqueInput;

  factory CopyWith$Input$SellersWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersWhereUniqueInput;

  TRes call({int? seller_id});
}

class _CopyWithImpl$Input$SellersWhereUniqueInput<TRes>
    implements CopyWith$Input$SellersWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$SellersWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$SellersWhereUniqueInput _instance;

  final TRes Function(Input$SellersWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? seller_id = _undefined}) =>
      _then(Input$SellersWhereUniqueInput._({
        ..._instance._$data,
        if (seller_id != _undefined) 'seller_id': (seller_id as int?),
      }));
}

class _CopyWithStubImpl$Input$SellersWhereUniqueInput<TRes>
    implements CopyWith$Input$SellersWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$SellersWhereUniqueInput(this._res);

  TRes _res;

  call({int? seller_id}) => _res;
}

class Input$SellersOrderByWithAggregationInput {
  factory Input$SellersOrderByWithAggregationInput({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$SellersCountOrderByAggregateInput? $_count,
    Input$SellersAvgOrderByAggregateInput? $_avg,
    Input$SellersMaxOrderByAggregateInput? $_max,
    Input$SellersMinOrderByAggregateInput? $_min,
    Input$SellersSumOrderByAggregateInput? $_sum,
  }) =>
      Input$SellersOrderByWithAggregationInput._({
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$SellersOrderByWithAggregationInput._(this._$data);

  factory Input$SellersOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_name as String));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_phone as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$SellersCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$SellersAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$SellersMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$SellersMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$SellersSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$SellersOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_name => (_$data['seller_name'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_phone =>
      (_$data['seller_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Input$SellersCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$SellersCountOrderByAggregateInput?);
  Input$SellersAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$SellersAvgOrderByAggregateInput?);
  Input$SellersMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$SellersMaxOrderByAggregateInput?);
  Input$SellersMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$SellersMinOrderByAggregateInput?);
  Input$SellersSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$SellersSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] =
          l$seller_name == null ? null : toJson$Enum$SortOrder(l$seller_name);
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] =
          l$seller_phone == null ? null : toJson$Enum$SortOrder(l$seller_phone);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersOrderByWithAggregationInput<
          Input$SellersOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$SellersOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$SellersOrderByWithAggregationInput(
    Input$SellersOrderByWithAggregationInput instance,
    TRes Function(Input$SellersOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$SellersOrderByWithAggregationInput;

  factory CopyWith$Input$SellersOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$SellersCountOrderByAggregateInput? $_count,
    Input$SellersAvgOrderByAggregateInput? $_avg,
    Input$SellersMaxOrderByAggregateInput? $_max,
    Input$SellersMinOrderByAggregateInput? $_min,
    Input$SellersSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$SellersCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$SellersMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$SellersSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$SellersOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$SellersOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$SellersOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$SellersOrderByWithAggregationInput _instance;

  final TRes Function(Input$SellersOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$SellersOrderByWithAggregationInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Enum$SortOrder?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$SellersCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$SellersAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$SellersMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$SellersMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$SellersSumOrderByAggregateInput?),
      }));
  CopyWith$Input$SellersCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$SellersCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$SellersAvgOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SellersAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$SellersMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SellersMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$SellersMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$SellersMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SellersMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$SellersSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$SellersSumOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SellersSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$SellersOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$SellersOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$SellersOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
    Input$SellersCountOrderByAggregateInput? $_count,
    Input$SellersAvgOrderByAggregateInput? $_avg,
    Input$SellersMaxOrderByAggregateInput? $_max,
    Input$SellersMinOrderByAggregateInput? $_min,
    Input$SellersSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$SellersCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$SellersCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$SellersAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$SellersMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$SellersMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$SellersMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$SellersSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$SellersSumOrderByAggregateInput.stub(_res);
}

class Input$SellersCountOrderByAggregateInput {
  factory Input$SellersCountOrderByAggregateInput({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      Input$SellersCountOrderByAggregateInput._({
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersCountOrderByAggregateInput._(this._$data);

  factory Input$SellersCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_name as String));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_phone as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    return Input$SellersCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_name => (_$data['seller_name'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_phone =>
      (_$data['seller_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] =
          l$seller_name == null ? null : toJson$Enum$SortOrder(l$seller_name);
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] =
          l$seller_phone == null ? null : toJson$Enum$SortOrder(l$seller_phone);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    return result$data;
  }

  CopyWith$Input$SellersCountOrderByAggregateInput<
          Input$SellersCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$SellersCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SellersCountOrderByAggregateInput(
    Input$SellersCountOrderByAggregateInput instance,
    TRes Function(Input$SellersCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SellersCountOrderByAggregateInput;

  factory CopyWith$Input$SellersCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  });
}

class _CopyWithImpl$Input$SellersCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SellersCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SellersCountOrderByAggregateInput _instance;

  final TRes Function(Input$SellersCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersCountOrderByAggregateInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Enum$SortOrder?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SellersCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SellersCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      _res;
}

class Input$SellersAvgOrderByAggregateInput {
  factory Input$SellersAvgOrderByAggregateInput({Enum$SortOrder? seller_id}) =>
      Input$SellersAvgOrderByAggregateInput._({
        if (seller_id != null) r'seller_id': seller_id,
      });

  Input$SellersAvgOrderByAggregateInput._(this._$data);

  factory Input$SellersAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    return Input$SellersAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    return result$data;
  }

  CopyWith$Input$SellersAvgOrderByAggregateInput<
          Input$SellersAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$SellersAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    return Object.hashAll(
        [_$data.containsKey('seller_id') ? l$seller_id : const {}]);
  }
}

abstract class CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SellersAvgOrderByAggregateInput(
    Input$SellersAvgOrderByAggregateInput instance,
    TRes Function(Input$SellersAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SellersAvgOrderByAggregateInput;

  factory CopyWith$Input$SellersAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? seller_id});
}

class _CopyWithImpl$Input$SellersAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SellersAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SellersAvgOrderByAggregateInput _instance;

  final TRes Function(Input$SellersAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? seller_id = _undefined}) =>
      _then(Input$SellersAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SellersAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SellersAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? seller_id}) => _res;
}

class Input$SellersMaxOrderByAggregateInput {
  factory Input$SellersMaxOrderByAggregateInput({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      Input$SellersMaxOrderByAggregateInput._({
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersMaxOrderByAggregateInput._(this._$data);

  factory Input$SellersMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_name as String));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_phone as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    return Input$SellersMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_name => (_$data['seller_name'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_phone =>
      (_$data['seller_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] =
          l$seller_name == null ? null : toJson$Enum$SortOrder(l$seller_name);
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] =
          l$seller_phone == null ? null : toJson$Enum$SortOrder(l$seller_phone);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    return result$data;
  }

  CopyWith$Input$SellersMaxOrderByAggregateInput<
          Input$SellersMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$SellersMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SellersMaxOrderByAggregateInput(
    Input$SellersMaxOrderByAggregateInput instance,
    TRes Function(Input$SellersMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SellersMaxOrderByAggregateInput;

  factory CopyWith$Input$SellersMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  });
}

class _CopyWithImpl$Input$SellersMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SellersMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SellersMaxOrderByAggregateInput _instance;

  final TRes Function(Input$SellersMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Enum$SortOrder?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SellersMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SellersMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      _res;
}

class Input$SellersMinOrderByAggregateInput {
  factory Input$SellersMinOrderByAggregateInput({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      Input$SellersMinOrderByAggregateInput._({
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersMinOrderByAggregateInput._(this._$data);

  factory Input$SellersMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_name as String));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_phone as String));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : fromJson$Enum$SortOrder((l$picture as String));
    }
    return Input$SellersMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_name => (_$data['seller_name'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_phone =>
      (_$data['seller_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get picture => (_$data['picture'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] =
          l$seller_name == null ? null : toJson$Enum$SortOrder(l$seller_name);
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] =
          l$seller_phone == null ? null : toJson$Enum$SortOrder(l$seller_phone);
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] =
          l$picture == null ? null : toJson$Enum$SortOrder(l$picture);
    }
    return result$data;
  }

  CopyWith$Input$SellersMinOrderByAggregateInput<
          Input$SellersMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$SellersMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SellersMinOrderByAggregateInput(
    Input$SellersMinOrderByAggregateInput instance,
    TRes Function(Input$SellersMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SellersMinOrderByAggregateInput;

  factory CopyWith$Input$SellersMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  });
}

class _CopyWithImpl$Input$SellersMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SellersMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SellersMinOrderByAggregateInput _instance;

  final TRes Function(Input$SellersMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersMinOrderByAggregateInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Enum$SortOrder?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Enum$SortOrder?),
        if (picture != _undefined) 'picture': (picture as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SellersMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SellersMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? seller_id,
    Enum$SortOrder? seller_name,
    Enum$SortOrder? seller_phone,
    Enum$SortOrder? picture,
  }) =>
      _res;
}

class Input$SellersSumOrderByAggregateInput {
  factory Input$SellersSumOrderByAggregateInput({Enum$SortOrder? seller_id}) =>
      Input$SellersSumOrderByAggregateInput._({
        if (seller_id != null) r'seller_id': seller_id,
      });

  Input$SellersSumOrderByAggregateInput._(this._$data);

  factory Input$SellersSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    return Input$SellersSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    return result$data;
  }

  CopyWith$Input$SellersSumOrderByAggregateInput<
          Input$SellersSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$SellersSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_id = seller_id;
    return Object.hashAll(
        [_$data.containsKey('seller_id') ? l$seller_id : const {}]);
  }
}

abstract class CopyWith$Input$SellersSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SellersSumOrderByAggregateInput(
    Input$SellersSumOrderByAggregateInput instance,
    TRes Function(Input$SellersSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SellersSumOrderByAggregateInput;

  factory CopyWith$Input$SellersSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersSumOrderByAggregateInput;

  TRes call({Enum$SortOrder? seller_id});
}

class _CopyWithImpl$Input$SellersSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SellersSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SellersSumOrderByAggregateInput _instance;

  final TRes Function(Input$SellersSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? seller_id = _undefined}) =>
      _then(Input$SellersSumOrderByAggregateInput._({
        ..._instance._$data,
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SellersSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$SellersSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SellersSumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? seller_id}) => _res;
}

class Input$SellersScalarWhereWithAggregatesInput {
  factory Input$SellersScalarWhereWithAggregatesInput({
    List<Input$SellersScalarWhereWithAggregatesInput>? AND,
    List<Input$SellersScalarWhereWithAggregatesInput>? OR,
    List<Input$SellersScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? seller_id,
    Input$StringWithAggregatesFilter? seller_name,
    Input$StringWithAggregatesFilter? seller_phone,
    Input$StringWithAggregatesFilter? picture,
  }) =>
      Input$SellersScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (seller_id != null) r'seller_id': seller_id,
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersScalarWhereWithAggregatesInput._(this._$data);

  factory Input$SellersScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$SellersScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$SellersScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$SellersScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$seller_id as Map<String, dynamic>));
    }
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$seller_name as Map<String, dynamic>));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$seller_phone as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    return Input$SellersScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SellersScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$SellersScalarWhereWithAggregatesInput>?);
  List<Input$SellersScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$SellersScalarWhereWithAggregatesInput>?);
  List<Input$SellersScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$SellersScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get seller_id =>
      (_$data['seller_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get seller_name =>
      (_$data['seller_name'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get seller_phone =>
      (_$data['seller_phone'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get picture =>
      (_$data['picture'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id?.toJson();
    }
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] = l$seller_name?.toJson();
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] = l$seller_phone?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersScalarWhereWithAggregatesInput<
          Input$SellersScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$SellersScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$seller_id = seller_id;
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$SellersScalarWhereWithAggregatesInput(
    Input$SellersScalarWhereWithAggregatesInput instance,
    TRes Function(Input$SellersScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$SellersScalarWhereWithAggregatesInput;

  factory CopyWith$Input$SellersScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$SellersScalarWhereWithAggregatesInput>? AND,
    List<Input$SellersScalarWhereWithAggregatesInput>? OR,
    List<Input$SellersScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? seller_id,
    Input$StringWithAggregatesFilter? seller_name,
    Input$StringWithAggregatesFilter? seller_phone,
    Input$StringWithAggregatesFilter? picture,
  });
  TRes AND(
      Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                      Input$SellersScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                      Input$SellersScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                      Input$SellersScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_name;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_phone;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture;
}

class _CopyWithImpl$Input$SellersScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$SellersScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$SellersScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$SellersScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$SellersScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? seller_id = _undefined,
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$SellersScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$SellersScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$SellersScalarWhereWithAggregatesInput>?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Input$IntWithAggregatesFilter?),
        if (seller_name != _undefined)
          'seller_name': (seller_name as Input$StringWithAggregatesFilter?),
        if (seller_phone != _undefined)
          'seller_phone': (seller_phone as Input$StringWithAggregatesFilter?),
        if (picture != _undefined)
          'picture': (picture as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                          Input$SellersScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$SellersScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                          Input$SellersScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$SellersScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$SellersScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SellersScalarWhereWithAggregatesInput<
                          Input$SellersScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$SellersScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id {
    final local$seller_id = _instance.seller_id;
    return local$seller_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$seller_id, (e) => call(seller_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_name {
    final local$seller_name = _instance.seller_name;
    return local$seller_name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$seller_name, (e) => call(seller_name: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_phone {
    final local$seller_phone = _instance.seller_phone;
    return local$seller_phone == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$seller_phone, (e) => call(seller_phone: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$picture, (e) => call(picture: e));
  }
}

class _CopyWithStubImpl$Input$SellersScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$SellersScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$SellersScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$SellersScalarWhereWithAggregatesInput>? AND,
    List<Input$SellersScalarWhereWithAggregatesInput>? OR,
    List<Input$SellersScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? seller_id,
    Input$StringWithAggregatesFilter? seller_name,
    Input$StringWithAggregatesFilter? seller_phone,
    Input$StringWithAggregatesFilter? picture,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get seller_phone =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get picture =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$SizesWhereUniqueInput {
  factory Input$SizesWhereUniqueInput({int? id}) =>
      Input$SizesWhereUniqueInput._({
        if (id != null) r'id': id,
      });

  Input$SizesWhereUniqueInput._(this._$data);

  factory Input$SizesWhereUniqueInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = (l$id as int?);
    }
    return Input$SizesWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get id => (_$data['id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id;
    }
    return result$data;
  }

  CopyWith$Input$SizesWhereUniqueInput<Input$SizesWhereUniqueInput>
      get copyWith => CopyWith$Input$SizesWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$SizesWhereUniqueInput<TRes> {
  factory CopyWith$Input$SizesWhereUniqueInput(
    Input$SizesWhereUniqueInput instance,
    TRes Function(Input$SizesWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$SizesWhereUniqueInput;

  factory CopyWith$Input$SizesWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesWhereUniqueInput;

  TRes call({int? id});
}

class _CopyWithImpl$Input$SizesWhereUniqueInput<TRes>
    implements CopyWith$Input$SizesWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$SizesWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$SizesWhereUniqueInput _instance;

  final TRes Function(Input$SizesWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) => _then(Input$SizesWhereUniqueInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as int?),
      }));
}

class _CopyWithStubImpl$Input$SizesWhereUniqueInput<TRes>
    implements CopyWith$Input$SizesWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$SizesWhereUniqueInput(this._res);

  TRes _res;

  call({int? id}) => _res;
}

class Input$SizesOrderByWithAggregationInput {
  factory Input$SizesOrderByWithAggregationInput({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$SizesCountOrderByAggregateInput? $_count,
    Input$SizesAvgOrderByAggregateInput? $_avg,
    Input$SizesMaxOrderByAggregateInput? $_max,
    Input$SizesMinOrderByAggregateInput? $_min,
    Input$SizesSumOrderByAggregateInput? $_sum,
  }) =>
      Input$SizesOrderByWithAggregationInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$SizesOrderByWithAggregationInput._(this._$data);

  factory Input$SizesOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$Enum$SortOrder((l$size as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$SizesCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$SizesAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$SizesMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$SizesMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$SizesSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$SizesOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get size => (_$data['size'] as Enum$SortOrder?);
  Input$SizesCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$SizesCountOrderByAggregateInput?);
  Input$SizesAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$SizesAvgOrderByAggregateInput?);
  Input$SizesMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$SizesMaxOrderByAggregateInput?);
  Input$SizesMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$SizesMinOrderByAggregateInput?);
  Input$SizesSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$SizesSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] =
          l$size == null ? null : toJson$Enum$SortOrder(l$size);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesOrderByWithAggregationInput<
          Input$SizesOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$SizesOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$SizesOrderByWithAggregationInput(
    Input$SizesOrderByWithAggregationInput instance,
    TRes Function(Input$SizesOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$SizesOrderByWithAggregationInput;

  factory CopyWith$Input$SizesOrderByWithAggregationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$SizesCountOrderByAggregateInput? $_count,
    Input$SizesAvgOrderByAggregateInput? $_avg,
    Input$SizesMaxOrderByAggregateInput? $_max,
    Input$SizesMinOrderByAggregateInput? $_min,
    Input$SizesSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$SizesCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$SizesMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$SizesSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$SizesOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$SizesOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$SizesOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$SizesOrderByWithAggregationInput _instance;

  final TRes Function(Input$SizesOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$SizesOrderByWithAggregationInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (size != _undefined) 'size': (size as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$SizesCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$SizesAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$SizesMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$SizesMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$SizesSumOrderByAggregateInput?),
      }));
  CopyWith$Input$SizesCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$SizesCountOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SizesCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$SizesAvgOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SizesAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$SizesMaxOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SizesMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$SizesMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$SizesMinOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SizesMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$SizesSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$SizesSumOrderByAggregateInput.stub(_then(_instance))
        : CopyWith$Input$SizesSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$SizesOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$SizesOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$SizesOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
    Input$SizesCountOrderByAggregateInput? $_count,
    Input$SizesAvgOrderByAggregateInput? $_avg,
    Input$SizesMaxOrderByAggregateInput? $_max,
    Input$SizesMinOrderByAggregateInput? $_min,
    Input$SizesSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$SizesCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$SizesCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$SizesAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$SizesMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$SizesMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$SizesMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$SizesSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$SizesSumOrderByAggregateInput.stub(_res);
}

class Input$SizesCountOrderByAggregateInput {
  factory Input$SizesCountOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      Input$SizesCountOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesCountOrderByAggregateInput._(this._$data);

  factory Input$SizesCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$Enum$SortOrder((l$size as String));
    }
    return Input$SizesCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get size => (_$data['size'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] =
          l$size == null ? null : toJson$Enum$SortOrder(l$size);
    }
    return result$data;
  }

  CopyWith$Input$SizesCountOrderByAggregateInput<
          Input$SizesCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$SizesCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SizesCountOrderByAggregateInput(
    Input$SizesCountOrderByAggregateInput instance,
    TRes Function(Input$SizesCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SizesCountOrderByAggregateInput;

  factory CopyWith$Input$SizesCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  });
}

class _CopyWithImpl$Input$SizesCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SizesCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SizesCountOrderByAggregateInput _instance;

  final TRes Function(Input$SizesCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesCountOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (size != _undefined) 'size': (size as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SizesCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SizesCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      _res;
}

class Input$SizesAvgOrderByAggregateInput {
  factory Input$SizesAvgOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$SizesAvgOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$SizesAvgOrderByAggregateInput._(this._$data);

  factory Input$SizesAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$SizesAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$SizesAvgOrderByAggregateInput<
          Input$SizesAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$SizesAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SizesAvgOrderByAggregateInput(
    Input$SizesAvgOrderByAggregateInput instance,
    TRes Function(Input$SizesAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SizesAvgOrderByAggregateInput;

  factory CopyWith$Input$SizesAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$SizesAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SizesAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SizesAvgOrderByAggregateInput _instance;

  final TRes Function(Input$SizesAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$SizesAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SizesAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SizesAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$SizesMaxOrderByAggregateInput {
  factory Input$SizesMaxOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      Input$SizesMaxOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesMaxOrderByAggregateInput._(this._$data);

  factory Input$SizesMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$Enum$SortOrder((l$size as String));
    }
    return Input$SizesMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get size => (_$data['size'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] =
          l$size == null ? null : toJson$Enum$SortOrder(l$size);
    }
    return result$data;
  }

  CopyWith$Input$SizesMaxOrderByAggregateInput<
          Input$SizesMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$SizesMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SizesMaxOrderByAggregateInput(
    Input$SizesMaxOrderByAggregateInput instance,
    TRes Function(Input$SizesMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SizesMaxOrderByAggregateInput;

  factory CopyWith$Input$SizesMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  });
}

class _CopyWithImpl$Input$SizesMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SizesMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SizesMaxOrderByAggregateInput _instance;

  final TRes Function(Input$SizesMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (size != _undefined) 'size': (size as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SizesMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SizesMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      _res;
}

class Input$SizesMinOrderByAggregateInput {
  factory Input$SizesMinOrderByAggregateInput({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      Input$SizesMinOrderByAggregateInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesMinOrderByAggregateInput._(this._$data);

  factory Input$SizesMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] =
          l$size == null ? null : fromJson$Enum$SortOrder((l$size as String));
    }
    return Input$SizesMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Enum$SortOrder? get size => (_$data['size'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] =
          l$size == null ? null : toJson$Enum$SortOrder(l$size);
    }
    return result$data;
  }

  CopyWith$Input$SizesMinOrderByAggregateInput<
          Input$SizesMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$SizesMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SizesMinOrderByAggregateInput(
    Input$SizesMinOrderByAggregateInput instance,
    TRes Function(Input$SizesMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SizesMinOrderByAggregateInput;

  factory CopyWith$Input$SizesMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  });
}

class _CopyWithImpl$Input$SizesMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SizesMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SizesMinOrderByAggregateInput _instance;

  final TRes Function(Input$SizesMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesMinOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
        if (size != _undefined) 'size': (size as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SizesMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SizesMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? id,
    Enum$SortOrder? size,
  }) =>
      _res;
}

class Input$SizesSumOrderByAggregateInput {
  factory Input$SizesSumOrderByAggregateInput({Enum$SortOrder? id}) =>
      Input$SizesSumOrderByAggregateInput._({
        if (id != null) r'id': id,
      });

  Input$SizesSumOrderByAggregateInput._(this._$data);

  factory Input$SizesSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] =
          l$id == null ? null : fromJson$Enum$SortOrder((l$id as String));
    }
    return Input$SizesSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get id => (_$data['id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id == null ? null : toJson$Enum$SortOrder(l$id);
    }
    return result$data;
  }

  CopyWith$Input$SizesSumOrderByAggregateInput<
          Input$SizesSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$SizesSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    return Object.hashAll([_$data.containsKey('id') ? l$id : const {}]);
  }
}

abstract class CopyWith$Input$SizesSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$SizesSumOrderByAggregateInput(
    Input$SizesSumOrderByAggregateInput instance,
    TRes Function(Input$SizesSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$SizesSumOrderByAggregateInput;

  factory CopyWith$Input$SizesSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesSumOrderByAggregateInput;

  TRes call({Enum$SortOrder? id});
}

class _CopyWithImpl$Input$SizesSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$SizesSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$SizesSumOrderByAggregateInput _instance;

  final TRes Function(Input$SizesSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? id = _undefined}) =>
      _then(Input$SizesSumOrderByAggregateInput._({
        ..._instance._$data,
        if (id != _undefined) 'id': (id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$SizesSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$SizesSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$SizesSumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? id}) => _res;
}

class Input$SizesScalarWhereWithAggregatesInput {
  factory Input$SizesScalarWhereWithAggregatesInput({
    List<Input$SizesScalarWhereWithAggregatesInput>? AND,
    List<Input$SizesScalarWhereWithAggregatesInput>? OR,
    List<Input$SizesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? size,
  }) =>
      Input$SizesScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesScalarWhereWithAggregatesInput._(this._$data);

  factory Input$SizesScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$SizesScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$SizesScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$SizesScalarWhereWithAggregatesInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$size as Map<String, dynamic>));
    }
    return Input$SizesScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$SizesScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND'] as List<Input$SizesScalarWhereWithAggregatesInput>?);
  List<Input$SizesScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$SizesScalarWhereWithAggregatesInput>?);
  List<Input$SizesScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT'] as List<Input$SizesScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get id =>
      (_$data['id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get size =>
      (_$data['size'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesScalarWhereWithAggregatesInput<
          Input$SizesScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$SizesScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$SizesScalarWhereWithAggregatesInput(
    Input$SizesScalarWhereWithAggregatesInput instance,
    TRes Function(Input$SizesScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$SizesScalarWhereWithAggregatesInput;

  factory CopyWith$Input$SizesScalarWhereWithAggregatesInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$SizesScalarWhereWithAggregatesInput>? AND,
    List<Input$SizesScalarWhereWithAggregatesInput>? OR,
    List<Input$SizesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? size,
  });
  TRes AND(
      Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                      Input$SizesScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                      Input$SizesScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                      Input$SizesScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get size;
}

class _CopyWithImpl$Input$SizesScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$SizesScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$SizesScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$SizesScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$SizesScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$SizesScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$SizesScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$SizesScalarWhereWithAggregatesInput>?),
        if (id != _undefined) 'id': (id as Input$IntWithAggregatesFilter?),
        if (size != _undefined)
          'size': (size as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                          Input$SizesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$SizesScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                          Input$SizesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$SizesScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$SizesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$SizesScalarWhereWithAggregatesInput<
                          Input$SizesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$SizesScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$size, (e) => call(size: e));
  }
}

class _CopyWithStubImpl$Input$SizesScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$SizesScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$SizesScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$SizesScalarWhereWithAggregatesInput>? AND,
    List<Input$SizesScalarWhereWithAggregatesInput>? OR,
    List<Input$SizesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? id,
    Input$StringWithAggregatesFilter? size,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get size =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$TransactionProductOrderByWithAggregationInput {
  factory Input$TransactionProductOrderByWithAggregationInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$TransactionProductCountOrderByAggregateInput? $_count,
    Input$TransactionProductAvgOrderByAggregateInput? $_avg,
    Input$TransactionProductMaxOrderByAggregateInput? $_max,
    Input$TransactionProductMinOrderByAggregateInput? $_min,
    Input$TransactionProductSumOrderByAggregateInput? $_sum,
  }) =>
      Input$TransactionProductOrderByWithAggregationInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$TransactionProductOrderByWithAggregationInput._(this._$data);

  factory Input$TransactionProductOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : fromJson$Enum$SortOrder((l$product_name as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$TransactionProductCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$TransactionProductAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$TransactionProductMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$TransactionProductMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$TransactionProductSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$TransactionProductOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Enum$SortOrder? get product_name =>
      (_$data['product_name'] as Enum$SortOrder?);
  Input$TransactionProductCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$TransactionProductCountOrderByAggregateInput?);
  Input$TransactionProductAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$TransactionProductAvgOrderByAggregateInput?);
  Input$TransactionProductMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$TransactionProductMaxOrderByAggregateInput?);
  Input$TransactionProductMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$TransactionProductMinOrderByAggregateInput?);
  Input$TransactionProductSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$TransactionProductSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] =
          l$product_name == null ? null : toJson$Enum$SortOrder(l$product_name);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductOrderByWithAggregationInput<
          Input$TransactionProductOrderByWithAggregationInput>
      get copyWith =>
          CopyWith$Input$TransactionProductOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductOrderByWithAggregationInput<
    TRes> {
  factory CopyWith$Input$TransactionProductOrderByWithAggregationInput(
    Input$TransactionProductOrderByWithAggregationInput instance,
    TRes Function(Input$TransactionProductOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$TransactionProductOrderByWithAggregationInput;

  factory CopyWith$Input$TransactionProductOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$TransactionProductCountOrderByAggregateInput? $_count,
    Input$TransactionProductAvgOrderByAggregateInput? $_avg,
    Input$TransactionProductMaxOrderByAggregateInput? $_max,
    Input$TransactionProductMinOrderByAggregateInput? $_min,
    Input$TransactionProductSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$TransactionProductCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$TransactionProductOrderByWithAggregationInput<TRes>
    implements
        CopyWith$Input$TransactionProductOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$TransactionProductOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductOrderByWithAggregationInput _instance;

  final TRes Function(Input$TransactionProductOrderByWithAggregationInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$TransactionProductOrderByWithAggregationInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
        if (product_name != _undefined)
          'product_name': (product_name as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count':
              ($_count as Input$TransactionProductCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$TransactionProductAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$TransactionProductMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$TransactionProductMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$TransactionProductSumOrderByAggregateInput?),
      }));
  CopyWith$Input$TransactionProductCountOrderByAggregateInput<TRes>
      get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$TransactionProductCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$TransactionProductAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$TransactionProductMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$TransactionProductMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$TransactionProductSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionProductSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductOrderByWithAggregationInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductOrderByWithAggregationInput(
      this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
    Input$TransactionProductCountOrderByAggregateInput? $_count,
    Input$TransactionProductAvgOrderByAggregateInput? $_avg,
    Input$TransactionProductMaxOrderByAggregateInput? $_max,
    Input$TransactionProductMinOrderByAggregateInput? $_min,
    Input$TransactionProductSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$TransactionProductCountOrderByAggregateInput<TRes>
      get $_count =>
          CopyWith$Input$TransactionProductCountOrderByAggregateInput.stub(
              _res);
  CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$TransactionProductAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$TransactionProductMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$TransactionProductMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$TransactionProductSumOrderByAggregateInput.stub(_res);
}

class Input$TransactionProductCountOrderByAggregateInput {
  factory Input$TransactionProductCountOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      Input$TransactionProductCountOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductCountOrderByAggregateInput._(this._$data);

  factory Input$TransactionProductCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : fromJson$Enum$SortOrder((l$product_name as String));
    }
    return Input$TransactionProductCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Enum$SortOrder? get product_name =>
      (_$data['product_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] =
          l$product_name == null ? null : toJson$Enum$SortOrder(l$product_name);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductCountOrderByAggregateInput<
          Input$TransactionProductCountOrderByAggregateInput>
      get copyWith =>
          CopyWith$Input$TransactionProductCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductCountOrderByAggregateInput<
    TRes> {
  factory CopyWith$Input$TransactionProductCountOrderByAggregateInput(
    Input$TransactionProductCountOrderByAggregateInput instance,
    TRes Function(Input$TransactionProductCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductCountOrderByAggregateInput;

  factory CopyWith$Input$TransactionProductCountOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  });
}

class _CopyWithImpl$Input$TransactionProductCountOrderByAggregateInput<TRes>
    implements
        CopyWith$Input$TransactionProductCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductCountOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionProductCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductCountOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
        if (product_name != _undefined)
          'product_name': (product_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductCountOrderByAggregateInput<TRes>
    implements
        CopyWith$Input$TransactionProductCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductCountOrderByAggregateInput(
      this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      _res;
}

class Input$TransactionProductAvgOrderByAggregateInput {
  factory Input$TransactionProductAvgOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  }) =>
      Input$TransactionProductAvgOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
      });

  Input$TransactionProductAvgOrderByAggregateInput._(this._$data);

  factory Input$TransactionProductAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    return Input$TransactionProductAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductAvgOrderByAggregateInput<
          Input$TransactionProductAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionProductAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionProductAvgOrderByAggregateInput(
    Input$TransactionProductAvgOrderByAggregateInput instance,
    TRes Function(Input$TransactionProductAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductAvgOrderByAggregateInput;

  factory CopyWith$Input$TransactionProductAvgOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  });
}

class _CopyWithImpl$Input$TransactionProductAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductAvgOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionProductAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
  }) =>
      _then(Input$TransactionProductAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  }) =>
      _res;
}

class Input$TransactionProductMaxOrderByAggregateInput {
  factory Input$TransactionProductMaxOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      Input$TransactionProductMaxOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductMaxOrderByAggregateInput._(this._$data);

  factory Input$TransactionProductMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : fromJson$Enum$SortOrder((l$product_name as String));
    }
    return Input$TransactionProductMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Enum$SortOrder? get product_name =>
      (_$data['product_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] =
          l$product_name == null ? null : toJson$Enum$SortOrder(l$product_name);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductMaxOrderByAggregateInput<
          Input$TransactionProductMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionProductMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionProductMaxOrderByAggregateInput(
    Input$TransactionProductMaxOrderByAggregateInput instance,
    TRes Function(Input$TransactionProductMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductMaxOrderByAggregateInput;

  factory CopyWith$Input$TransactionProductMaxOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  });
}

class _CopyWithImpl$Input$TransactionProductMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductMaxOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionProductMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
        if (product_name != _undefined)
          'product_name': (product_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      _res;
}

class Input$TransactionProductMinOrderByAggregateInput {
  factory Input$TransactionProductMinOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      Input$TransactionProductMinOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductMinOrderByAggregateInput._(this._$data);

  factory Input$TransactionProductMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : fromJson$Enum$SortOrder((l$product_name as String));
    }
    return Input$TransactionProductMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Enum$SortOrder? get product_name =>
      (_$data['product_name'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] =
          l$product_name == null ? null : toJson$Enum$SortOrder(l$product_name);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductMinOrderByAggregateInput<
          Input$TransactionProductMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionProductMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionProductMinOrderByAggregateInput(
    Input$TransactionProductMinOrderByAggregateInput instance,
    TRes Function(Input$TransactionProductMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductMinOrderByAggregateInput;

  factory CopyWith$Input$TransactionProductMinOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  });
}

class _CopyWithImpl$Input$TransactionProductMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductMinOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionProductMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductMinOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
        if (product_name != _undefined)
          'product_name': (product_name as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
    Enum$SortOrder? product_name,
  }) =>
      _res;
}

class Input$TransactionProductSumOrderByAggregateInput {
  factory Input$TransactionProductSumOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  }) =>
      Input$TransactionProductSumOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
      });

  Input$TransactionProductSumOrderByAggregateInput._(this._$data);

  factory Input$TransactionProductSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] =
          l$price == null ? null : fromJson$Enum$SortOrder((l$price as String));
    }
    return Input$TransactionProductSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get price => (_$data['price'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] =
          l$price == null ? null : toJson$Enum$SortOrder(l$price);
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductSumOrderByAggregateInput<
          Input$TransactionProductSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionProductSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionProductSumOrderByAggregateInput(
    Input$TransactionProductSumOrderByAggregateInput instance,
    TRes Function(Input$TransactionProductSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductSumOrderByAggregateInput;

  factory CopyWith$Input$TransactionProductSumOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  });
}

class _CopyWithImpl$Input$TransactionProductSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductSumOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionProductSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
  }) =>
      _then(Input$TransactionProductSumOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (price != _undefined) 'price': (price as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionProductSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? price,
  }) =>
      _res;
}

class Input$TransactionProductScalarWhereWithAggregatesInput {
  factory Input$TransactionProductScalarWhereWithAggregatesInput({
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? quantity,
    Input$FloatWithAggregatesFilter? price,
    Input$StringWithAggregatesFilter? product_name,
  }) =>
      Input$TransactionProductScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductScalarWhereWithAggregatesInput._(this._$data);

  factory Input$TransactionProductScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    return Input$TransactionProductScalarWhereWithAggregatesInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionProductScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$TransactionProductScalarWhereWithAggregatesInput>?);
  List<Input$TransactionProductScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR']
          as List<Input$TransactionProductScalarWhereWithAggregatesInput>?);
  List<Input$TransactionProductScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$TransactionProductScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get product_id =>
      (_$data['product_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get quantity =>
      (_$data['quantity'] as Input$IntWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get price =>
      (_$data['price'] as Input$FloatWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get product_name =>
      (_$data['product_name'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
          Input$TransactionProductScalarWhereWithAggregatesInput>
      get copyWith =>
          CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
    TRes> {
  factory CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput(
    Input$TransactionProductScalarWhereWithAggregatesInput instance,
    TRes Function(Input$TransactionProductScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$TransactionProductScalarWhereWithAggregatesInput;

  factory CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? quantity,
    Input$FloatWithAggregatesFilter? price,
    Input$StringWithAggregatesFilter? product_name,
  });
  TRes AND(
      Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                      Input$TransactionProductScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                      Input$TransactionProductScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                      Input$TransactionProductScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get price;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get product_name;
}

class _CopyWithImpl$Input$TransactionProductScalarWhereWithAggregatesInput<TRes>
    implements
        CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$TransactionProductScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$TransactionProductScalarWhereWithAggregatesInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND
              as List<Input$TransactionProductScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR
              as List<Input$TransactionProductScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT
              as List<Input$TransactionProductScalarWhereWithAggregatesInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntWithAggregatesFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntWithAggregatesFilter?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntWithAggregatesFilter?),
        if (price != _undefined)
          'price': (price as Input$FloatWithAggregatesFilter?),
        if (product_name != _undefined)
          'product_name': (product_name as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                          Input$TransactionProductScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) =>
              CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                          Input$TransactionProductScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) =>
              CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionProductScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<
                          Input$TransactionProductScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) =>
              CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$product_name, (e) => call(product_name: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductScalarWhereWithAggregatesInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductScalarWhereWithAggregatesInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionProductScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$IntWithAggregatesFilter? quantity,
    Input$FloatWithAggregatesFilter? price,
    Input$StringWithAggregatesFilter? product_name,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get price =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get product_name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$TransactionStatusWhereUniqueInput {
  factory Input$TransactionStatusWhereUniqueInput(
          {int? transaction_status_id}) =>
      Input$TransactionStatusWhereUniqueInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
      });

  Input$TransactionStatusWhereUniqueInput._(this._$data);

  factory Input$TransactionStatusWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = (l$transaction_status_id as int?);
    }
    return Input$TransactionStatusWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get transaction_status_id => (_$data['transaction_status_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id;
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusWhereUniqueInput<
          Input$TransactionStatusWhereUniqueInput>
      get copyWith => CopyWith$Input$TransactionStatusWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> {
  factory CopyWith$Input$TransactionStatusWhereUniqueInput(
    Input$TransactionStatusWhereUniqueInput instance,
    TRes Function(Input$TransactionStatusWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusWhereUniqueInput;

  factory CopyWith$Input$TransactionStatusWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusWhereUniqueInput;

  TRes call({int? transaction_status_id});
}

class _CopyWithImpl$Input$TransactionStatusWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusWhereUniqueInput _instance;

  final TRes Function(Input$TransactionStatusWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_status_id = _undefined}) =>
      _then(Input$TransactionStatusWhereUniqueInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as int?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusWhereUniqueInput(this._res);

  TRes _res;

  call({int? transaction_status_id}) => _res;
}

class Input$TransactionStatusOrderByWithAggregationInput {
  factory Input$TransactionStatusOrderByWithAggregationInput({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionStatusCountOrderByAggregateInput? $_count,
    Input$TransactionStatusAvgOrderByAggregateInput? $_avg,
    Input$TransactionStatusMaxOrderByAggregateInput? $_max,
    Input$TransactionStatusMinOrderByAggregateInput? $_min,
    Input$TransactionStatusSumOrderByAggregateInput? $_sum,
  }) =>
      Input$TransactionStatusOrderByWithAggregationInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$TransactionStatusOrderByWithAggregationInput._(this._$data);

  factory Input$TransactionStatusOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$TransactionStatusCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$TransactionStatusAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$TransactionStatusMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$TransactionStatusMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$TransactionStatusSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$TransactionStatusOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Input$TransactionStatusCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$TransactionStatusCountOrderByAggregateInput?);
  Input$TransactionStatusAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$TransactionStatusAvgOrderByAggregateInput?);
  Input$TransactionStatusMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$TransactionStatusMaxOrderByAggregateInput?);
  Input$TransactionStatusMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$TransactionStatusMinOrderByAggregateInput?);
  Input$TransactionStatusSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$TransactionStatusSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusOrderByWithAggregationInput<
          Input$TransactionStatusOrderByWithAggregationInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusOrderByWithAggregationInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusOrderByWithAggregationInput(
    Input$TransactionStatusOrderByWithAggregationInput instance,
    TRes Function(Input$TransactionStatusOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusOrderByWithAggregationInput;

  factory CopyWith$Input$TransactionStatusOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionStatusCountOrderByAggregateInput? $_count,
    Input$TransactionStatusAvgOrderByAggregateInput? $_avg,
    Input$TransactionStatusMaxOrderByAggregateInput? $_max,
    Input$TransactionStatusMinOrderByAggregateInput? $_min,
    Input$TransactionStatusSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$TransactionStatusCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$TransactionStatusOrderByWithAggregationInput<TRes>
    implements
        CopyWith$Input$TransactionStatusOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusOrderByWithAggregationInput _instance;

  final TRes Function(Input$TransactionStatusOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$TransactionStatusOrderByWithAggregationInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count':
              ($_count as Input$TransactionStatusCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$TransactionStatusAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$TransactionStatusMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$TransactionStatusMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$TransactionStatusSumOrderByAggregateInput?),
      }));
  CopyWith$Input$TransactionStatusCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$TransactionStatusCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$TransactionStatusAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$TransactionStatusMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$TransactionStatusMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$TransactionStatusSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusOrderByWithAggregationInput<TRes>
    implements
        CopyWith$Input$TransactionStatusOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusOrderByWithAggregationInput(
      this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
    Input$TransactionStatusCountOrderByAggregateInput? $_count,
    Input$TransactionStatusAvgOrderByAggregateInput? $_avg,
    Input$TransactionStatusMaxOrderByAggregateInput? $_max,
    Input$TransactionStatusMinOrderByAggregateInput? $_min,
    Input$TransactionStatusSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusCountOrderByAggregateInput<TRes>
      get $_count =>
          CopyWith$Input$TransactionStatusCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$TransactionStatusAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$TransactionStatusMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$TransactionStatusMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$TransactionStatusSumOrderByAggregateInput.stub(_res);
}

class Input$TransactionStatusCountOrderByAggregateInput {
  factory Input$TransactionStatusCountOrderByAggregateInput({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionStatusCountOrderByAggregateInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusCountOrderByAggregateInput._(this._$data);

  factory Input$TransactionStatusCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionStatusCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusCountOrderByAggregateInput<
          Input$TransactionStatusCountOrderByAggregateInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusCountOrderByAggregateInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusCountOrderByAggregateInput(
    Input$TransactionStatusCountOrderByAggregateInput instance,
    TRes Function(Input$TransactionStatusCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusCountOrderByAggregateInput;

  factory CopyWith$Input$TransactionStatusCountOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionStatusCountOrderByAggregateInput<TRes>
    implements
        CopyWith$Input$TransactionStatusCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusCountOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionStatusCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusCountOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusCountOrderByAggregateInput<TRes>
    implements
        CopyWith$Input$TransactionStatusCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusCountOrderByAggregateInput(
      this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionStatusAvgOrderByAggregateInput {
  factory Input$TransactionStatusAvgOrderByAggregateInput(
          {Enum$SortOrder? transaction_status_id}) =>
      Input$TransactionStatusAvgOrderByAggregateInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
      });

  Input$TransactionStatusAvgOrderByAggregateInput._(this._$data);

  factory Input$TransactionStatusAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    return Input$TransactionStatusAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<
          Input$TransactionStatusAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionStatusAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionStatusAvgOrderByAggregateInput(
    Input$TransactionStatusAvgOrderByAggregateInput instance,
    TRes Function(Input$TransactionStatusAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusAvgOrderByAggregateInput;

  factory CopyWith$Input$TransactionStatusAvgOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? transaction_status_id});
}

class _CopyWithImpl$Input$TransactionStatusAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusAvgOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionStatusAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_status_id = _undefined}) =>
      _then(Input$TransactionStatusAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? transaction_status_id}) => _res;
}

class Input$TransactionStatusMaxOrderByAggregateInput {
  factory Input$TransactionStatusMaxOrderByAggregateInput({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionStatusMaxOrderByAggregateInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusMaxOrderByAggregateInput._(this._$data);

  factory Input$TransactionStatusMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionStatusMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<
          Input$TransactionStatusMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionStatusMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionStatusMaxOrderByAggregateInput(
    Input$TransactionStatusMaxOrderByAggregateInput instance,
    TRes Function(Input$TransactionStatusMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusMaxOrderByAggregateInput;

  factory CopyWith$Input$TransactionStatusMaxOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionStatusMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusMaxOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionStatusMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionStatusMinOrderByAggregateInput {
  factory Input$TransactionStatusMinOrderByAggregateInput({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionStatusMinOrderByAggregateInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusMinOrderByAggregateInput._(this._$data);

  factory Input$TransactionStatusMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] =
          l$name == null ? null : fromJson$Enum$SortOrder((l$name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionStatusMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Enum$SortOrder? get name => (_$data['name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] =
          l$name == null ? null : toJson$Enum$SortOrder(l$name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusMinOrderByAggregateInput<
          Input$TransactionStatusMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionStatusMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionStatusMinOrderByAggregateInput(
    Input$TransactionStatusMinOrderByAggregateInput instance,
    TRes Function(Input$TransactionStatusMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusMinOrderByAggregateInput;

  factory CopyWith$Input$TransactionStatusMinOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionStatusMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusMinOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionStatusMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusMinOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
        if (name != _undefined) 'name': (name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_status_id,
    Enum$SortOrder? name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionStatusSumOrderByAggregateInput {
  factory Input$TransactionStatusSumOrderByAggregateInput(
          {Enum$SortOrder? transaction_status_id}) =>
      Input$TransactionStatusSumOrderByAggregateInput._({
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
      });

  Input$TransactionStatusSumOrderByAggregateInput._(this._$data);

  factory Input$TransactionStatusSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_status_id as String));
    }
    return Input$TransactionStatusSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_status_id =>
      (_$data['transaction_status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusSumOrderByAggregateInput<
          Input$TransactionStatusSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionStatusSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_status_id = transaction_status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionStatusSumOrderByAggregateInput(
    Input$TransactionStatusSumOrderByAggregateInput instance,
    TRes Function(Input$TransactionStatusSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusSumOrderByAggregateInput;

  factory CopyWith$Input$TransactionStatusSumOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusSumOrderByAggregateInput;

  TRes call({Enum$SortOrder? transaction_status_id});
}

class _CopyWithImpl$Input$TransactionStatusSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusSumOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionStatusSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_status_id = _undefined}) =>
      _then(Input$TransactionStatusSumOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_status_id != _undefined)
          'transaction_status_id': (transaction_status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionStatusSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusSumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? transaction_status_id}) => _res;
}

class Input$TransactionStatusScalarWhereWithAggregatesInput {
  factory Input$TransactionStatusScalarWhereWithAggregatesInput({
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_status_id,
    Input$StringWithAggregatesFilter? name,
    Input$StringWithAggregatesFilter? description,
  }) =>
      Input$TransactionStatusScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_status_id != null)
          r'transaction_status_id': transaction_status_id,
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusScalarWhereWithAggregatesInput._(this._$data);

  factory Input$TransactionStatusScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionStatusScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionStatusScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionStatusScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = data['transaction_status_id'];
      result$data['transaction_status_id'] = l$transaction_status_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_status_id as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionStatusScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionStatusScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?);
  List<Input$TransactionStatusScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR']
          as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?);
  List<Input$TransactionStatusScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get transaction_status_id =>
      (_$data['transaction_status_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get name =>
      (_$data['name'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get description =>
      (_$data['description'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_status_id')) {
      final l$transaction_status_id = transaction_status_id;
      result$data['transaction_status_id'] = l$transaction_status_id?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
          Input$TransactionStatusScalarWhereWithAggregatesInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_status_id = transaction_status_id;
    final lOther$transaction_status_id = other.transaction_status_id;
    if (_$data.containsKey('transaction_status_id') !=
        other._$data.containsKey('transaction_status_id')) {
      return false;
    }
    if (l$transaction_status_id != lOther$transaction_status_id) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_status_id = transaction_status_id;
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_status_id')
          ? l$transaction_status_id
          : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput(
    Input$TransactionStatusScalarWhereWithAggregatesInput instance,
    TRes Function(Input$TransactionStatusScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusScalarWhereWithAggregatesInput;

  factory CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_status_id,
    Input$StringWithAggregatesFilter? name,
    Input$StringWithAggregatesFilter? description,
  });
  TRes AND(
      Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                      Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                      Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                      Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_status_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description;
}

class _CopyWithImpl$Input$TransactionStatusScalarWhereWithAggregatesInput<TRes>
    implements
        CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$TransactionStatusScalarWhereWithAggregatesInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_status_id = _undefined,
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND
              as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR
              as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT
              as List<Input$TransactionStatusScalarWhereWithAggregatesInput>?),
        if (transaction_status_id != _undefined)
          'transaction_status_id':
              (transaction_status_id as Input$IntWithAggregatesFilter?),
        if (name != _undefined)
          'name': (name as Input$StringWithAggregatesFilter?),
        if (description != _undefined)
          'description': (description as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                          Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) =>
              CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                          Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) =>
              CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionStatusScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<
                          Input$TransactionStatusScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) =>
              CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_status_id {
    final local$transaction_status_id = _instance.transaction_status_id;
    return local$transaction_status_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_status_id, (e) => call(transaction_status_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusScalarWhereWithAggregatesInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusScalarWhereWithAggregatesInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionStatusScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_status_id,
    Input$StringWithAggregatesFilter? name,
    Input$StringWithAggregatesFilter? description,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_status_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$TransactionTypesWhereUniqueInput {
  factory Input$TransactionTypesWhereUniqueInput({int? transaction_type_id}) =>
      Input$TransactionTypesWhereUniqueInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
      });

  Input$TransactionTypesWhereUniqueInput._(this._$data);

  factory Input$TransactionTypesWhereUniqueInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = (l$transaction_type_id as int?);
    }
    return Input$TransactionTypesWhereUniqueInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get transaction_type_id => (_$data['transaction_type_id'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id;
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesWhereUniqueInput<
          Input$TransactionTypesWhereUniqueInput>
      get copyWith => CopyWith$Input$TransactionTypesWhereUniqueInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesWhereUniqueInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> {
  factory CopyWith$Input$TransactionTypesWhereUniqueInput(
    Input$TransactionTypesWhereUniqueInput instance,
    TRes Function(Input$TransactionTypesWhereUniqueInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesWhereUniqueInput;

  factory CopyWith$Input$TransactionTypesWhereUniqueInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesWhereUniqueInput;

  TRes call({int? transaction_type_id});
}

class _CopyWithImpl$Input$TransactionTypesWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesWhereUniqueInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesWhereUniqueInput _instance;

  final TRes Function(Input$TransactionTypesWhereUniqueInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_type_id = _undefined}) =>
      _then(Input$TransactionTypesWhereUniqueInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as int?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesWhereUniqueInput<TRes>
    implements CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesWhereUniqueInput(this._res);

  TRes _res;

  call({int? transaction_type_id}) => _res;
}

class Input$TransactionTypesOrderByWithAggregationInput {
  factory Input$TransactionTypesOrderByWithAggregationInput({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionTypesCountOrderByAggregateInput? $_count,
    Input$TransactionTypesAvgOrderByAggregateInput? $_avg,
    Input$TransactionTypesMaxOrderByAggregateInput? $_max,
    Input$TransactionTypesMinOrderByAggregateInput? $_min,
    Input$TransactionTypesSumOrderByAggregateInput? $_sum,
  }) =>
      Input$TransactionTypesOrderByWithAggregationInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$TransactionTypesOrderByWithAggregationInput._(this._$data);

  factory Input$TransactionTypesOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : fromJson$Enum$SortOrder((l$type_name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$TransactionTypesCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$TransactionTypesAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$TransactionTypesMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$TransactionTypesMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$TransactionTypesSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$TransactionTypesOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get type_name => (_$data['type_name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Input$TransactionTypesCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$TransactionTypesCountOrderByAggregateInput?);
  Input$TransactionTypesAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$TransactionTypesAvgOrderByAggregateInput?);
  Input$TransactionTypesMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$TransactionTypesMaxOrderByAggregateInput?);
  Input$TransactionTypesMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$TransactionTypesMinOrderByAggregateInput?);
  Input$TransactionTypesSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$TransactionTypesSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] =
          l$type_name == null ? null : toJson$Enum$SortOrder(l$type_name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesOrderByWithAggregationInput<
          Input$TransactionTypesOrderByWithAggregationInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesOrderByWithAggregationInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesOrderByWithAggregationInput(
    Input$TransactionTypesOrderByWithAggregationInput instance,
    TRes Function(Input$TransactionTypesOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesOrderByWithAggregationInput;

  factory CopyWith$Input$TransactionTypesOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionTypesCountOrderByAggregateInput? $_count,
    Input$TransactionTypesAvgOrderByAggregateInput? $_avg,
    Input$TransactionTypesMaxOrderByAggregateInput? $_max,
    Input$TransactionTypesMinOrderByAggregateInput? $_min,
    Input$TransactionTypesSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$TransactionTypesOrderByWithAggregationInput<TRes>
    implements
        CopyWith$Input$TransactionTypesOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesOrderByWithAggregationInput _instance;

  final TRes Function(Input$TransactionTypesOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$TransactionTypesOrderByWithAggregationInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (type_name != _undefined)
          'type_name': (type_name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count':
              ($_count as Input$TransactionTypesCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$TransactionTypesAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$TransactionTypesMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$TransactionTypesMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$TransactionTypesSumOrderByAggregateInput?),
      }));
  CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$TransactionTypesCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$TransactionTypesAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$TransactionTypesMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$TransactionTypesMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$TransactionTypesSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesOrderByWithAggregationInput<TRes>
    implements
        CopyWith$Input$TransactionTypesOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesOrderByWithAggregationInput(
      this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
    Input$TransactionTypesCountOrderByAggregateInput? $_count,
    Input$TransactionTypesAvgOrderByAggregateInput? $_avg,
    Input$TransactionTypesMaxOrderByAggregateInput? $_max,
    Input$TransactionTypesMinOrderByAggregateInput? $_min,
    Input$TransactionTypesSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$TransactionTypesCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$TransactionTypesAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$TransactionTypesMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$TransactionTypesMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$TransactionTypesSumOrderByAggregateInput.stub(_res);
}

class Input$TransactionTypesCountOrderByAggregateInput {
  factory Input$TransactionTypesCountOrderByAggregateInput({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionTypesCountOrderByAggregateInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesCountOrderByAggregateInput._(this._$data);

  factory Input$TransactionTypesCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : fromJson$Enum$SortOrder((l$type_name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionTypesCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get type_name => (_$data['type_name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] =
          l$type_name == null ? null : toJson$Enum$SortOrder(l$type_name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesCountOrderByAggregateInput<
          Input$TransactionTypesCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionTypesCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionTypesCountOrderByAggregateInput(
    Input$TransactionTypesCountOrderByAggregateInput instance,
    TRes Function(Input$TransactionTypesCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesCountOrderByAggregateInput;

  factory CopyWith$Input$TransactionTypesCountOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionTypesCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesCountOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionTypesCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesCountOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (type_name != _undefined)
          'type_name': (type_name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionTypesAvgOrderByAggregateInput {
  factory Input$TransactionTypesAvgOrderByAggregateInput(
          {Enum$SortOrder? transaction_type_id}) =>
      Input$TransactionTypesAvgOrderByAggregateInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
      });

  Input$TransactionTypesAvgOrderByAggregateInput._(this._$data);

  factory Input$TransactionTypesAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    return Input$TransactionTypesAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<
          Input$TransactionTypesAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionTypesAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionTypesAvgOrderByAggregateInput(
    Input$TransactionTypesAvgOrderByAggregateInput instance,
    TRes Function(Input$TransactionTypesAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesAvgOrderByAggregateInput;

  factory CopyWith$Input$TransactionTypesAvgOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesAvgOrderByAggregateInput;

  TRes call({Enum$SortOrder? transaction_type_id});
}

class _CopyWithImpl$Input$TransactionTypesAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesAvgOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionTypesAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_type_id = _undefined}) =>
      _then(Input$TransactionTypesAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? transaction_type_id}) => _res;
}

class Input$TransactionTypesMaxOrderByAggregateInput {
  factory Input$TransactionTypesMaxOrderByAggregateInput({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionTypesMaxOrderByAggregateInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesMaxOrderByAggregateInput._(this._$data);

  factory Input$TransactionTypesMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : fromJson$Enum$SortOrder((l$type_name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionTypesMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get type_name => (_$data['type_name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] =
          l$type_name == null ? null : toJson$Enum$SortOrder(l$type_name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<
          Input$TransactionTypesMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionTypesMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionTypesMaxOrderByAggregateInput(
    Input$TransactionTypesMaxOrderByAggregateInput instance,
    TRes Function(Input$TransactionTypesMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesMaxOrderByAggregateInput;

  factory CopyWith$Input$TransactionTypesMaxOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionTypesMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesMaxOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionTypesMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (type_name != _undefined)
          'type_name': (type_name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionTypesMinOrderByAggregateInput {
  factory Input$TransactionTypesMinOrderByAggregateInput({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      Input$TransactionTypesMinOrderByAggregateInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesMinOrderByAggregateInput._(this._$data);

  factory Input$TransactionTypesMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : fromJson$Enum$SortOrder((l$type_name as String));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : fromJson$Enum$SortOrder((l$description as String));
    }
    return Input$TransactionTypesMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get type_name => (_$data['type_name'] as Enum$SortOrder?);
  Enum$SortOrder? get description => (_$data['description'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] =
          l$type_name == null ? null : toJson$Enum$SortOrder(l$type_name);
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] =
          l$description == null ? null : toJson$Enum$SortOrder(l$description);
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesMinOrderByAggregateInput<
          Input$TransactionTypesMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionTypesMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionTypesMinOrderByAggregateInput(
    Input$TransactionTypesMinOrderByAggregateInput instance,
    TRes Function(Input$TransactionTypesMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesMinOrderByAggregateInput;

  factory CopyWith$Input$TransactionTypesMinOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  });
}

class _CopyWithImpl$Input$TransactionTypesMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesMinOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionTypesMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesMinOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (type_name != _undefined)
          'type_name': (type_name as Enum$SortOrder?),
        if (description != _undefined)
          'description': (description as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? type_name,
    Enum$SortOrder? description,
  }) =>
      _res;
}

class Input$TransactionTypesSumOrderByAggregateInput {
  factory Input$TransactionTypesSumOrderByAggregateInput(
          {Enum$SortOrder? transaction_type_id}) =>
      Input$TransactionTypesSumOrderByAggregateInput._({
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
      });

  Input$TransactionTypesSumOrderByAggregateInput._(this._$data);

  factory Input$TransactionTypesSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    return Input$TransactionTypesSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesSumOrderByAggregateInput<
          Input$TransactionTypesSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionTypesSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_type_id = transaction_type_id;
    return Object.hashAll([
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {}
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionTypesSumOrderByAggregateInput(
    Input$TransactionTypesSumOrderByAggregateInput instance,
    TRes Function(Input$TransactionTypesSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesSumOrderByAggregateInput;

  factory CopyWith$Input$TransactionTypesSumOrderByAggregateInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesSumOrderByAggregateInput;

  TRes call({Enum$SortOrder? transaction_type_id});
}

class _CopyWithImpl$Input$TransactionTypesSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesSumOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionTypesSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? transaction_type_id = _undefined}) =>
      _then(Input$TransactionTypesSumOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionTypesSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesSumOrderByAggregateInput(this._res);

  TRes _res;

  call({Enum$SortOrder? transaction_type_id}) => _res;
}

class Input$TransactionTypesScalarWhereWithAggregatesInput {
  factory Input$TransactionTypesScalarWhereWithAggregatesInput({
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$StringWithAggregatesFilter? type_name,
    Input$StringWithAggregatesFilter? description,
  }) =>
      Input$TransactionTypesScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesScalarWhereWithAggregatesInput._(this._$data);

  factory Input$TransactionTypesScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionTypesScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionTypesScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionTypesScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_type_id as Map<String, dynamic>));
    }
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$type_name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionTypesScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionTypesScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?);
  List<Input$TransactionTypesScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR']
          as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?);
  List<Input$TransactionTypesScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get transaction_type_id =>
      (_$data['transaction_type_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get type_name =>
      (_$data['type_name'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get description =>
      (_$data['description'] as Input$StringWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id?.toJson();
    }
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] = l$type_name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
          Input$TransactionTypesScalarWhereWithAggregatesInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_type_id = transaction_type_id;
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput(
    Input$TransactionTypesScalarWhereWithAggregatesInput instance,
    TRes Function(Input$TransactionTypesScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesScalarWhereWithAggregatesInput;

  factory CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$StringWithAggregatesFilter? type_name,
    Input$StringWithAggregatesFilter? description,
  });
  TRes AND(
      Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                      Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                      Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                      Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get type_name;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description;
}

class _CopyWithImpl$Input$TransactionTypesScalarWhereWithAggregatesInput<TRes>
    implements
        CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$TransactionTypesScalarWhereWithAggregatesInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_type_id = _undefined,
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND
              as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR
              as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT': (NOT
              as List<Input$TransactionTypesScalarWhereWithAggregatesInput>?),
        if (transaction_type_id != _undefined)
          'transaction_type_id':
              (transaction_type_id as Input$IntWithAggregatesFilter?),
        if (type_name != _undefined)
          'type_name': (type_name as Input$StringWithAggregatesFilter?),
        if (description != _undefined)
          'description': (description as Input$StringWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                          Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map((e) =>
              CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes OR(
          Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                          Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map((e) =>
              CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionTypesScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<
                          Input$TransactionTypesScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map((e) =>
              CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput(
                e,
                (i) => i,
              )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id {
    final local$transaction_type_id = _instance.transaction_type_id;
    return local$transaction_type_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_type_id, (e) => call(transaction_type_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get type_name {
    final local$type_name = _instance.type_name;
    return local$type_name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$type_name, (e) => call(type_name: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesScalarWhereWithAggregatesInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesScalarWhereWithAggregatesInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionTypesScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$StringWithAggregatesFilter? type_name,
    Input$StringWithAggregatesFilter? description,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get type_name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get description =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
}

class Input$TransactionsOrderByWithAggregationInput {
  factory Input$TransactionsOrderByWithAggregationInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
    Input$TransactionsCountOrderByAggregateInput? $_count,
    Input$TransactionsAvgOrderByAggregateInput? $_avg,
    Input$TransactionsMaxOrderByAggregateInput? $_max,
    Input$TransactionsMinOrderByAggregateInput? $_min,
    Input$TransactionsSumOrderByAggregateInput? $_sum,
  }) =>
      Input$TransactionsOrderByWithAggregationInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
        if ($_count != null) r'_count': $_count,
        if ($_avg != null) r'_avg': $_avg,
        if ($_max != null) r'_max': $_max,
        if ($_min != null) r'_min': $_min,
        if ($_sum != null) r'_sum': $_sum,
      });

  Input$TransactionsOrderByWithAggregationInput._(this._$data);

  factory Input$TransactionsOrderByWithAggregationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_name as String));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_phone as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$SortOrder((l$address as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : fromJson$Enum$SortOrder((l$date as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$TransactionsCountOrderByAggregateInput.fromJson(
              (l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_avg')) {
      final l$$_avg = data['_avg'];
      result$data['_avg'] = l$$_avg == null
          ? null
          : Input$TransactionsAvgOrderByAggregateInput.fromJson(
              (l$$_avg as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$TransactionsMaxOrderByAggregateInput.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$TransactionsMinOrderByAggregateInput.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_sum')) {
      final l$$_sum = data['_sum'];
      result$data['_sum'] = l$$_sum == null
          ? null
          : Input$TransactionsSumOrderByAggregateInput.fromJson(
              (l$$_sum as Map<String, dynamic>));
    }
    return Input$TransactionsOrderByWithAggregationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_name =>
      (_$data['customer_name'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_phone =>
      (_$data['customer_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get address => (_$data['address'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get date => (_$data['date'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Input$TransactionsCountOrderByAggregateInput? get $_count =>
      (_$data['_count'] as Input$TransactionsCountOrderByAggregateInput?);
  Input$TransactionsAvgOrderByAggregateInput? get $_avg =>
      (_$data['_avg'] as Input$TransactionsAvgOrderByAggregateInput?);
  Input$TransactionsMaxOrderByAggregateInput? get $_max =>
      (_$data['_max'] as Input$TransactionsMaxOrderByAggregateInput?);
  Input$TransactionsMinOrderByAggregateInput? get $_min =>
      (_$data['_min'] as Input$TransactionsMinOrderByAggregateInput?);
  Input$TransactionsSumOrderByAggregateInput? get $_sum =>
      (_$data['_sum'] as Input$TransactionsSumOrderByAggregateInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name == null
          ? null
          : toJson$Enum$SortOrder(l$customer_name);
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : toJson$Enum$SortOrder(l$customer_phone);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$SortOrder(l$address);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] =
          l$date == null ? null : toJson$Enum$SortOrder(l$date);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_avg')) {
      final l$$_avg = $_avg;
      result$data['_avg'] = l$$_avg?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_sum')) {
      final l$$_sum = $_sum;
      result$data['_sum'] = l$$_sum?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsOrderByWithAggregationInput<
          Input$TransactionsOrderByWithAggregationInput>
      get copyWith => CopyWith$Input$TransactionsOrderByWithAggregationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsOrderByWithAggregationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_avg = $_avg;
    final lOther$$_avg = other.$_avg;
    if (_$data.containsKey('_avg') != other._$data.containsKey('_avg')) {
      return false;
    }
    if (l$$_avg != lOther$$_avg) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_sum = $_sum;
    final lOther$$_sum = other.$_sum;
    if (_$data.containsKey('_sum') != other._$data.containsKey('_sum')) {
      return false;
    }
    if (l$$_sum != lOther$$_sum) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    final l$$_count = $_count;
    final l$$_avg = $_avg;
    final l$$_max = $_max;
    final l$$_min = $_min;
    final l$$_sum = $_sum;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_avg') ? l$$_avg : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_sum') ? l$$_sum : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsOrderByWithAggregationInput<TRes> {
  factory CopyWith$Input$TransactionsOrderByWithAggregationInput(
    Input$TransactionsOrderByWithAggregationInput instance,
    TRes Function(Input$TransactionsOrderByWithAggregationInput) then,
  ) = _CopyWithImpl$Input$TransactionsOrderByWithAggregationInput;

  factory CopyWith$Input$TransactionsOrderByWithAggregationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsOrderByWithAggregationInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
    Input$TransactionsCountOrderByAggregateInput? $_count,
    Input$TransactionsAvgOrderByAggregateInput? $_avg,
    Input$TransactionsMaxOrderByAggregateInput? $_max,
    Input$TransactionsMinOrderByAggregateInput? $_min,
    Input$TransactionsSumOrderByAggregateInput? $_sum,
  });
  CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> get $_count;
  CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> get $_avg;
  CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> get $_max;
  CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> get $_min;
  CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> get $_sum;
}

class _CopyWithImpl$Input$TransactionsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$TransactionsOrderByWithAggregationInput<TRes> {
  _CopyWithImpl$Input$TransactionsOrderByWithAggregationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsOrderByWithAggregationInput _instance;

  final TRes Function(Input$TransactionsOrderByWithAggregationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
    Object? $_count = _undefined,
    Object? $_avg = _undefined,
    Object? $_max = _undefined,
    Object? $_min = _undefined,
    Object? $_sum = _undefined,
  }) =>
      _then(Input$TransactionsOrderByWithAggregationInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Enum$SortOrder?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (address != _undefined) 'address': (address as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (date != _undefined) 'date': (date as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
        if ($_count != _undefined)
          '_count': ($_count as Input$TransactionsCountOrderByAggregateInput?),
        if ($_avg != _undefined)
          '_avg': ($_avg as Input$TransactionsAvgOrderByAggregateInput?),
        if ($_max != _undefined)
          '_max': ($_max as Input$TransactionsMaxOrderByAggregateInput?),
        if ($_min != _undefined)
          '_min': ($_min as Input$TransactionsMinOrderByAggregateInput?),
        if ($_sum != _undefined)
          '_sum': ($_sum as Input$TransactionsSumOrderByAggregateInput?),
      }));
  CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$TransactionsCountOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCountOrderByAggregateInput(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> get $_avg {
    final local$$_avg = _instance.$_avg;
    return local$$_avg == null
        ? CopyWith$Input$TransactionsAvgOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsAvgOrderByAggregateInput(
            local$$_avg, (e) => call($_avg: e));
  }

  CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$TransactionsMaxOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsMaxOrderByAggregateInput(
            local$$_max, (e) => call($_max: e));
  }

  CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$TransactionsMinOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsMinOrderByAggregateInput(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> get $_sum {
    final local$$_sum = _instance.$_sum;
    return local$$_sum == null
        ? CopyWith$Input$TransactionsSumOrderByAggregateInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsSumOrderByAggregateInput(
            local$$_sum, (e) => call($_sum: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsOrderByWithAggregationInput<TRes>
    implements CopyWith$Input$TransactionsOrderByWithAggregationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsOrderByWithAggregationInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
    Input$TransactionsCountOrderByAggregateInput? $_count,
    Input$TransactionsAvgOrderByAggregateInput? $_avg,
    Input$TransactionsMaxOrderByAggregateInput? $_max,
    Input$TransactionsMinOrderByAggregateInput? $_min,
    Input$TransactionsSumOrderByAggregateInput? $_sum,
  }) =>
      _res;
  CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> get $_count =>
      CopyWith$Input$TransactionsCountOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> get $_avg =>
      CopyWith$Input$TransactionsAvgOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> get $_max =>
      CopyWith$Input$TransactionsMaxOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> get $_min =>
      CopyWith$Input$TransactionsMinOrderByAggregateInput.stub(_res);
  CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> get $_sum =>
      CopyWith$Input$TransactionsSumOrderByAggregateInput.stub(_res);
}

class Input$TransactionsCountOrderByAggregateInput {
  factory Input$TransactionsCountOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      Input$TransactionsCountOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsCountOrderByAggregateInput._(this._$data);

  factory Input$TransactionsCountOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_name as String));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_phone as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$SortOrder((l$address as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : fromJson$Enum$SortOrder((l$date as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    return Input$TransactionsCountOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_name =>
      (_$data['customer_name'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_phone =>
      (_$data['customer_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get address => (_$data['address'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get date => (_$data['date'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name == null
          ? null
          : toJson$Enum$SortOrder(l$customer_name);
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : toJson$Enum$SortOrder(l$customer_phone);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$SortOrder(l$address);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] =
          l$date == null ? null : toJson$Enum$SortOrder(l$date);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCountOrderByAggregateInput<
          Input$TransactionsCountOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionsCountOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCountOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsCountOrderByAggregateInput(
    Input$TransactionsCountOrderByAggregateInput instance,
    TRes Function(Input$TransactionsCountOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsCountOrderByAggregateInput;

  factory CopyWith$Input$TransactionsCountOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsCountOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  });
}

class _CopyWithImpl$Input$TransactionsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsCountOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCountOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionsCountOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsCountOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Enum$SortOrder?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (address != _undefined) 'address': (address as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (date != _undefined) 'date': (date as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsCountOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsCountOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCountOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      _res;
}

class Input$TransactionsAvgOrderByAggregateInput {
  factory Input$TransactionsAvgOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      Input$TransactionsAvgOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (city_id != null) r'city_id': city_id,
        if (quantity != null) r'quantity': quantity,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsAvgOrderByAggregateInput._(this._$data);

  factory Input$TransactionsAvgOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    return Input$TransactionsAvgOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsAvgOrderByAggregateInput<
          Input$TransactionsAvgOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionsAvgOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsAvgOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$city_id = city_id;
    final l$quantity = quantity;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsAvgOrderByAggregateInput(
    Input$TransactionsAvgOrderByAggregateInput instance,
    TRes Function(Input$TransactionsAvgOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsAvgOrderByAggregateInput;

  factory CopyWith$Input$TransactionsAvgOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsAvgOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  });
}

class _CopyWithImpl$Input$TransactionsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsAvgOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsAvgOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionsAvgOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? city_id = _undefined,
    Object? quantity = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsAvgOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsAvgOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsAvgOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsAvgOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      _res;
}

class Input$TransactionsMaxOrderByAggregateInput {
  factory Input$TransactionsMaxOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      Input$TransactionsMaxOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsMaxOrderByAggregateInput._(this._$data);

  factory Input$TransactionsMaxOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_name as String));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_phone as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$SortOrder((l$address as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : fromJson$Enum$SortOrder((l$date as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    return Input$TransactionsMaxOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_name =>
      (_$data['customer_name'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_phone =>
      (_$data['customer_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get address => (_$data['address'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get date => (_$data['date'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name == null
          ? null
          : toJson$Enum$SortOrder(l$customer_name);
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : toJson$Enum$SortOrder(l$customer_phone);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$SortOrder(l$address);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] =
          l$date == null ? null : toJson$Enum$SortOrder(l$date);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsMaxOrderByAggregateInput<
          Input$TransactionsMaxOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionsMaxOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsMaxOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsMaxOrderByAggregateInput(
    Input$TransactionsMaxOrderByAggregateInput instance,
    TRes Function(Input$TransactionsMaxOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsMaxOrderByAggregateInput;

  factory CopyWith$Input$TransactionsMaxOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsMaxOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  });
}

class _CopyWithImpl$Input$TransactionsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsMaxOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsMaxOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionsMaxOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsMaxOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Enum$SortOrder?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (address != _undefined) 'address': (address as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (date != _undefined) 'date': (date as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsMaxOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsMaxOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsMaxOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      _res;
}

class Input$TransactionsMinOrderByAggregateInput {
  factory Input$TransactionsMinOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      Input$TransactionsMinOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsMinOrderByAggregateInput._(this._$data);

  factory Input$TransactionsMinOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_name as String));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : fromJson$Enum$SortOrder((l$customer_phone as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : fromJson$Enum$SortOrder((l$address as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] =
          l$date == null ? null : fromJson$Enum$SortOrder((l$date as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    return Input$TransactionsMinOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_name =>
      (_$data['customer_name'] as Enum$SortOrder?);
  Enum$SortOrder? get customer_phone =>
      (_$data['customer_phone'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get address => (_$data['address'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get date => (_$data['date'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name == null
          ? null
          : toJson$Enum$SortOrder(l$customer_name);
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : toJson$Enum$SortOrder(l$customer_phone);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] =
          l$address == null ? null : toJson$Enum$SortOrder(l$address);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] =
          l$date == null ? null : toJson$Enum$SortOrder(l$date);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsMinOrderByAggregateInput<
          Input$TransactionsMinOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionsMinOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsMinOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsMinOrderByAggregateInput(
    Input$TransactionsMinOrderByAggregateInput instance,
    TRes Function(Input$TransactionsMinOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsMinOrderByAggregateInput;

  factory CopyWith$Input$TransactionsMinOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsMinOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  });
}

class _CopyWithImpl$Input$TransactionsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsMinOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsMinOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionsMinOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsMinOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Enum$SortOrder?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (address != _undefined) 'address': (address as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (date != _undefined) 'date': (date as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsMinOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsMinOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsMinOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? customer_name,
    Enum$SortOrder? customer_phone,
    Enum$SortOrder? city_id,
    Enum$SortOrder? address,
    Enum$SortOrder? quantity,
    Enum$SortOrder? date,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      _res;
}

class Input$TransactionsSumOrderByAggregateInput {
  factory Input$TransactionsSumOrderByAggregateInput({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      Input$TransactionsSumOrderByAggregateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (city_id != null) r'city_id': city_id,
        if (quantity != null) r'quantity': quantity,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsSumOrderByAggregateInput._(this._$data);

  factory Input$TransactionsSumOrderByAggregateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_id as String));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : fromJson$Enum$SortOrder((l$seller_id as String));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : fromJson$Enum$SortOrder((l$product_id as String));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : fromJson$Enum$SortOrder((l$city_id as String));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : fromJson$Enum$SortOrder((l$quantity as String));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$remainingPayement as String));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : fromJson$Enum$SortOrder((l$totalPayement as String));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : fromJson$Enum$SortOrder((l$transaction_type_id as String));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : fromJson$Enum$SortOrder((l$status_id as String));
    }
    return Input$TransactionsSumOrderByAggregateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Enum$SortOrder? get transaction_id =>
      (_$data['transaction_id'] as Enum$SortOrder?);
  Enum$SortOrder? get seller_id => (_$data['seller_id'] as Enum$SortOrder?);
  Enum$SortOrder? get product_id => (_$data['product_id'] as Enum$SortOrder?);
  Enum$SortOrder? get city_id => (_$data['city_id'] as Enum$SortOrder?);
  Enum$SortOrder? get quantity => (_$data['quantity'] as Enum$SortOrder?);
  Enum$SortOrder? get remainingPayement =>
      (_$data['remainingPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get totalPayement =>
      (_$data['totalPayement'] as Enum$SortOrder?);
  Enum$SortOrder? get transaction_type_id =>
      (_$data['transaction_type_id'] as Enum$SortOrder?);
  Enum$SortOrder? get status_id => (_$data['status_id'] as Enum$SortOrder?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_id);
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] =
          l$seller_id == null ? null : toJson$Enum$SortOrder(l$seller_id);
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] =
          l$product_id == null ? null : toJson$Enum$SortOrder(l$product_id);
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] =
          l$city_id == null ? null : toJson$Enum$SortOrder(l$city_id);
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] =
          l$quantity == null ? null : toJson$Enum$SortOrder(l$quantity);
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : toJson$Enum$SortOrder(l$remainingPayement);
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : toJson$Enum$SortOrder(l$totalPayement);
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : toJson$Enum$SortOrder(l$transaction_type_id);
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] =
          l$status_id == null ? null : toJson$Enum$SortOrder(l$status_id);
    }
    return result$data;
  }

  CopyWith$Input$TransactionsSumOrderByAggregateInput<
          Input$TransactionsSumOrderByAggregateInput>
      get copyWith => CopyWith$Input$TransactionsSumOrderByAggregateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsSumOrderByAggregateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$city_id = city_id;
    final l$quantity = quantity;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> {
  factory CopyWith$Input$TransactionsSumOrderByAggregateInput(
    Input$TransactionsSumOrderByAggregateInput instance,
    TRes Function(Input$TransactionsSumOrderByAggregateInput) then,
  ) = _CopyWithImpl$Input$TransactionsSumOrderByAggregateInput;

  factory CopyWith$Input$TransactionsSumOrderByAggregateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsSumOrderByAggregateInput;

  TRes call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  });
}

class _CopyWithImpl$Input$TransactionsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> {
  _CopyWithImpl$Input$TransactionsSumOrderByAggregateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsSumOrderByAggregateInput _instance;

  final TRes Function(Input$TransactionsSumOrderByAggregateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? city_id = _undefined,
    Object? quantity = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsSumOrderByAggregateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Enum$SortOrder?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Enum$SortOrder?),
        if (product_id != _undefined)
          'product_id': (product_id as Enum$SortOrder?),
        if (city_id != _undefined) 'city_id': (city_id as Enum$SortOrder?),
        if (quantity != _undefined) 'quantity': (quantity as Enum$SortOrder?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Enum$SortOrder?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Enum$SortOrder?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Enum$SortOrder?),
        if (status_id != _undefined)
          'status_id': (status_id as Enum$SortOrder?),
      }));
}

class _CopyWithStubImpl$Input$TransactionsSumOrderByAggregateInput<TRes>
    implements CopyWith$Input$TransactionsSumOrderByAggregateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsSumOrderByAggregateInput(this._res);

  TRes _res;

  call({
    Enum$SortOrder? transaction_id,
    Enum$SortOrder? seller_id,
    Enum$SortOrder? product_id,
    Enum$SortOrder? city_id,
    Enum$SortOrder? quantity,
    Enum$SortOrder? remainingPayement,
    Enum$SortOrder? totalPayement,
    Enum$SortOrder? transaction_type_id,
    Enum$SortOrder? status_id,
  }) =>
      _res;
}

class Input$TransactionsScalarWhereWithAggregatesInput {
  factory Input$TransactionsScalarWhereWithAggregatesInput({
    List<Input$TransactionsScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? seller_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$StringWithAggregatesFilter? customer_name,
    Input$StringWithAggregatesFilter? customer_phone,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? address,
    Input$IntWithAggregatesFilter? quantity,
    Input$DateTimeWithAggregatesFilter? date,
    Input$FloatWithAggregatesFilter? remainingPayement,
    Input$FloatWithAggregatesFilter? totalPayement,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$IntWithAggregatesFilter? status_id,
  }) =>
      Input$TransactionsScalarWhereWithAggregatesInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsScalarWhereWithAggregatesInput._(this._$data);

  factory Input$TransactionsScalarWhereWithAggregatesInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsScalarWhereWithAggregatesInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$seller_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringWithAggregatesFilter.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeWithAggregatesFilter.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatWithAggregatesFilter.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$transaction_type_id as Map<String, dynamic>));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : Input$IntWithAggregatesFilter.fromJson(
              (l$status_id as Map<String, dynamic>));
    }
    return Input$TransactionsScalarWhereWithAggregatesInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsScalarWhereWithAggregatesInput>? get AND =>
      (_$data['AND']
          as List<Input$TransactionsScalarWhereWithAggregatesInput>?);
  List<Input$TransactionsScalarWhereWithAggregatesInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionsScalarWhereWithAggregatesInput>?);
  List<Input$TransactionsScalarWhereWithAggregatesInput>? get NOT =>
      (_$data['NOT']
          as List<Input$TransactionsScalarWhereWithAggregatesInput>?);
  Input$IntWithAggregatesFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get seller_id =>
      (_$data['seller_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get product_id =>
      (_$data['product_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get customer_name =>
      (_$data['customer_name'] as Input$StringWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get customer_phone =>
      (_$data['customer_phone'] as Input$StringWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get city_id =>
      (_$data['city_id'] as Input$IntWithAggregatesFilter?);
  Input$StringWithAggregatesFilter? get address =>
      (_$data['address'] as Input$StringWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get quantity =>
      (_$data['quantity'] as Input$IntWithAggregatesFilter?);
  Input$DateTimeWithAggregatesFilter? get date =>
      (_$data['date'] as Input$DateTimeWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatWithAggregatesFilter?);
  Input$FloatWithAggregatesFilter? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get transaction_type_id =>
      (_$data['transaction_type_id'] as Input$IntWithAggregatesFilter?);
  Input$IntWithAggregatesFilter? get status_id =>
      (_$data['status_id'] as Input$IntWithAggregatesFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id?.toJson();
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] = l$status_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
          Input$TransactionsScalarWhereWithAggregatesInput>
      get copyWith => CopyWith$Input$TransactionsScalarWhereWithAggregatesInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsScalarWhereWithAggregatesInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<TRes> {
  factory CopyWith$Input$TransactionsScalarWhereWithAggregatesInput(
    Input$TransactionsScalarWhereWithAggregatesInput instance,
    TRes Function(Input$TransactionsScalarWhereWithAggregatesInput) then,
  ) = _CopyWithImpl$Input$TransactionsScalarWhereWithAggregatesInput;

  factory CopyWith$Input$TransactionsScalarWhereWithAggregatesInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsScalarWhereWithAggregatesInput;

  TRes call({
    List<Input$TransactionsScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? seller_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$StringWithAggregatesFilter? customer_name,
    Input$StringWithAggregatesFilter? customer_phone,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? address,
    Input$IntWithAggregatesFilter? quantity,
    Input$DateTimeWithAggregatesFilter? date,
    Input$FloatWithAggregatesFilter? remainingPayement,
    Input$FloatWithAggregatesFilter? totalPayement,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$IntWithAggregatesFilter? status_id,
  });
  TRes AND(
      Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                      Input$TransactionsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                      Input$TransactionsScalarWhereWithAggregatesInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                      Input$TransactionsScalarWhereWithAggregatesInput>>?)
          _fn);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_name;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_phone;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id;
  CopyWith$Input$StringWithAggregatesFilter<TRes> get address;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity;
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get date;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get remainingPayement;
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get totalPayement;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get status_id;
}

class _CopyWithImpl$Input$TransactionsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithImpl$Input$TransactionsScalarWhereWithAggregatesInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsScalarWhereWithAggregatesInput _instance;

  final TRes Function(Input$TransactionsScalarWhereWithAggregatesInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsScalarWhereWithAggregatesInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND':
              (AND as List<Input$TransactionsScalarWhereWithAggregatesInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionsScalarWhereWithAggregatesInput>?),
        if (NOT != _undefined)
          'NOT':
              (NOT as List<Input$TransactionsScalarWhereWithAggregatesInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntWithAggregatesFilter?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Input$IntWithAggregatesFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntWithAggregatesFilter?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Input$StringWithAggregatesFilter?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringWithAggregatesFilter?),
        if (city_id != _undefined)
          'city_id': (city_id as Input$IntWithAggregatesFilter?),
        if (address != _undefined)
          'address': (address as Input$StringWithAggregatesFilter?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntWithAggregatesFilter?),
        if (date != _undefined)
          'date': (date as Input$DateTimeWithAggregatesFilter?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatWithAggregatesFilter?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Input$FloatWithAggregatesFilter?),
        if (transaction_type_id != _undefined)
          'transaction_type_id':
              (transaction_type_id as Input$IntWithAggregatesFilter?),
        if (status_id != _undefined)
          'status_id': (status_id as Input$IntWithAggregatesFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                          Input$TransactionsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND?.map(
              (e) => CopyWith$Input$TransactionsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                          Input$TransactionsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR?.map(
              (e) => CopyWith$Input$TransactionsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionsScalarWhereWithAggregatesInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<
                          Input$TransactionsScalarWhereWithAggregatesInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT?.map(
              (e) => CopyWith$Input$TransactionsScalarWhereWithAggregatesInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id {
    final local$seller_id = _instance.seller_id;
    return local$seller_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$seller_id, (e) => call(seller_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringWithAggregatesFilter<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$StringWithAggregatesFilter(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeWithAggregatesFilter(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatWithAggregatesFilter<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$FloatWithAggregatesFilter(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id {
    final local$transaction_type_id = _instance.transaction_type_id;
    return local$transaction_type_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$transaction_type_id, (e) => call(transaction_type_id: e));
  }

  CopyWith$Input$IntWithAggregatesFilter<TRes> get status_id {
    final local$status_id = _instance.status_id;
    return local$status_id == null
        ? CopyWith$Input$IntWithAggregatesFilter.stub(_then(_instance))
        : CopyWith$Input$IntWithAggregatesFilter(
            local$status_id, (e) => call(status_id: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsScalarWhereWithAggregatesInput<TRes>
    implements CopyWith$Input$TransactionsScalarWhereWithAggregatesInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsScalarWhereWithAggregatesInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionsScalarWhereWithAggregatesInput>? AND,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? OR,
    List<Input$TransactionsScalarWhereWithAggregatesInput>? NOT,
    Input$IntWithAggregatesFilter? transaction_id,
    Input$IntWithAggregatesFilter? seller_id,
    Input$IntWithAggregatesFilter? product_id,
    Input$StringWithAggregatesFilter? customer_name,
    Input$StringWithAggregatesFilter? customer_phone,
    Input$IntWithAggregatesFilter? city_id,
    Input$StringWithAggregatesFilter? address,
    Input$IntWithAggregatesFilter? quantity,
    Input$DateTimeWithAggregatesFilter? date,
    Input$FloatWithAggregatesFilter? remainingPayement,
    Input$FloatWithAggregatesFilter? totalPayement,
    Input$IntWithAggregatesFilter? transaction_type_id,
    Input$IntWithAggregatesFilter? status_id,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get seller_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get product_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_name =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get customer_phone =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get city_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$StringWithAggregatesFilter<TRes> get address =>
      CopyWith$Input$StringWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get quantity =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$DateTimeWithAggregatesFilter<TRes> get date =>
      CopyWith$Input$DateTimeWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get remainingPayement =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$FloatWithAggregatesFilter<TRes> get totalPayement =>
      CopyWith$Input$FloatWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get transaction_type_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
  CopyWith$Input$IntWithAggregatesFilter<TRes> get status_id =>
      CopyWith$Input$IntWithAggregatesFilter.stub(_res);
}

class Input$DateTimeWithAggregatesFilter {
  factory Input$DateTimeWithAggregatesFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  }) =>
      Input$DateTimeWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$DateTimeWithAggregatesFilter._(this._$data);

  factory Input$DateTimeWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    return Input$DateTimeWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedDateTimeFilter? get $_min =>
      (_$data['_min'] as Input$NestedDateTimeFilter?);
  Input$NestedDateTimeFilter? get $_max =>
      (_$data['_max'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$DateTimeWithAggregatesFilter<
          Input$DateTimeWithAggregatesFilter>
      get copyWith => CopyWith$Input$DateTimeWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  factory CopyWith$Input$DateTimeWithAggregatesFilter(
    Input$DateTimeWithAggregatesFilter instance,
    TRes Function(Input$DateTimeWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$DateTimeWithAggregatesFilter;

  factory CopyWith$Input$DateTimeWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  });
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$DateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$DateTimeWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$DateTimeWithAggregatesFilter _instance;

  final TRes Function(Input$DateTimeWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$DateTimeWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedDateTimeFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$DateTimeWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$DateTimeWithAggregatesFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$NestedDateTimeWithAggregatesFilter {
  factory Input$NestedDateTimeWithAggregatesFilter({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  }) =>
      Input$NestedDateTimeWithAggregatesFilter._({
        if (equals != null) r'equals': equals,
        if ($in != null) r'in': $in,
        if (notIn != null) r'notIn': notIn,
        if (lt != null) r'lt': lt,
        if (lte != null) r'lte': lte,
        if (gt != null) r'gt': gt,
        if (gte != null) r'gte': gte,
        if (not != null) r'not': not,
        if ($_count != null) r'_count': $_count,
        if ($_min != null) r'_min': $_min,
        if ($_max != null) r'_max': $_max,
      });

  Input$NestedDateTimeWithAggregatesFilter._(this._$data);

  factory Input$NestedDateTimeWithAggregatesFilter.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('equals')) {
      final l$equals = data['equals'];
      result$data['equals'] = (l$equals as String?);
    }
    if (data.containsKey('in')) {
      final l$$in = data['in'];
      result$data['in'] =
          (l$$in as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('notIn')) {
      final l$notIn = data['notIn'];
      result$data['notIn'] =
          (l$notIn as List<dynamic>?)?.map((e) => (e as String)).toList();
    }
    if (data.containsKey('lt')) {
      final l$lt = data['lt'];
      result$data['lt'] = (l$lt as String?);
    }
    if (data.containsKey('lte')) {
      final l$lte = data['lte'];
      result$data['lte'] = (l$lte as String?);
    }
    if (data.containsKey('gt')) {
      final l$gt = data['gt'];
      result$data['gt'] = (l$gt as String?);
    }
    if (data.containsKey('gte')) {
      final l$gte = data['gte'];
      result$data['gte'] = (l$gte as String?);
    }
    if (data.containsKey('not')) {
      final l$not = data['not'];
      result$data['not'] = l$not == null
          ? null
          : Input$NestedDateTimeWithAggregatesFilter.fromJson(
              (l$not as Map<String, dynamic>));
    }
    if (data.containsKey('_count')) {
      final l$$_count = data['_count'];
      result$data['_count'] = l$$_count == null
          ? null
          : Input$NestedIntFilter.fromJson((l$$_count as Map<String, dynamic>));
    }
    if (data.containsKey('_min')) {
      final l$$_min = data['_min'];
      result$data['_min'] = l$$_min == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_min as Map<String, dynamic>));
    }
    if (data.containsKey('_max')) {
      final l$$_max = data['_max'];
      result$data['_max'] = l$$_max == null
          ? null
          : Input$NestedDateTimeFilter.fromJson(
              (l$$_max as Map<String, dynamic>));
    }
    return Input$NestedDateTimeWithAggregatesFilter._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get equals => (_$data['equals'] as String?);
  List<String>? get $in => (_$data['in'] as List<String>?);
  List<String>? get notIn => (_$data['notIn'] as List<String>?);
  String? get lt => (_$data['lt'] as String?);
  String? get lte => (_$data['lte'] as String?);
  String? get gt => (_$data['gt'] as String?);
  String? get gte => (_$data['gte'] as String?);
  Input$NestedDateTimeWithAggregatesFilter? get not =>
      (_$data['not'] as Input$NestedDateTimeWithAggregatesFilter?);
  Input$NestedIntFilter? get $_count =>
      (_$data['_count'] as Input$NestedIntFilter?);
  Input$NestedDateTimeFilter? get $_min =>
      (_$data['_min'] as Input$NestedDateTimeFilter?);
  Input$NestedDateTimeFilter? get $_max =>
      (_$data['_max'] as Input$NestedDateTimeFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('equals')) {
      final l$equals = equals;
      result$data['equals'] = l$equals;
    }
    if (_$data.containsKey('in')) {
      final l$$in = $in;
      result$data['in'] = l$$in?.map((e) => e).toList();
    }
    if (_$data.containsKey('notIn')) {
      final l$notIn = notIn;
      result$data['notIn'] = l$notIn?.map((e) => e).toList();
    }
    if (_$data.containsKey('lt')) {
      final l$lt = lt;
      result$data['lt'] = l$lt;
    }
    if (_$data.containsKey('lte')) {
      final l$lte = lte;
      result$data['lte'] = l$lte;
    }
    if (_$data.containsKey('gt')) {
      final l$gt = gt;
      result$data['gt'] = l$gt;
    }
    if (_$data.containsKey('gte')) {
      final l$gte = gte;
      result$data['gte'] = l$gte;
    }
    if (_$data.containsKey('not')) {
      final l$not = not;
      result$data['not'] = l$not?.toJson();
    }
    if (_$data.containsKey('_count')) {
      final l$$_count = $_count;
      result$data['_count'] = l$$_count?.toJson();
    }
    if (_$data.containsKey('_min')) {
      final l$$_min = $_min;
      result$data['_min'] = l$$_min?.toJson();
    }
    if (_$data.containsKey('_max')) {
      final l$$_max = $_max;
      result$data['_max'] = l$$_max?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$NestedDateTimeWithAggregatesFilter<
          Input$NestedDateTimeWithAggregatesFilter>
      get copyWith => CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$NestedDateTimeWithAggregatesFilter) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$equals = equals;
    final lOther$equals = other.equals;
    if (_$data.containsKey('equals') != other._$data.containsKey('equals')) {
      return false;
    }
    if (l$equals != lOther$equals) {
      return false;
    }
    final l$$in = $in;
    final lOther$$in = other.$in;
    if (_$data.containsKey('in') != other._$data.containsKey('in')) {
      return false;
    }
    if (l$$in != null && lOther$$in != null) {
      if (l$$in.length != lOther$$in.length) {
        return false;
      }
      for (int i = 0; i < l$$in.length; i++) {
        final l$$in$entry = l$$in[i];
        final lOther$$in$entry = lOther$$in[i];
        if (l$$in$entry != lOther$$in$entry) {
          return false;
        }
      }
    } else if (l$$in != lOther$$in) {
      return false;
    }
    final l$notIn = notIn;
    final lOther$notIn = other.notIn;
    if (_$data.containsKey('notIn') != other._$data.containsKey('notIn')) {
      return false;
    }
    if (l$notIn != null && lOther$notIn != null) {
      if (l$notIn.length != lOther$notIn.length) {
        return false;
      }
      for (int i = 0; i < l$notIn.length; i++) {
        final l$notIn$entry = l$notIn[i];
        final lOther$notIn$entry = lOther$notIn[i];
        if (l$notIn$entry != lOther$notIn$entry) {
          return false;
        }
      }
    } else if (l$notIn != lOther$notIn) {
      return false;
    }
    final l$lt = lt;
    final lOther$lt = other.lt;
    if (_$data.containsKey('lt') != other._$data.containsKey('lt')) {
      return false;
    }
    if (l$lt != lOther$lt) {
      return false;
    }
    final l$lte = lte;
    final lOther$lte = other.lte;
    if (_$data.containsKey('lte') != other._$data.containsKey('lte')) {
      return false;
    }
    if (l$lte != lOther$lte) {
      return false;
    }
    final l$gt = gt;
    final lOther$gt = other.gt;
    if (_$data.containsKey('gt') != other._$data.containsKey('gt')) {
      return false;
    }
    if (l$gt != lOther$gt) {
      return false;
    }
    final l$gte = gte;
    final lOther$gte = other.gte;
    if (_$data.containsKey('gte') != other._$data.containsKey('gte')) {
      return false;
    }
    if (l$gte != lOther$gte) {
      return false;
    }
    final l$not = not;
    final lOther$not = other.not;
    if (_$data.containsKey('not') != other._$data.containsKey('not')) {
      return false;
    }
    if (l$not != lOther$not) {
      return false;
    }
    final l$$_count = $_count;
    final lOther$$_count = other.$_count;
    if (_$data.containsKey('_count') != other._$data.containsKey('_count')) {
      return false;
    }
    if (l$$_count != lOther$$_count) {
      return false;
    }
    final l$$_min = $_min;
    final lOther$$_min = other.$_min;
    if (_$data.containsKey('_min') != other._$data.containsKey('_min')) {
      return false;
    }
    if (l$$_min != lOther$$_min) {
      return false;
    }
    final l$$_max = $_max;
    final lOther$$_max = other.$_max;
    if (_$data.containsKey('_max') != other._$data.containsKey('_max')) {
      return false;
    }
    if (l$$_max != lOther$$_max) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$equals = equals;
    final l$$in = $in;
    final l$notIn = notIn;
    final l$lt = lt;
    final l$lte = lte;
    final l$gt = gt;
    final l$gte = gte;
    final l$not = not;
    final l$$_count = $_count;
    final l$$_min = $_min;
    final l$$_max = $_max;
    return Object.hashAll([
      _$data.containsKey('equals') ? l$equals : const {},
      _$data.containsKey('in')
          ? l$$in == null
              ? null
              : Object.hashAll(l$$in.map((v) => v))
          : const {},
      _$data.containsKey('notIn')
          ? l$notIn == null
              ? null
              : Object.hashAll(l$notIn.map((v) => v))
          : const {},
      _$data.containsKey('lt') ? l$lt : const {},
      _$data.containsKey('lte') ? l$lte : const {},
      _$data.containsKey('gt') ? l$gt : const {},
      _$data.containsKey('gte') ? l$gte : const {},
      _$data.containsKey('not') ? l$not : const {},
      _$data.containsKey('_count') ? l$$_count : const {},
      _$data.containsKey('_min') ? l$$_min : const {},
      _$data.containsKey('_max') ? l$$_max : const {},
    ]);
  }
}

abstract class CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  factory CopyWith$Input$NestedDateTimeWithAggregatesFilter(
    Input$NestedDateTimeWithAggregatesFilter instance,
    TRes Function(Input$NestedDateTimeWithAggregatesFilter) then,
  ) = _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter;

  factory CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(TRes res) =
      _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter;

  TRes call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  });
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not;
  CopyWith$Input$NestedIntFilter<TRes> get $_count;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min;
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max;
}

class _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  _CopyWithImpl$Input$NestedDateTimeWithAggregatesFilter(
    this._instance,
    this._then,
  );

  final Input$NestedDateTimeWithAggregatesFilter _instance;

  final TRes Function(Input$NestedDateTimeWithAggregatesFilter) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? equals = _undefined,
    Object? $in = _undefined,
    Object? notIn = _undefined,
    Object? lt = _undefined,
    Object? lte = _undefined,
    Object? gt = _undefined,
    Object? gte = _undefined,
    Object? not = _undefined,
    Object? $_count = _undefined,
    Object? $_min = _undefined,
    Object? $_max = _undefined,
  }) =>
      _then(Input$NestedDateTimeWithAggregatesFilter._({
        ..._instance._$data,
        if (equals != _undefined) 'equals': (equals as String?),
        if ($in != _undefined) 'in': ($in as List<String>?),
        if (notIn != _undefined) 'notIn': (notIn as List<String>?),
        if (lt != _undefined) 'lt': (lt as String?),
        if (lte != _undefined) 'lte': (lte as String?),
        if (gt != _undefined) 'gt': (gt as String?),
        if (gte != _undefined) 'gte': (gte as String?),
        if (not != _undefined)
          'not': (not as Input$NestedDateTimeWithAggregatesFilter?),
        if ($_count != _undefined)
          '_count': ($_count as Input$NestedIntFilter?),
        if ($_min != _undefined) '_min': ($_min as Input$NestedDateTimeFilter?),
        if ($_max != _undefined) '_max': ($_max as Input$NestedDateTimeFilter?),
      }));
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not {
    final local$not = _instance.not;
    return local$not == null
        ? CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(
            _then(_instance))
        : CopyWith$Input$NestedDateTimeWithAggregatesFilter(
            local$not, (e) => call(not: e));
  }

  CopyWith$Input$NestedIntFilter<TRes> get $_count {
    final local$$_count = _instance.$_count;
    return local$$_count == null
        ? CopyWith$Input$NestedIntFilter.stub(_then(_instance))
        : CopyWith$Input$NestedIntFilter(
            local$$_count, (e) => call($_count: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min {
    final local$$_min = _instance.$_min;
    return local$$_min == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_min, (e) => call($_min: e));
  }

  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max {
    final local$$_max = _instance.$_max;
    return local$$_max == null
        ? CopyWith$Input$NestedDateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$NestedDateTimeFilter(
            local$$_max, (e) => call($_max: e));
  }
}

class _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter<TRes>
    implements CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> {
  _CopyWithStubImpl$Input$NestedDateTimeWithAggregatesFilter(this._res);

  TRes _res;

  call({
    String? equals,
    List<String>? $in,
    List<String>? notIn,
    String? lt,
    String? lte,
    String? gt,
    String? gte,
    Input$NestedDateTimeWithAggregatesFilter? not,
    Input$NestedIntFilter? $_count,
    Input$NestedDateTimeFilter? $_min,
    Input$NestedDateTimeFilter? $_max,
  }) =>
      _res;
  CopyWith$Input$NestedDateTimeWithAggregatesFilter<TRes> get not =>
      CopyWith$Input$NestedDateTimeWithAggregatesFilter.stub(_res);
  CopyWith$Input$NestedIntFilter<TRes> get $_count =>
      CopyWith$Input$NestedIntFilter.stub(_res);
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_min =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
  CopyWith$Input$NestedDateTimeFilter<TRes> get $_max =>
      CopyWith$Input$NestedDateTimeFilter.stub(_res);
}

class Input$CityCreateInput {
  factory Input$CityCreateInput({
    required int city_id,
    required String city_name,
    Input$TransactionsCreateNestedManyWithoutCityInput? Transactions,
  }) =>
      Input$CityCreateInput._({
        r'city_id': city_id,
        r'city_name': city_name,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$CityCreateInput._(this._$data);

  factory Input$CityCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$city_id = data['city_id'];
    result$data['city_id'] = (l$city_id as int);
    final l$city_name = data['city_name'];
    result$data['city_name'] = (l$city_name as String);
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsCreateNestedManyWithoutCityInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$CityCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get city_id => (_$data['city_id'] as int);
  String get city_name => (_$data['city_name'] as String);
  Input$TransactionsCreateNestedManyWithoutCityInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsCreateNestedManyWithoutCityInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$city_id = city_id;
    result$data['city_id'] = l$city_id;
    final l$city_name = city_name;
    result$data['city_name'] = l$city_name;
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityCreateInput<Input$CityCreateInput> get copyWith =>
      CopyWith$Input$CityCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityCreateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (l$city_name != lOther$city_name) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    final l$Transactions = Transactions;
    return Object.hashAll([
      l$city_id,
      l$city_name,
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityCreateInput<TRes> {
  factory CopyWith$Input$CityCreateInput(
    Input$CityCreateInput instance,
    TRes Function(Input$CityCreateInput) then,
  ) = _CopyWithImpl$Input$CityCreateInput;

  factory CopyWith$Input$CityCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityCreateInput;

  TRes call({
    int? city_id,
    String? city_name,
    Input$TransactionsCreateNestedManyWithoutCityInput? Transactions,
  });
  CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$CityCreateInput<TRes>
    implements CopyWith$Input$CityCreateInput<TRes> {
  _CopyWithImpl$Input$CityCreateInput(
    this._instance,
    this._then,
  );

  final Input$CityCreateInput _instance;

  final TRes Function(Input$CityCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$CityCreateInput._({
        ..._instance._$data,
        if (city_id != _undefined && city_id != null)
          'city_id': (city_id as int),
        if (city_name != _undefined && city_name != null)
          'city_name': (city_name as String),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsCreateNestedManyWithoutCityInput?),
      }));
  CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$CityCreateInput<TRes>
    implements CopyWith$Input$CityCreateInput<TRes> {
  _CopyWithStubImpl$Input$CityCreateInput(this._res);

  TRes _res;

  call({
    int? city_id,
    String? city_name,
    Input$TransactionsCreateNestedManyWithoutCityInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput.stub(
              _res);
}

class Input$TransactionsCreateNestedManyWithoutCityInput {
  factory Input$TransactionsCreateNestedManyWithoutCityInput({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      Input$TransactionsCreateNestedManyWithoutCityInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionsCreateNestedManyWithoutCityInput._(this._$data);

  factory Input$TransactionsCreateNestedManyWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutCityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutCityInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsCreateNestedManyWithoutCityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutCityInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutCityInput>?);
  List<Input$TransactionsCreateOrConnectWithoutCityInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutCityInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<
          Input$TransactionsCreateNestedManyWithoutCityInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateNestedManyWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput(
    Input$TransactionsCreateNestedManyWithoutCityInput instance,
    TRes Function(Input$TransactionsCreateNestedManyWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutCityInput;

  factory CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutCityInput;

  TRes call({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutCityInput<
                      Input$TransactionsCreateWithoutCityInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
                      Input$TransactionsCreateOrConnectWithoutCityInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutCityInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateNestedManyWithoutCityInput _instance;

  final TRes Function(Input$TransactionsCreateNestedManyWithoutCityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionsCreateNestedManyWithoutCityInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$TransactionsCreateWithoutCityInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutCityInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutCityInput<
                          Input$TransactionsCreateWithoutCityInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutCityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
                          Input$TransactionsCreateOrConnectWithoutCityInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutCityInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutCityInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$TransactionsCreateWithoutCityInput {
  factory Input$TransactionsCreateWithoutCityInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$SellersCreateNestedOneWithoutTransactionsInput seller,
    required Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      Input$TransactionsCreateWithoutCityInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'seller': seller,
        r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsCreateWithoutCityInput._(this._$data);

  factory Input$TransactionsCreateWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$seller = data['seller'];
    result$data['seller'] =
        Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$seller as Map<String, dynamic>));
    final l$transaction_type = data['transaction_type'];
    result$data['transaction_type'] =
        Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$transaction_type as Map<String, dynamic>));
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsCreateWithoutCityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$SellersCreateNestedOneWithoutTransactionsInput get seller =>
      (_$data['seller']
          as Input$SellersCreateNestedOneWithoutTransactionsInput);
  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput);
  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? get status =>
      (_$data['status']
          as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?);
  Input$PayementsCreateNestedManyWithoutTransactionInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsCreateNestedManyWithoutTransactionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$seller = seller;
    result$data['seller'] = l$seller.toJson();
    final l$transaction_type = transaction_type;
    result$data['transaction_type'] = l$transaction_type.toJson();
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateWithoutCityInput<
          Input$TransactionsCreateWithoutCityInput>
      get copyWith => CopyWith$Input$TransactionsCreateWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$seller,
      l$transaction_type,
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> {
  factory CopyWith$Input$TransactionsCreateWithoutCityInput(
    Input$TransactionsCreateWithoutCityInput instance,
    TRes Function(Input$TransactionsCreateWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateWithoutCityInput;

  factory CopyWith$Input$TransactionsCreateWithoutCityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateWithoutCityInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  });
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller;
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type;
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status;
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsCreateWithoutCityInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateWithoutCityInput _instance;

  final TRes Function(Input$TransactionsCreateWithoutCityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsCreateWithoutCityInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (seller != _undefined && seller != null)
          'seller':
              (seller as Input$SellersCreateNestedOneWithoutTransactionsInput),
        if (transaction_type != _undefined && transaction_type != null)
          'transaction_type': (transaction_type
              as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsCreateNestedManyWithoutTransactionInput?),
      }));
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
        local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
        local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateWithoutCityInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateWithoutCityInput(this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      _res;
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
              _res);
}

class Input$SellersCreateNestedOneWithoutTransactionsInput {
  factory Input$SellersCreateNestedOneWithoutTransactionsInput({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersWhereUniqueInput? connect,
  }) =>
      Input$SellersCreateNestedOneWithoutTransactionsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$SellersCreateNestedOneWithoutTransactionsInput._(this._$data);

  factory Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$SellersCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$SellersCreateOrConnectWithoutTransactionsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$SellersWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$SellersCreateNestedOneWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SellersCreateWithoutTransactionsInput? get create =>
      (_$data['create'] as Input$SellersCreateWithoutTransactionsInput?);
  Input$SellersCreateOrConnectWithoutTransactionsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$SellersCreateOrConnectWithoutTransactionsInput?);
  Input$SellersWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$SellersWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<
          Input$SellersCreateNestedOneWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersCreateNestedOneWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
    Input$SellersCreateNestedOneWithoutTransactionsInput instance,
    TRes Function(Input$SellersCreateNestedOneWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$SellersCreateNestedOneWithoutTransactionsInput;

  factory CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SellersCreateNestedOneWithoutTransactionsInput;

  TRes call({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersWhereUniqueInput? connect,
  });
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create;
  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$SellersCreateNestedOneWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$SellersCreateNestedOneWithoutTransactionsInput _instance;

  final TRes Function(Input$SellersCreateNestedOneWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$SellersCreateNestedOneWithoutTransactionsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$SellersCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$SellersCreateOrConnectWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$SellersWhereUniqueInput?),
      }));
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$SellersWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$SellersWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$SellersCreateNestedOneWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$SellersCreateNestedOneWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$SellersWhereUniqueInput.stub(_res);
}

class Input$SellersCreateWithoutTransactionsInput {
  factory Input$SellersCreateWithoutTransactionsInput({
    required String seller_name,
    required String seller_phone,
    required String picture,
  }) =>
      Input$SellersCreateWithoutTransactionsInput._({
        r'seller_name': seller_name,
        r'seller_phone': seller_phone,
        r'picture': picture,
      });

  Input$SellersCreateWithoutTransactionsInput._(this._$data);

  factory Input$SellersCreateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$seller_name = data['seller_name'];
    result$data['seller_name'] = (l$seller_name as String);
    final l$seller_phone = data['seller_phone'];
    result$data['seller_phone'] = (l$seller_phone as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    return Input$SellersCreateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get seller_name => (_$data['seller_name'] as String);
  String get seller_phone => (_$data['seller_phone'] as String);
  String get picture => (_$data['picture'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$seller_name = seller_name;
    result$data['seller_name'] = l$seller_name;
    final l$seller_phone = seller_phone;
    result$data['seller_phone'] = l$seller_phone;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    return result$data;
  }

  CopyWith$Input$SellersCreateWithoutTransactionsInput<
          Input$SellersCreateWithoutTransactionsInput>
      get copyWith => CopyWith$Input$SellersCreateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersCreateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      l$seller_name,
      l$seller_phone,
      l$picture,
    ]);
  }
}

abstract class CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$SellersCreateWithoutTransactionsInput(
    Input$SellersCreateWithoutTransactionsInput instance,
    TRes Function(Input$SellersCreateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$SellersCreateWithoutTransactionsInput;

  factory CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersCreateWithoutTransactionsInput;

  TRes call({
    String? seller_name,
    String? seller_phone,
    String? picture,
  });
}

class _CopyWithImpl$Input$SellersCreateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$SellersCreateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$SellersCreateWithoutTransactionsInput _instance;

  final TRes Function(Input$SellersCreateWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersCreateWithoutTransactionsInput._({
        ..._instance._$data,
        if (seller_name != _undefined && seller_name != null)
          'seller_name': (seller_name as String),
        if (seller_phone != _undefined && seller_phone != null)
          'seller_phone': (seller_phone as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
      }));
}

class _CopyWithStubImpl$Input$SellersCreateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$SellersCreateWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    String? seller_name,
    String? seller_phone,
    String? picture,
  }) =>
      _res;
}

class Input$SellersCreateOrConnectWithoutTransactionsInput {
  factory Input$SellersCreateOrConnectWithoutTransactionsInput({
    required Input$SellersWhereUniqueInput where,
    required Input$SellersCreateWithoutTransactionsInput create,
  }) =>
      Input$SellersCreateOrConnectWithoutTransactionsInput._({
        r'where': where,
        r'create': create,
      });

  Input$SellersCreateOrConnectWithoutTransactionsInput._(this._$data);

  factory Input$SellersCreateOrConnectWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$SellersWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$SellersCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$SellersCreateOrConnectWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SellersWhereUniqueInput get where =>
      (_$data['where'] as Input$SellersWhereUniqueInput);
  Input$SellersCreateWithoutTransactionsInput get create =>
      (_$data['create'] as Input$SellersCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<
          Input$SellersCreateOrConnectWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersCreateOrConnectWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput(
    Input$SellersCreateOrConnectWithoutTransactionsInput instance,
    TRes Function(Input$SellersCreateOrConnectWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$SellersCreateOrConnectWithoutTransactionsInput;

  factory CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SellersCreateOrConnectWithoutTransactionsInput;

  TRes call({
    Input$SellersWhereUniqueInput? where,
    Input$SellersCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$SellersWhereUniqueInput<TRes> get where;
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create;
}

class _CopyWithImpl$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$SellersCreateOrConnectWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$SellersCreateOrConnectWithoutTransactionsInput _instance;

  final TRes Function(Input$SellersCreateOrConnectWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$SellersCreateOrConnectWithoutTransactionsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$SellersWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$SellersCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$SellersWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$SellersWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$SellersCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$SellersCreateOrConnectWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$SellersCreateOrConnectWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$SellersWhereUniqueInput? where,
    Input$SellersCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$SellersWhereUniqueInput<TRes> get where =>
      CopyWith$Input$SellersWhereUniqueInput.stub(_res);
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(_res);
}

class Input$TransactionTypesCreateNestedOneWithoutTransactionsInput {
  factory Input$TransactionTypesCreateNestedOneWithoutTransactionsInput({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesWhereUniqueInput? connect,
  }) =>
      Input$TransactionTypesCreateNestedOneWithoutTransactionsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput._(this._$data);

  factory Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionTypesCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionTypesWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$TransactionTypesCreateNestedOneWithoutTransactionsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionTypesCreateWithoutTransactionsInput? get create =>
      (_$data['create']
          as Input$TransactionTypesCreateWithoutTransactionsInput?);
  Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?);
  Input$TransactionTypesWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionTypesWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
          Input$TransactionTypesCreateNestedOneWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionTypesCreateNestedOneWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput instance,
    TRes Function(Input$TransactionTypesCreateNestedOneWithoutTransactionsInput)
        then,
  ) = _CopyWithImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput;

  factory CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput;

  TRes call({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesWhereUniqueInput? connect,
  });
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create;
  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
            TRes> {
  _CopyWithImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesCreateNestedOneWithoutTransactionsInput _instance;

  final TRes Function(
      Input$TransactionTypesCreateNestedOneWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionTypesCreateNestedOneWithoutTransactionsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as Input$TransactionTypesCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionTypesWhereUniqueInput?),
      }));
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionTypesWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$TransactionTypesWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionTypesWhereUniqueInput.stub(_res);
}

class Input$TransactionTypesCreateWithoutTransactionsInput {
  factory Input$TransactionTypesCreateWithoutTransactionsInput({
    required String type_name,
    required String description,
  }) =>
      Input$TransactionTypesCreateWithoutTransactionsInput._({
        r'type_name': type_name,
        r'description': description,
      });

  Input$TransactionTypesCreateWithoutTransactionsInput._(this._$data);

  factory Input$TransactionTypesCreateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$type_name = data['type_name'];
    result$data['type_name'] = (l$type_name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$TransactionTypesCreateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get type_name => (_$data['type_name'] as String);
  String get description => (_$data['description'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$type_name = type_name;
    result$data['type_name'] = l$type_name;
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<
          Input$TransactionTypesCreateWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesCreateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      l$type_name,
      l$description,
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
    Input$TransactionTypesCreateWithoutTransactionsInput instance,
    TRes Function(Input$TransactionTypesCreateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesCreateWithoutTransactionsInput;

  factory CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesCreateWithoutTransactionsInput;

  TRes call({
    String? type_name,
    String? description,
  });
}

class _CopyWithImpl$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesCreateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesCreateWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionTypesCreateWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesCreateWithoutTransactionsInput._({
        ..._instance._$data,
        if (type_name != _undefined && type_name != null)
          'type_name': (type_name as String),
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$TransactionTypesCreateWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesCreateWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    String? type_name,
    String? description,
  }) =>
      _res;
}

class Input$TransactionTypesCreateOrConnectWithoutTransactionsInput {
  factory Input$TransactionTypesCreateOrConnectWithoutTransactionsInput({
    required Input$TransactionTypesWhereUniqueInput where,
    required Input$TransactionTypesCreateWithoutTransactionsInput create,
  }) =>
      Input$TransactionTypesCreateOrConnectWithoutTransactionsInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionTypesCreateOrConnectWithoutTransactionsInput._(this._$data);

  factory Input$TransactionTypesCreateOrConnectWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionTypesWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionTypesCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionTypesCreateOrConnectWithoutTransactionsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionTypesWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionTypesWhereUniqueInput);
  Input$TransactionTypesCreateWithoutTransactionsInput get create =>
      (_$data['create']
          as Input$TransactionTypesCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
          Input$TransactionTypesCreateOrConnectWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionTypesCreateOrConnectWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput instance,
    TRes Function(Input$TransactionTypesCreateOrConnectWithoutTransactionsInput)
        then,
  ) = _CopyWithImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput;

  factory CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput;

  TRes call({
    Input$TransactionTypesWhereUniqueInput? where,
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
            TRes> {
  _CopyWithImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesCreateOrConnectWithoutTransactionsInput _instance;

  final TRes Function(
      Input$TransactionTypesCreateOrConnectWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionTypesCreateOrConnectWithoutTransactionsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionTypesWhereUniqueInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionTypesCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionTypesWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionTypesWhereUniqueInput? where,
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionTypesWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
              _res);
}

class Input$TransactionStatusCreateNestedOneWithoutTransactionsInput {
  factory Input$TransactionStatusCreateNestedOneWithoutTransactionsInput({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusWhereUniqueInput? connect,
  }) =>
      Input$TransactionStatusCreateNestedOneWithoutTransactionsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput._(this._$data);

  factory Input$TransactionStatusCreateNestedOneWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionStatusCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionStatusWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$TransactionStatusCreateNestedOneWithoutTransactionsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionStatusCreateWithoutTransactionsInput? get create =>
      (_$data['create']
          as Input$TransactionStatusCreateWithoutTransactionsInput?);
  Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?);
  Input$TransactionStatusWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionStatusWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
          Input$TransactionStatusCreateNestedOneWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionStatusCreateNestedOneWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput instance,
    TRes Function(
            Input$TransactionStatusCreateNestedOneWithoutTransactionsInput)
        then,
  ) = _CopyWithImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput;

  factory CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput;

  TRes call({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusWhereUniqueInput? connect,
  });
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create;
  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
            TRes> {
  _CopyWithImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
      _instance;

  final TRes Function(
      Input$TransactionStatusCreateNestedOneWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionStatusCreateNestedOneWithoutTransactionsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as Input$TransactionStatusCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionStatusWhereUniqueInput?),
      }));
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionStatusWhereUniqueInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionStatusWhereUniqueInput.stub(_res);
}

class Input$TransactionStatusCreateWithoutTransactionsInput {
  factory Input$TransactionStatusCreateWithoutTransactionsInput({
    required String name,
    required String description,
  }) =>
      Input$TransactionStatusCreateWithoutTransactionsInput._({
        r'name': name,
        r'description': description,
      });

  Input$TransactionStatusCreateWithoutTransactionsInput._(this._$data);

  factory Input$TransactionStatusCreateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    return Input$TransactionStatusCreateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get description => (_$data['description'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$description = description;
    result$data['description'] = l$description;
    return result$data;
  }

  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<
          Input$TransactionStatusCreateWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusCreateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      l$name,
      l$description,
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
    Input$TransactionStatusCreateWithoutTransactionsInput instance,
    TRes Function(Input$TransactionStatusCreateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusCreateWithoutTransactionsInput;

  factory CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusCreateWithoutTransactionsInput;

  TRes call({
    String? name,
    String? description,
  });
}

class _CopyWithImpl$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusCreateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusCreateWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionStatusCreateWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusCreateWithoutTransactionsInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined && description != null)
          'description': (description as String),
      }));
}

class _CopyWithStubImpl$Input$TransactionStatusCreateWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusCreateWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    String? name,
    String? description,
  }) =>
      _res;
}

class Input$TransactionStatusCreateOrConnectWithoutTransactionsInput {
  factory Input$TransactionStatusCreateOrConnectWithoutTransactionsInput({
    required Input$TransactionStatusWhereUniqueInput where,
    required Input$TransactionStatusCreateWithoutTransactionsInput create,
  }) =>
      Input$TransactionStatusCreateOrConnectWithoutTransactionsInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionStatusCreateOrConnectWithoutTransactionsInput._(this._$data);

  factory Input$TransactionStatusCreateOrConnectWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionStatusWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionStatusCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionStatusCreateOrConnectWithoutTransactionsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionStatusWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionStatusWhereUniqueInput);
  Input$TransactionStatusCreateWithoutTransactionsInput get create =>
      (_$data['create']
          as Input$TransactionStatusCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
          Input$TransactionStatusCreateOrConnectWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionStatusCreateOrConnectWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput instance,
    TRes Function(
            Input$TransactionStatusCreateOrConnectWithoutTransactionsInput)
        then,
  ) = _CopyWithImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput;

  factory CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput;

  TRes call({
    Input$TransactionStatusWhereUniqueInput? where,
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
            TRes> {
  _CopyWithImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
      _instance;

  final TRes Function(
      Input$TransactionStatusCreateOrConnectWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionStatusCreateOrConnectWithoutTransactionsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionStatusWhereUniqueInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionStatusCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionStatusWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionStatusWhereUniqueInput? where,
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionStatusWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
              _res);
}

class Input$PayementsCreateNestedManyWithoutTransactionInput {
  factory Input$PayementsCreateNestedManyWithoutTransactionInput({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsWhereUniqueInput>? connect,
  }) =>
      Input$PayementsCreateNestedManyWithoutTransactionInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$PayementsCreateNestedManyWithoutTransactionInput._(this._$data);

  factory Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$PayementsCreateWithoutTransactionInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsCreateOrConnectWithoutTransactionInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$PayementsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PayementsCreateNestedManyWithoutTransactionInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayementsCreateWithoutTransactionInput>? get create =>
      (_$data['create'] as List<Input$PayementsCreateWithoutTransactionInput>?);
  List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$PayementsCreateOrConnectWithoutTransactionInput>?);
  List<Input$PayementsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$PayementsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<
          Input$PayementsCreateNestedManyWithoutTransactionInput>
      get copyWith =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsCreateNestedManyWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<
    TRes> {
  factory CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
    Input$PayementsCreateNestedManyWithoutTransactionInput instance,
    TRes Function(Input$PayementsCreateNestedManyWithoutTransactionInput) then,
  ) = _CopyWithImpl$Input$PayementsCreateNestedManyWithoutTransactionInput;

  factory CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsCreateNestedManyWithoutTransactionInput;

  TRes call({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$PayementsCreateWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsCreateWithoutTransactionInput<
                      Input$PayementsCreateWithoutTransactionInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$PayementsCreateOrConnectWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
                      Input$PayementsCreateOrConnectWithoutTransactionInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$PayementsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereUniqueInput<
                      Input$PayementsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
    implements
        CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes> {
  _CopyWithImpl$Input$PayementsCreateNestedManyWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsCreateNestedManyWithoutTransactionInput _instance;

  final TRes Function(Input$PayementsCreateNestedManyWithoutTransactionInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$PayementsCreateNestedManyWithoutTransactionInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$PayementsCreateWithoutTransactionInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$PayementsCreateOrConnectWithoutTransactionInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$PayementsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$PayementsCreateWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsCreateWithoutTransactionInput<
                          Input$PayementsCreateWithoutTransactionInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map(
              (e) => CopyWith$Input$PayementsCreateWithoutTransactionInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$PayementsCreateOrConnectWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
                          Input$PayementsCreateOrConnectWithoutTransactionInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$PayementsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereUniqueInput<
                          Input$PayementsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$PayementsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PayementsCreateNestedManyWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes> {
  _CopyWithStubImpl$Input$PayementsCreateNestedManyWithoutTransactionInput(
      this._res);

  TRes _res;

  call({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$PayementsCreateWithoutTransactionInput {
  factory Input$PayementsCreateWithoutTransactionInput({
    required int payement_id,
    required double payement,
  }) =>
      Input$PayementsCreateWithoutTransactionInput._({
        r'payement_id': payement_id,
        r'payement': payement,
      });

  Input$PayementsCreateWithoutTransactionInput._(this._$data);

  factory Input$PayementsCreateWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$payement_id = data['payement_id'];
    result$data['payement_id'] = (l$payement_id as int);
    final l$payement = data['payement'];
    result$data['payement'] = (l$payement as num).toDouble();
    return Input$PayementsCreateWithoutTransactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get payement_id => (_$data['payement_id'] as int);
  double get payement => (_$data['payement'] as double);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$payement_id = payement_id;
    result$data['payement_id'] = l$payement_id;
    final l$payement = payement;
    result$data['payement'] = l$payement;
    return result$data;
  }

  CopyWith$Input$PayementsCreateWithoutTransactionInput<
          Input$PayementsCreateWithoutTransactionInput>
      get copyWith => CopyWith$Input$PayementsCreateWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsCreateWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$payement = payement;
    return Object.hashAll([
      l$payement_id,
      l$payement,
    ]);
  }
}

abstract class CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> {
  factory CopyWith$Input$PayementsCreateWithoutTransactionInput(
    Input$PayementsCreateWithoutTransactionInput instance,
    TRes Function(Input$PayementsCreateWithoutTransactionInput) then,
  ) = _CopyWithImpl$Input$PayementsCreateWithoutTransactionInput;

  factory CopyWith$Input$PayementsCreateWithoutTransactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsCreateWithoutTransactionInput;

  TRes call({
    int? payement_id,
    double? payement,
  });
}

class _CopyWithImpl$Input$PayementsCreateWithoutTransactionInput<TRes>
    implements CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> {
  _CopyWithImpl$Input$PayementsCreateWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsCreateWithoutTransactionInput _instance;

  final TRes Function(Input$PayementsCreateWithoutTransactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsCreateWithoutTransactionInput._({
        ..._instance._$data,
        if (payement_id != _undefined && payement_id != null)
          'payement_id': (payement_id as int),
        if (payement != _undefined && payement != null)
          'payement': (payement as double),
      }));
}

class _CopyWithStubImpl$Input$PayementsCreateWithoutTransactionInput<TRes>
    implements CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> {
  _CopyWithStubImpl$Input$PayementsCreateWithoutTransactionInput(this._res);

  TRes _res;

  call({
    int? payement_id,
    double? payement,
  }) =>
      _res;
}

class Input$PayementsCreateOrConnectWithoutTransactionInput {
  factory Input$PayementsCreateOrConnectWithoutTransactionInput({
    required Input$PayementsWhereUniqueInput where,
    required Input$PayementsCreateWithoutTransactionInput create,
  }) =>
      Input$PayementsCreateOrConnectWithoutTransactionInput._({
        r'where': where,
        r'create': create,
      });

  Input$PayementsCreateOrConnectWithoutTransactionInput._(this._$data);

  factory Input$PayementsCreateOrConnectWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$PayementsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$PayementsCreateWithoutTransactionInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$PayementsCreateOrConnectWithoutTransactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsWhereUniqueInput get where =>
      (_$data['where'] as Input$PayementsWhereUniqueInput);
  Input$PayementsCreateWithoutTransactionInput get create =>
      (_$data['create'] as Input$PayementsCreateWithoutTransactionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
          Input$PayementsCreateOrConnectWithoutTransactionInput>
      get copyWith =>
          CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsCreateOrConnectWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
    TRes> {
  factory CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput(
    Input$PayementsCreateOrConnectWithoutTransactionInput instance,
    TRes Function(Input$PayementsCreateOrConnectWithoutTransactionInput) then,
  ) = _CopyWithImpl$Input$PayementsCreateOrConnectWithoutTransactionInput;

  factory CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsCreateOrConnectWithoutTransactionInput;

  TRes call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsCreateWithoutTransactionInput? create,
  });
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where;
  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create;
}

class _CopyWithImpl$Input$PayementsCreateOrConnectWithoutTransactionInput<TRes>
    implements
        CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<TRes> {
  _CopyWithImpl$Input$PayementsCreateOrConnectWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsCreateOrConnectWithoutTransactionInput _instance;

  final TRes Function(Input$PayementsCreateOrConnectWithoutTransactionInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$PayementsCreateOrConnectWithoutTransactionInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$PayementsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$PayementsCreateWithoutTransactionInput),
      }));
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$PayementsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$PayementsCreateWithoutTransactionInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$PayementsCreateOrConnectWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<TRes> {
  _CopyWithStubImpl$Input$PayementsCreateOrConnectWithoutTransactionInput(
      this._res);

  TRes _res;

  call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsCreateWithoutTransactionInput? create,
  }) =>
      _res;
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$PayementsWhereUniqueInput.stub(_res);
  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create =>
      CopyWith$Input$PayementsCreateWithoutTransactionInput.stub(_res);
}

class Input$TransactionsCreateOrConnectWithoutCityInput {
  factory Input$TransactionsCreateOrConnectWithoutCityInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsCreateWithoutCityInput create,
  }) =>
      Input$TransactionsCreateOrConnectWithoutCityInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionsCreateOrConnectWithoutCityInput._(this._$data);

  factory Input$TransactionsCreateOrConnectWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutCityInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsCreateOrConnectWithoutCityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsCreateWithoutCityInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutCityInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
          Input$TransactionsCreateOrConnectWithoutCityInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateOrConnectWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput(
    Input$TransactionsCreateOrConnectWithoutCityInput instance,
    TRes Function(Input$TransactionsCreateOrConnectWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutCityInput;

  factory CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutCityInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutCityInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutCityInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateOrConnectWithoutCityInput _instance;

  final TRes Function(Input$TransactionsCreateOrConnectWithoutCityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsCreateOrConnectWithoutCityInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutCityInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutCityInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutCityInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutCityInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutCityInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutCityInput.stub(_res);
}

class Input$CityUpdateManyMutationInput {
  factory Input$CityUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  }) =>
      Input$CityUpdateManyMutationInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityUpdateManyMutationInput._(this._$data);

  factory Input$CityUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$city_name as Map<String, dynamic>));
    }
    return Input$CityUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get city_id =>
      (_$data['city_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get city_name =>
      (_$data['city_name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] = l$city_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityUpdateManyMutationInput<Input$CityUpdateManyMutationInput>
      get copyWith => CopyWith$Input$CityUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$CityUpdateManyMutationInput(
    Input$CityUpdateManyMutationInput instance,
    TRes Function(Input$CityUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$CityUpdateManyMutationInput;

  factory CopyWith$Input$CityUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name;
}

class _CopyWithImpl$Input$CityUpdateManyMutationInput<TRes>
    implements CopyWith$Input$CityUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$CityUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$CityUpdateManyMutationInput _instance;

  final TRes Function(Input$CityUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityUpdateManyMutationInput._({
        ..._instance._$data,
        if (city_id != _undefined)
          'city_id': (city_id as Input$IntFieldUpdateOperationsInput?),
        if (city_name != _undefined)
          'city_name': (city_name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name {
    final local$city_name = _instance.city_name;
    return local$city_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$city_name, (e) => call(city_name: e));
  }
}

class _CopyWithStubImpl$Input$CityUpdateManyMutationInput<TRes>
    implements CopyWith$Input$CityUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$CityUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$IntFieldUpdateOperationsInput {
  factory Input$IntFieldUpdateOperationsInput({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      Input$IntFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
        if (increment != null) r'increment': increment,
        if (decrement != null) r'decrement': decrement,
        if (multiply != null) r'multiply': multiply,
        if (divide != null) r'divide': divide,
      });

  Input$IntFieldUpdateOperationsInput._(this._$data);

  factory Input$IntFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as int?);
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as int?);
    }
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as int?);
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as int?);
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as int?);
    }
    return Input$IntFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int? get $set => (_$data['set'] as int?);
  int? get increment => (_$data['increment'] as int?);
  int? get decrement => (_$data['decrement'] as int?);
  int? get multiply => (_$data['multiply'] as int?);
  int? get divide => (_$data['divide'] as int?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    return result$data;
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<
          Input$IntFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$IntFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$IntFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll([
      _$data.containsKey('set') ? l$$set : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('divide') ? l$divide : const {},
    ]);
  }
}

abstract class CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$IntFieldUpdateOperationsInput(
    Input$IntFieldUpdateOperationsInput instance,
    TRes Function(Input$IntFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$IntFieldUpdateOperationsInput;

  factory CopyWith$Input$IntFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput;

  TRes call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  });
}

class _CopyWithImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$IntFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$IntFieldUpdateOperationsInput _instance;

  final TRes Function(Input$IntFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $set = _undefined,
    Object? increment = _undefined,
    Object? decrement = _undefined,
    Object? multiply = _undefined,
    Object? divide = _undefined,
  }) =>
      _then(Input$IntFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as int?),
        if (increment != _undefined) 'increment': (increment as int?),
        if (decrement != _undefined) 'decrement': (decrement as int?),
        if (multiply != _undefined) 'multiply': (multiply as int?),
        if (divide != _undefined) 'divide': (divide as int?),
      }));
}

class _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$IntFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$IntFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    int? $set,
    int? increment,
    int? decrement,
    int? multiply,
    int? divide,
  }) =>
      _res;
}

class Input$StringFieldUpdateOperationsInput {
  factory Input$StringFieldUpdateOperationsInput({String? $set}) =>
      Input$StringFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$StringFieldUpdateOperationsInput._(this._$data);

  factory Input$StringFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$StringFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<
          Input$StringFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$StringFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$StringFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$StringFieldUpdateOperationsInput(
    Input$StringFieldUpdateOperationsInput instance,
    TRes Function(Input$StringFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$StringFieldUpdateOperationsInput;

  factory CopyWith$Input$StringFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$StringFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$StringFieldUpdateOperationsInput _instance;

  final TRes Function(Input$StringFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$StringFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$StringFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$StringFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$CityUpdateInput {
  factory Input$CityUpdateInput({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
    Input$TransactionsUpdateManyWithoutCityNestedInput? Transactions,
  }) =>
      Input$CityUpdateInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$CityUpdateInput._(this._$data);

  factory Input$CityUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$city_name as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsUpdateManyWithoutCityNestedInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$CityUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get city_id =>
      (_$data['city_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get city_name =>
      (_$data['city_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$TransactionsUpdateManyWithoutCityNestedInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsUpdateManyWithoutCityNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] = l$city_name?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityUpdateInput<Input$CityUpdateInput> get copyWith =>
      CopyWith$Input$CityUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityUpdateInput) || runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityUpdateInput<TRes> {
  factory CopyWith$Input$CityUpdateInput(
    Input$CityUpdateInput instance,
    TRes Function(Input$CityUpdateInput) then,
  ) = _CopyWithImpl$Input$CityUpdateInput;

  factory CopyWith$Input$CityUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
    Input$TransactionsUpdateManyWithoutCityNestedInput? Transactions,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name;
  CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$CityUpdateInput<TRes>
    implements CopyWith$Input$CityUpdateInput<TRes> {
  _CopyWithImpl$Input$CityUpdateInput(
    this._instance,
    this._then,
  );

  final Input$CityUpdateInput _instance;

  final TRes Function(Input$CityUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$CityUpdateInput._({
        ..._instance._$data,
        if (city_id != _undefined)
          'city_id': (city_id as Input$IntFieldUpdateOperationsInput?),
        if (city_name != _undefined)
          'city_name': (city_name as Input$StringFieldUpdateOperationsInput?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsUpdateManyWithoutCityNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name {
    final local$city_name = _instance.city_name;
    return local$city_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$city_name, (e) => call(city_name: e));
  }

  CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$CityUpdateInput<TRes>
    implements CopyWith$Input$CityUpdateInput<TRes> {
  _CopyWithStubImpl$Input$CityUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
    Input$TransactionsUpdateManyWithoutCityNestedInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateManyWithoutCityNestedInput {
  factory Input$TransactionsUpdateManyWithoutCityNestedInput({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      Input$TransactionsUpdateManyWithoutCityNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$TransactionsUpdateManyWithoutCityNestedInput._(this._$data);

  factory Input$TransactionsUpdateManyWithoutCityNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutCityInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutCityInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpsertWithWhereUniqueWithoutCityInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateWithWhereUniqueWithoutCityInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateManyWithWhereWithoutCityInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsUpdateManyWithoutCityNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutCityInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutCityInput>?);
  List<Input$TransactionsCreateOrConnectWithoutCityInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutCityInput>?);
  List<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? get upsert =>
      (_$data['upsert']
          as List<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>?);
  List<Input$TransactionsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? get update =>
      (_$data['update']
          as List<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>?);
  List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>?);
  List<Input$TransactionsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$TransactionsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<
          Input$TransactionsUpdateManyWithoutCityNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithoutCityNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput(
    Input$TransactionsUpdateManyWithoutCityNestedInput instance,
    TRes Function(Input$TransactionsUpdateManyWithoutCityNestedInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithoutCityNestedInput;

  factory CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutCityNestedInput;

  TRes call({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutCityInput<
                      Input$TransactionsCreateWithoutCityInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
                      Input$TransactionsCreateOrConnectWithoutCityInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
                      Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
                      Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<
                      Input$TransactionsUpdateManyWithWhereWithoutCityInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithoutCityNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithoutCityNestedInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithoutCityNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithoutCityNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$TransactionsCreateWithoutCityInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutCityInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$TransactionsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$TransactionsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$TransactionsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$TransactionsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutCityInput<
                          Input$TransactionsCreateWithoutCityInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutCityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput<
                          Input$TransactionsCreateOrConnectWithoutCityInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$TransactionsCreateOrConnectWithoutCityInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
                          Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
                          Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<
                          Input$TransactionsUpdateManyWithWhereWithoutCityInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutCityNestedInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutCityNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutCityInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutCityInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutCityInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$TransactionsUpsertWithWhereUniqueWithoutCityInput {
  factory Input$TransactionsUpsertWithWhereUniqueWithoutCityInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutCityInput update,
    required Input$TransactionsCreateWithoutCityInput create,
  }) =>
      Input$TransactionsUpsertWithWhereUniqueWithoutCityInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$TransactionsUpsertWithWhereUniqueWithoutCityInput._(this._$data);

  factory Input$TransactionsUpsertWithWhereUniqueWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$TransactionsUpdateWithoutCityInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutCityInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsUpsertWithWhereUniqueWithoutCityInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutCityInput get update =>
      (_$data['update'] as Input$TransactionsUpdateWithoutCityInput);
  Input$TransactionsCreateWithoutCityInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutCityInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
          Input$TransactionsUpsertWithWhereUniqueWithoutCityInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpsertWithWhereUniqueWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput(
    Input$TransactionsUpsertWithWhereUniqueWithoutCityInput instance,
    TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput;

  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutCityInput? update,
    Input$TransactionsCreateWithoutCityInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get update;
  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpsertWithWhereUniqueWithoutCityInput _instance;

  final TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutCityInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsUpsertWithWhereUniqueWithoutCityInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$TransactionsUpdateWithoutCityInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutCityInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionsUpdateWithoutCityInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutCityInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutCityInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutCityInput? update,
    Input$TransactionsCreateWithoutCityInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get update =>
      CopyWith$Input$TransactionsUpdateWithoutCityInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutCityInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutCityInput.stub(_res);
}

class Input$TransactionsUpdateWithoutCityInput {
  factory Input$TransactionsUpdateWithoutCityInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      Input$TransactionsUpdateWithoutCityInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsUpdateWithoutCityInput._(this._$data);

  factory Input$TransactionsUpdateWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateWithoutCityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? get seller =>
      (_$data['seller']
          as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
      get status => (_$data['status']
          as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$PayementsUpdateManyWithoutTransactionNestedInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsUpdateManyWithoutTransactionNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithoutCityInput<
          Input$TransactionsUpdateWithoutCityInput>
      get copyWith => CopyWith$Input$TransactionsUpdateWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateWithoutCityInput(
    Input$TransactionsUpdateWithoutCityInput instance,
    TRes Function(Input$TransactionsUpdateWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithoutCityInput;

  factory CopyWith$Input$TransactionsUpdateWithoutCityInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithoutCityInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller;
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type;
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status;
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsUpdateWithoutCityInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithoutCityInput _instance;

  final TRes Function(Input$TransactionsUpdateWithoutCityInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithoutCityInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (seller != _undefined)
          'seller': (seller
              as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsUpdateManyWithoutTransactionNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithoutCityInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithoutCityInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get status =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
              _res);
}

class Input$DateTimeFieldUpdateOperationsInput {
  factory Input$DateTimeFieldUpdateOperationsInput({String? $set}) =>
      Input$DateTimeFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
      });

  Input$DateTimeFieldUpdateOperationsInput._(this._$data);

  factory Input$DateTimeFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as String?);
    }
    return Input$DateTimeFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String? get $set => (_$data['set'] as String?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    return result$data;
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<
          Input$DateTimeFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$DateTimeFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    return Object.hashAll([_$data.containsKey('set') ? l$$set : const {}]);
  }
}

abstract class CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput(
    Input$DateTimeFieldUpdateOperationsInput instance,
    TRes Function(Input$DateTimeFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput;

  factory CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput;

  TRes call({String? $set});
}

class _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$DateTimeFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$DateTimeFieldUpdateOperationsInput _instance;

  final TRes Function(Input$DateTimeFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? $set = _undefined}) =>
      _then(Input$DateTimeFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as String?),
      }));
}

class _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$DateTimeFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({String? $set}) => _res;
}

class Input$FloatFieldUpdateOperationsInput {
  factory Input$FloatFieldUpdateOperationsInput({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  }) =>
      Input$FloatFieldUpdateOperationsInput._({
        if ($set != null) r'set': $set,
        if (increment != null) r'increment': increment,
        if (decrement != null) r'decrement': decrement,
        if (multiply != null) r'multiply': multiply,
        if (divide != null) r'divide': divide,
      });

  Input$FloatFieldUpdateOperationsInput._(this._$data);

  factory Input$FloatFieldUpdateOperationsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as num?)?.toDouble();
    }
    if (data.containsKey('increment')) {
      final l$increment = data['increment'];
      result$data['increment'] = (l$increment as num?)?.toDouble();
    }
    if (data.containsKey('decrement')) {
      final l$decrement = data['decrement'];
      result$data['decrement'] = (l$decrement as num?)?.toDouble();
    }
    if (data.containsKey('multiply')) {
      final l$multiply = data['multiply'];
      result$data['multiply'] = (l$multiply as num?)?.toDouble();
    }
    if (data.containsKey('divide')) {
      final l$divide = data['divide'];
      result$data['divide'] = (l$divide as num?)?.toDouble();
    }
    return Input$FloatFieldUpdateOperationsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  double? get $set => (_$data['set'] as double?);
  double? get increment => (_$data['increment'] as double?);
  double? get decrement => (_$data['decrement'] as double?);
  double? get multiply => (_$data['multiply'] as double?);
  double? get divide => (_$data['divide'] as double?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set;
    }
    if (_$data.containsKey('increment')) {
      final l$increment = increment;
      result$data['increment'] = l$increment;
    }
    if (_$data.containsKey('decrement')) {
      final l$decrement = decrement;
      result$data['decrement'] = l$decrement;
    }
    if (_$data.containsKey('multiply')) {
      final l$multiply = multiply;
      result$data['multiply'] = l$multiply;
    }
    if (_$data.containsKey('divide')) {
      final l$divide = divide;
      result$data['divide'] = l$divide;
    }
    return result$data;
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<
          Input$FloatFieldUpdateOperationsInput>
      get copyWith => CopyWith$Input$FloatFieldUpdateOperationsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$FloatFieldUpdateOperationsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != lOther$$set) {
      return false;
    }
    final l$increment = increment;
    final lOther$increment = other.increment;
    if (_$data.containsKey('increment') !=
        other._$data.containsKey('increment')) {
      return false;
    }
    if (l$increment != lOther$increment) {
      return false;
    }
    final l$decrement = decrement;
    final lOther$decrement = other.decrement;
    if (_$data.containsKey('decrement') !=
        other._$data.containsKey('decrement')) {
      return false;
    }
    if (l$decrement != lOther$decrement) {
      return false;
    }
    final l$multiply = multiply;
    final lOther$multiply = other.multiply;
    if (_$data.containsKey('multiply') !=
        other._$data.containsKey('multiply')) {
      return false;
    }
    if (l$multiply != lOther$multiply) {
      return false;
    }
    final l$divide = divide;
    final lOther$divide = other.divide;
    if (_$data.containsKey('divide') != other._$data.containsKey('divide')) {
      return false;
    }
    if (l$divide != lOther$divide) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$$set = $set;
    final l$increment = increment;
    final l$decrement = decrement;
    final l$multiply = multiply;
    final l$divide = divide;
    return Object.hashAll([
      _$data.containsKey('set') ? l$$set : const {},
      _$data.containsKey('increment') ? l$increment : const {},
      _$data.containsKey('decrement') ? l$decrement : const {},
      _$data.containsKey('multiply') ? l$multiply : const {},
      _$data.containsKey('divide') ? l$divide : const {},
    ]);
  }
}

abstract class CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> {
  factory CopyWith$Input$FloatFieldUpdateOperationsInput(
    Input$FloatFieldUpdateOperationsInput instance,
    TRes Function(Input$FloatFieldUpdateOperationsInput) then,
  ) = _CopyWithImpl$Input$FloatFieldUpdateOperationsInput;

  factory CopyWith$Input$FloatFieldUpdateOperationsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$FloatFieldUpdateOperationsInput;

  TRes call({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  });
}

class _CopyWithImpl$Input$FloatFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> {
  _CopyWithImpl$Input$FloatFieldUpdateOperationsInput(
    this._instance,
    this._then,
  );

  final Input$FloatFieldUpdateOperationsInput _instance;

  final TRes Function(Input$FloatFieldUpdateOperationsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? $set = _undefined,
    Object? increment = _undefined,
    Object? decrement = _undefined,
    Object? multiply = _undefined,
    Object? divide = _undefined,
  }) =>
      _then(Input$FloatFieldUpdateOperationsInput._({
        ..._instance._$data,
        if ($set != _undefined) 'set': ($set as double?),
        if (increment != _undefined) 'increment': (increment as double?),
        if (decrement != _undefined) 'decrement': (decrement as double?),
        if (multiply != _undefined) 'multiply': (multiply as double?),
        if (divide != _undefined) 'divide': (divide as double?),
      }));
}

class _CopyWithStubImpl$Input$FloatFieldUpdateOperationsInput<TRes>
    implements CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> {
  _CopyWithStubImpl$Input$FloatFieldUpdateOperationsInput(this._res);

  TRes _res;

  call({
    double? $set,
    double? increment,
    double? decrement,
    double? multiply,
    double? divide,
  }) =>
      _res;
}

class Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput {
  factory Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersUpsertWithoutTransactionsInput? upsert,
    Input$SellersWhereUniqueInput? connect,
    Input$SellersUpdateWithoutTransactionsInput? update,
  }) =>
      Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput._(this._$data);

  factory Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$SellersCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$SellersCreateOrConnectWithoutTransactionsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$SellersUpsertWithoutTransactionsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$SellersWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$SellersUpdateWithoutTransactionsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$SellersCreateWithoutTransactionsInput? get create =>
      (_$data['create'] as Input$SellersCreateWithoutTransactionsInput?);
  Input$SellersCreateOrConnectWithoutTransactionsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$SellersCreateOrConnectWithoutTransactionsInput?);
  Input$SellersUpsertWithoutTransactionsInput? get upsert =>
      (_$data['upsert'] as Input$SellersUpsertWithoutTransactionsInput?);
  Input$SellersWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$SellersWhereUniqueInput?);
  Input$SellersUpdateWithoutTransactionsInput? get update =>
      (_$data['update'] as Input$SellersUpdateWithoutTransactionsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
          Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput>
      get copyWith =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
    TRes> {
  factory CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput instance,
    TRes Function(Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput)
        then,
  ) = _CopyWithImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput;

  factory CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput;

  TRes call({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersUpsertWithoutTransactionsInput? upsert,
    Input$SellersWhereUniqueInput? connect,
    Input$SellersUpdateWithoutTransactionsInput? update,
  });
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create;
  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> get upsert;
  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect;
  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update;
}

class _CopyWithImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
    this._instance,
    this._then,
  );

  final Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput _instance;

  final TRes Function(
      Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$SellersCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$SellersCreateOrConnectWithoutTransactionsInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$SellersUpsertWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$SellersWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$SellersUpdateWithoutTransactionsInput?),
      }));
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$SellersUpsertWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersUpsertWithoutTransactionsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$SellersWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$SellersWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$SellersUpdateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$SellersUpdateWithoutTransactionsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$SellersCreateWithoutTransactionsInput? create,
    Input$SellersCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$SellersUpsertWithoutTransactionsInput? upsert,
    Input$SellersWhereUniqueInput? connect,
    Input$SellersUpdateWithoutTransactionsInput? update,
  }) =>
      _res;
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$SellersCreateOrConnectWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> get upsert =>
      CopyWith$Input$SellersUpsertWithoutTransactionsInput.stub(_res);
  CopyWith$Input$SellersWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$SellersWhereUniqueInput.stub(_res);
  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update =>
      CopyWith$Input$SellersUpdateWithoutTransactionsInput.stub(_res);
}

class Input$SellersUpsertWithoutTransactionsInput {
  factory Input$SellersUpsertWithoutTransactionsInput({
    required Input$SellersUpdateWithoutTransactionsInput update,
    required Input$SellersCreateWithoutTransactionsInput create,
  }) =>
      Input$SellersUpsertWithoutTransactionsInput._({
        r'update': update,
        r'create': create,
      });

  Input$SellersUpsertWithoutTransactionsInput._(this._$data);

  factory Input$SellersUpsertWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$SellersUpdateWithoutTransactionsInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$SellersCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$SellersUpsertWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SellersUpdateWithoutTransactionsInput get update =>
      (_$data['update'] as Input$SellersUpdateWithoutTransactionsInput);
  Input$SellersCreateWithoutTransactionsInput get create =>
      (_$data['create'] as Input$SellersCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$SellersUpsertWithoutTransactionsInput<
          Input$SellersUpsertWithoutTransactionsInput>
      get copyWith => CopyWith$Input$SellersUpsertWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersUpsertWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$SellersUpsertWithoutTransactionsInput(
    Input$SellersUpsertWithoutTransactionsInput instance,
    TRes Function(Input$SellersUpsertWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$SellersUpsertWithoutTransactionsInput;

  factory CopyWith$Input$SellersUpsertWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersUpsertWithoutTransactionsInput;

  TRes call({
    Input$SellersUpdateWithoutTransactionsInput? update,
    Input$SellersCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update;
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create;
}

class _CopyWithImpl$Input$SellersUpsertWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$SellersUpsertWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$SellersUpsertWithoutTransactionsInput _instance;

  final TRes Function(Input$SellersUpsertWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$SellersUpsertWithoutTransactionsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$SellersUpdateWithoutTransactionsInput),
        if (create != _undefined && create != null)
          'create': (create as Input$SellersCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$SellersUpdateWithoutTransactionsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$SellersCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$SellersUpsertWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersUpsertWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$SellersUpsertWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    Input$SellersUpdateWithoutTransactionsInput? update,
    Input$SellersCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> get update =>
      CopyWith$Input$SellersUpdateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$SellersCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$SellersCreateWithoutTransactionsInput.stub(_res);
}

class Input$SellersUpdateWithoutTransactionsInput {
  factory Input$SellersUpdateWithoutTransactionsInput({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      Input$SellersUpdateWithoutTransactionsInput._({
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersUpdateWithoutTransactionsInput._(this._$data);

  factory Input$SellersUpdateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_name as Map<String, dynamic>));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_phone as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    return Input$SellersUpdateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get seller_name =>
      (_$data['seller_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get seller_phone =>
      (_$data['seller_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] = l$seller_name?.toJson();
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] = l$seller_phone?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersUpdateWithoutTransactionsInput<
          Input$SellersUpdateWithoutTransactionsInput>
      get copyWith => CopyWith$Input$SellersUpdateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersUpdateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$SellersUpdateWithoutTransactionsInput(
    Input$SellersUpdateWithoutTransactionsInput instance,
    TRes Function(Input$SellersUpdateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$SellersUpdateWithoutTransactionsInput;

  factory CopyWith$Input$SellersUpdateWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersUpdateWithoutTransactionsInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
}

class _CopyWithImpl$Input$SellersUpdateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$SellersUpdateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$SellersUpdateWithoutTransactionsInput _instance;

  final TRes Function(Input$SellersUpdateWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersUpdateWithoutTransactionsInput._({
        ..._instance._$data,
        if (seller_name != _undefined)
          'seller_name':
              (seller_name as Input$StringFieldUpdateOperationsInput?),
        if (seller_phone != _undefined)
          'seller_phone':
              (seller_phone as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name {
    final local$seller_name = _instance.seller_name;
    return local$seller_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_name, (e) => call(seller_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone {
    final local$seller_phone = _instance.seller_phone;
    return local$seller_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_phone, (e) => call(seller_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }
}

class _CopyWithStubImpl$Input$SellersUpdateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$SellersUpdateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$SellersUpdateWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput {
  factory Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesUpsertWithoutTransactionsInput? upsert,
    Input$TransactionTypesWhereUniqueInput? connect,
    Input$TransactionTypesUpdateWithoutTransactionsInput? update,
  }) =>
      Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput._(
      this._$data);

  factory Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionTypesCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$TransactionTypesUpsertWithoutTransactionsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionTypesWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$TransactionTypesUpdateWithoutTransactionsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionTypesCreateWithoutTransactionsInput? get create =>
      (_$data['create']
          as Input$TransactionTypesCreateWithoutTransactionsInput?);
  Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?);
  Input$TransactionTypesUpsertWithoutTransactionsInput? get upsert =>
      (_$data['upsert']
          as Input$TransactionTypesUpsertWithoutTransactionsInput?);
  Input$TransactionTypesWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionTypesWhereUniqueInput?);
  Input$TransactionTypesUpdateWithoutTransactionsInput? get update =>
      (_$data['update']
          as Input$TransactionTypesUpdateWithoutTransactionsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
        instance,
    TRes Function(
            Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput)
        then,
  ) = _CopyWithImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput;

  factory CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput;

  TRes call({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesUpsertWithoutTransactionsInput? upsert,
    Input$TransactionTypesWhereUniqueInput? connect,
    Input$TransactionTypesUpdateWithoutTransactionsInput? update,
  });
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create;
  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes>
      get upsert;
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect;
  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update;
}

class _CopyWithImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
      _instance;

  final TRes Function(
          Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(
          Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              ._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as Input$TransactionTypesCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?),
        if (upsert != _undefined)
          'upsert':
              (upsert as Input$TransactionTypesUpsertWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionTypesWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$TransactionTypesUpdateWithoutTransactionsInput?),
      }));
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes>
      get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionTypesWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$TransactionTypesWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
    Input$TransactionTypesCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionTypesUpsertWithoutTransactionsInput? upsert,
    Input$TransactionTypesWhereUniqueInput? connect,
    Input$TransactionTypesUpdateWithoutTransactionsInput? update,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionTypesCreateOrConnectWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes>
      get upsert =>
          CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionTypesWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionTypesWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update =>
          CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput.stub(
              _res);
}

class Input$TransactionTypesUpsertWithoutTransactionsInput {
  factory Input$TransactionTypesUpsertWithoutTransactionsInput({
    required Input$TransactionTypesUpdateWithoutTransactionsInput update,
    required Input$TransactionTypesCreateWithoutTransactionsInput create,
  }) =>
      Input$TransactionTypesUpsertWithoutTransactionsInput._({
        r'update': update,
        r'create': create,
      });

  Input$TransactionTypesUpsertWithoutTransactionsInput._(this._$data);

  factory Input$TransactionTypesUpsertWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$TransactionTypesUpdateWithoutTransactionsInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionTypesCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionTypesUpsertWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionTypesUpdateWithoutTransactionsInput get update =>
      (_$data['update']
          as Input$TransactionTypesUpdateWithoutTransactionsInput);
  Input$TransactionTypesCreateWithoutTransactionsInput get create =>
      (_$data['create']
          as Input$TransactionTypesCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<
          Input$TransactionTypesUpsertWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesUpsertWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput(
    Input$TransactionTypesUpsertWithoutTransactionsInput instance,
    TRes Function(Input$TransactionTypesUpsertWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesUpsertWithoutTransactionsInput;

  factory CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesUpsertWithoutTransactionsInput;

  TRes call({
    Input$TransactionTypesUpdateWithoutTransactionsInput? update,
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update;
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesUpsertWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesUpsertWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionTypesUpsertWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionTypesUpsertWithoutTransactionsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update':
              (update as Input$TransactionTypesUpdateWithoutTransactionsInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionTypesCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesUpsertWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesUpsertWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesUpsertWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionTypesUpdateWithoutTransactionsInput? update,
    Input$TransactionTypesCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
      get update =>
          CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionTypesCreateWithoutTransactionsInput.stub(
              _res);
}

class Input$TransactionTypesUpdateWithoutTransactionsInput {
  factory Input$TransactionTypesUpdateWithoutTransactionsInput({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      Input$TransactionTypesUpdateWithoutTransactionsInput._({
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesUpdateWithoutTransactionsInput._(this._$data);

  factory Input$TransactionTypesUpdateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$type_name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionTypesUpdateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get type_name =>
      (_$data['type_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] = l$type_name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<
          Input$TransactionTypesUpdateWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesUpdateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput(
    Input$TransactionTypesUpdateWithoutTransactionsInput instance,
    TRes Function(Input$TransactionTypesUpdateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesUpdateWithoutTransactionsInput;

  factory CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesUpdateWithoutTransactionsInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
}

class _CopyWithImpl$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesUpdateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesUpdateWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionTypesUpdateWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesUpdateWithoutTransactionsInput._({
        ..._instance._$data,
        if (type_name != _undefined)
          'type_name': (type_name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name {
    final local$type_name = _instance.type_name;
    return local$type_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$type_name, (e) => call(type_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesUpdateWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionTypesUpdateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesUpdateWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput {
  factory Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusUpsertWithoutTransactionsInput? upsert,
    Input$TransactionStatusWhereUniqueInput? connect,
    Input$TransactionStatusUpdateWithoutTransactionsInput? update,
  }) =>
      Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput._(
      this._$data);

  factory Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionStatusCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$TransactionStatusUpsertWithoutTransactionsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionStatusWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$TransactionStatusUpdateWithoutTransactionsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionStatusCreateWithoutTransactionsInput? get create =>
      (_$data['create']
          as Input$TransactionStatusCreateWithoutTransactionsInput?);
  Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?);
  Input$TransactionStatusUpsertWithoutTransactionsInput? get upsert =>
      (_$data['upsert']
          as Input$TransactionStatusUpsertWithoutTransactionsInput?);
  Input$TransactionStatusWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionStatusWhereUniqueInput?);
  Input$TransactionStatusUpdateWithoutTransactionsInput? get update =>
      (_$data['update']
          as Input$TransactionStatusUpdateWithoutTransactionsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
        instance,
    TRes Function(
            Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput)
        then,
  ) = _CopyWithImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput;

  factory CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput;

  TRes call({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusUpsertWithoutTransactionsInput? upsert,
    Input$TransactionStatusWhereUniqueInput? connect,
    Input$TransactionStatusUpdateWithoutTransactionsInput? update,
  });
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create;
  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes>
      get upsert;
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect;
  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update;
}

class _CopyWithImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
      _instance;

  final TRes Function(
          Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(
          Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              ._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as Input$TransactionStatusCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?),
        if (upsert != _undefined)
          'upsert': (upsert
              as Input$TransactionStatusUpsertWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionStatusWhereUniqueInput?),
        if (update != _undefined)
          'update': (update
              as Input$TransactionStatusUpdateWithoutTransactionsInput?),
      }));
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes>
      get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionStatusWhereUniqueInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
    Input$TransactionStatusCreateOrConnectWithoutTransactionsInput?
        connectOrCreate,
    Input$TransactionStatusUpsertWithoutTransactionsInput? upsert,
    Input$TransactionStatusWhereUniqueInput? connect,
    Input$TransactionStatusUpdateWithoutTransactionsInput? update,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionStatusCreateOrConnectWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes>
      get upsert =>
          CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionStatusWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionStatusWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update =>
          CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput.stub(
              _res);
}

class Input$TransactionStatusUpsertWithoutTransactionsInput {
  factory Input$TransactionStatusUpsertWithoutTransactionsInput({
    required Input$TransactionStatusUpdateWithoutTransactionsInput update,
    required Input$TransactionStatusCreateWithoutTransactionsInput create,
  }) =>
      Input$TransactionStatusUpsertWithoutTransactionsInput._({
        r'update': update,
        r'create': create,
      });

  Input$TransactionStatusUpsertWithoutTransactionsInput._(this._$data);

  factory Input$TransactionStatusUpsertWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$TransactionStatusUpdateWithoutTransactionsInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionStatusCreateWithoutTransactionsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionStatusUpsertWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionStatusUpdateWithoutTransactionsInput get update =>
      (_$data['update']
          as Input$TransactionStatusUpdateWithoutTransactionsInput);
  Input$TransactionStatusCreateWithoutTransactionsInput get create =>
      (_$data['create']
          as Input$TransactionStatusCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<
          Input$TransactionStatusUpsertWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusUpsertWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput(
    Input$TransactionStatusUpsertWithoutTransactionsInput instance,
    TRes Function(Input$TransactionStatusUpsertWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusUpsertWithoutTransactionsInput;

  factory CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusUpsertWithoutTransactionsInput;

  TRes call({
    Input$TransactionStatusUpdateWithoutTransactionsInput? update,
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update;
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusUpsertWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusUpsertWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionStatusUpsertWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionStatusUpsertWithoutTransactionsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update':
              (update as Input$TransactionStatusUpdateWithoutTransactionsInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionStatusCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusUpsertWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusUpsertWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusUpsertWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionStatusUpdateWithoutTransactionsInput? update,
    Input$TransactionStatusCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
      get update =>
          CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput<TRes>
      get create =>
          CopyWith$Input$TransactionStatusCreateWithoutTransactionsInput.stub(
              _res);
}

class Input$TransactionStatusUpdateWithoutTransactionsInput {
  factory Input$TransactionStatusUpdateWithoutTransactionsInput({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      Input$TransactionStatusUpdateWithoutTransactionsInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusUpdateWithoutTransactionsInput._(this._$data);

  factory Input$TransactionStatusUpdateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionStatusUpdateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<
          Input$TransactionStatusUpdateWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusUpdateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput(
    Input$TransactionStatusUpdateWithoutTransactionsInput instance,
    TRes Function(Input$TransactionStatusUpdateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusUpdateWithoutTransactionsInput;

  factory CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusUpdateWithoutTransactionsInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
}

class _CopyWithImpl$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusUpdateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusUpdateWithoutTransactionsInput _instance;

  final TRes Function(Input$TransactionStatusUpdateWithoutTransactionsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusUpdateWithoutTransactionsInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusUpdateWithoutTransactionsInput<
        TRes>
    implements
        CopyWith$Input$TransactionStatusUpdateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusUpdateWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$PayementsUpdateManyWithoutTransactionNestedInput {
  factory Input$PayementsUpdateManyWithoutTransactionNestedInput({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>? upsert,
    List<Input$PayementsWhereUniqueInput>? $set,
    List<Input$PayementsWhereUniqueInput>? disconnect,
    List<Input$PayementsWhereUniqueInput>? delete,
    List<Input$PayementsWhereUniqueInput>? connect,
    List<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>? update,
    List<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>? updateMany,
    List<Input$PayementsScalarWhereInput>? deleteMany,
  }) =>
      Input$PayementsUpdateManyWithoutTransactionNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$PayementsUpdateManyWithoutTransactionNestedInput._(this._$data);

  factory Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$PayementsCreateWithoutTransactionInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsCreateOrConnectWithoutTransactionInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$PayementsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$PayementsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$PayementsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$PayementsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) => Input$PayementsUpdateManyWithWhereWithoutTransactionInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$PayementsUpdateManyWithoutTransactionNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayementsCreateWithoutTransactionInput>? get create =>
      (_$data['create'] as List<Input$PayementsCreateWithoutTransactionInput>?);
  List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$PayementsCreateOrConnectWithoutTransactionInput>?);
  List<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>?
      get upsert => (_$data['upsert'] as List<
          Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>?);
  List<Input$PayementsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$PayementsWhereUniqueInput>?);
  List<Input$PayementsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$PayementsWhereUniqueInput>?);
  List<Input$PayementsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$PayementsWhereUniqueInput>?);
  List<Input$PayementsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$PayementsWhereUniqueInput>?);
  List<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>?
      get update => (_$data['update'] as List<
          Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>?);
  List<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>?);
  List<Input$PayementsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$PayementsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<
          Input$PayementsUpdateManyWithoutTransactionNestedInput>
      get copyWith =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsUpdateManyWithoutTransactionNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<
    TRes> {
  factory CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
    Input$PayementsUpdateManyWithoutTransactionNestedInput instance,
    TRes Function(Input$PayementsUpdateManyWithoutTransactionNestedInput) then,
  ) = _CopyWithImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput;

  factory CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput;

  TRes call({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>? upsert,
    List<Input$PayementsWhereUniqueInput>? $set,
    List<Input$PayementsWhereUniqueInput>? disconnect,
    List<Input$PayementsWhereUniqueInput>? delete,
    List<Input$PayementsWhereUniqueInput>? connect,
    List<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>? update,
    List<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>? updateMany,
    List<Input$PayementsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$PayementsCreateWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsCreateWithoutTransactionInput<
                      Input$PayementsCreateWithoutTransactionInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$PayementsCreateOrConnectWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
                      Input$PayementsCreateOrConnectWithoutTransactionInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
                      Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$PayementsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereUniqueInput<
                      Input$PayementsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$PayementsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereUniqueInput<
                      Input$PayementsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$PayementsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereUniqueInput<
                      Input$PayementsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$PayementsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsWhereUniqueInput<
                      Input$PayementsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
                      Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
                      Input$PayementsUpdateManyWithWhereWithoutTransactionInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$PayementsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereInput<
                      Input$PayementsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
    implements
        CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes> {
  _CopyWithImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateManyWithoutTransactionNestedInput _instance;

  final TRes Function(Input$PayementsUpdateManyWithoutTransactionNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$PayementsUpdateManyWithoutTransactionNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$PayementsCreateWithoutTransactionInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$PayementsCreateOrConnectWithoutTransactionInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$PayementsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$PayementsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$PayementsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$PayementsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$PayementsUpdateManyWithWhereWithoutTransactionInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$PayementsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$PayementsCreateWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsCreateWithoutTransactionInput<
                          Input$PayementsCreateWithoutTransactionInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map(
              (e) => CopyWith$Input$PayementsCreateWithoutTransactionInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$PayementsCreateOrConnectWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput<
                          Input$PayementsCreateOrConnectWithoutTransactionInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$PayementsCreateOrConnectWithoutTransactionInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
                          Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$PayementsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereUniqueInput<
                          Input$PayementsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$PayementsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$PayementsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereUniqueInput<
                          Input$PayementsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$PayementsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$PayementsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereUniqueInput<
                          Input$PayementsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$PayementsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$PayementsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsWhereUniqueInput<
                          Input$PayementsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$PayementsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
                          Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
                          Input$PayementsUpdateManyWithWhereWithoutTransactionInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$PayementsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereInput<
                          Input$PayementsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$PayementsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateManyWithoutTransactionNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$PayementsCreateWithoutTransactionInput>? create,
    List<Input$PayementsCreateOrConnectWithoutTransactionInput>?
        connectOrCreate,
    List<Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>? upsert,
    List<Input$PayementsWhereUniqueInput>? $set,
    List<Input$PayementsWhereUniqueInput>? disconnect,
    List<Input$PayementsWhereUniqueInput>? delete,
    List<Input$PayementsWhereUniqueInput>? connect,
    List<Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>? update,
    List<Input$PayementsUpdateManyWithWhereWithoutTransactionInput>? updateMany,
    List<Input$PayementsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput {
  factory Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput({
    required Input$PayementsWhereUniqueInput where,
    required Input$PayementsUpdateWithoutTransactionInput update,
    required Input$PayementsCreateWithoutTransactionInput create,
  }) =>
      Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput._(this._$data);

  factory Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$PayementsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$PayementsUpdateWithoutTransactionInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$PayementsCreateWithoutTransactionInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsWhereUniqueInput get where =>
      (_$data['where'] as Input$PayementsWhereUniqueInput);
  Input$PayementsUpdateWithoutTransactionInput get update =>
      (_$data['update'] as Input$PayementsUpdateWithoutTransactionInput);
  Input$PayementsCreateWithoutTransactionInput get create =>
      (_$data['create'] as Input$PayementsCreateWithoutTransactionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
          Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput>
      get copyWith =>
          CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
    TRes> {
  factory CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput(
    Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput instance,
    TRes Function(Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput)
        then,
  ) = _CopyWithImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput;

  factory CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput;

  TRes call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsUpdateWithoutTransactionInput? update,
    Input$PayementsCreateWithoutTransactionInput? create,
  });
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where;
  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get update;
  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create;
}

class _CopyWithImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
            TRes> {
  _CopyWithImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput _instance;

  final TRes Function(
      Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$PayementsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$PayementsUpdateWithoutTransactionInput),
        if (create != _undefined && create != null)
          'create': (create as Input$PayementsCreateWithoutTransactionInput),
      }));
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$PayementsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$PayementsUpdateWithoutTransactionInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$PayementsCreateWithoutTransactionInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput<
            TRes> {
  _CopyWithStubImpl$Input$PayementsUpsertWithWhereUniqueWithoutTransactionInput(
      this._res);

  TRes _res;

  call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsUpdateWithoutTransactionInput? update,
    Input$PayementsCreateWithoutTransactionInput? create,
  }) =>
      _res;
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$PayementsWhereUniqueInput.stub(_res);
  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get update =>
      CopyWith$Input$PayementsUpdateWithoutTransactionInput.stub(_res);
  CopyWith$Input$PayementsCreateWithoutTransactionInput<TRes> get create =>
      CopyWith$Input$PayementsCreateWithoutTransactionInput.stub(_res);
}

class Input$PayementsUpdateWithoutTransactionInput {
  factory Input$PayementsUpdateWithoutTransactionInput({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  }) =>
      Input$PayementsUpdateWithoutTransactionInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsUpdateWithoutTransactionInput._(this._$data);

  factory Input$PayementsUpdateWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$payement as Map<String, dynamic>));
    }
    return Input$PayementsUpdateWithoutTransactionInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get payement_id =>
      (_$data['payement_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get payement =>
      (_$data['payement'] as Input$FloatFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsUpdateWithoutTransactionInput<
          Input$PayementsUpdateWithoutTransactionInput>
      get copyWith => CopyWith$Input$PayementsUpdateWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsUpdateWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> {
  factory CopyWith$Input$PayementsUpdateWithoutTransactionInput(
    Input$PayementsUpdateWithoutTransactionInput instance,
    TRes Function(Input$PayementsUpdateWithoutTransactionInput) then,
  ) = _CopyWithImpl$Input$PayementsUpdateWithoutTransactionInput;

  factory CopyWith$Input$PayementsUpdateWithoutTransactionInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateWithoutTransactionInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement;
}

class _CopyWithImpl$Input$PayementsUpdateWithoutTransactionInput<TRes>
    implements CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> {
  _CopyWithImpl$Input$PayementsUpdateWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateWithoutTransactionInput _instance;

  final TRes Function(Input$PayementsUpdateWithoutTransactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsUpdateWithoutTransactionInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntFieldUpdateOperationsInput?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$payement, (e) => call(payement: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpdateWithoutTransactionInput<TRes>
    implements CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateWithoutTransactionInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
}

class Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput {
  factory Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput({
    required Input$PayementsWhereUniqueInput where,
    required Input$PayementsUpdateWithoutTransactionInput data,
  }) =>
      Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput._({
        r'where': where,
        r'data': data,
      });

  Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput._(this._$data);

  factory Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$PayementsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$PayementsUpdateWithoutTransactionInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsWhereUniqueInput get where =>
      (_$data['where'] as Input$PayementsWhereUniqueInput);
  Input$PayementsUpdateWithoutTransactionInput get data =>
      (_$data['data'] as Input$PayementsUpdateWithoutTransactionInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
          Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput>
      get copyWith =>
          CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
    TRes> {
  factory CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput(
    Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput instance,
    TRes Function(Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput)
        then,
  ) = _CopyWithImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput;

  factory CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput;

  TRes call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsUpdateWithoutTransactionInput? data,
  });
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where;
  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get data;
}

class _CopyWithImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
            TRes> {
  _CopyWithImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput _instance;

  final TRes Function(
      Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$PayementsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$PayementsUpdateWithoutTransactionInput),
      }));
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$PayementsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$PayementsUpdateWithoutTransactionInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput<
            TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateWithWhereUniqueWithoutTransactionInput(
      this._res);

  TRes _res;

  call({
    Input$PayementsWhereUniqueInput? where,
    Input$PayementsUpdateWithoutTransactionInput? data,
  }) =>
      _res;
  CopyWith$Input$PayementsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$PayementsWhereUniqueInput.stub(_res);
  CopyWith$Input$PayementsUpdateWithoutTransactionInput<TRes> get data =>
      CopyWith$Input$PayementsUpdateWithoutTransactionInput.stub(_res);
}

class Input$PayementsUpdateManyWithWhereWithoutTransactionInput {
  factory Input$PayementsUpdateManyWithWhereWithoutTransactionInput({
    required Input$PayementsScalarWhereInput where,
    required Input$PayementsUpdateManyMutationInput data,
  }) =>
      Input$PayementsUpdateManyWithWhereWithoutTransactionInput._({
        r'where': where,
        r'data': data,
      });

  Input$PayementsUpdateManyWithWhereWithoutTransactionInput._(this._$data);

  factory Input$PayementsUpdateManyWithWhereWithoutTransactionInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$PayementsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$PayementsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$PayementsUpdateManyWithWhereWithoutTransactionInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$PayementsScalarWhereInput get where =>
      (_$data['where'] as Input$PayementsScalarWhereInput);
  Input$PayementsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$PayementsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
          Input$PayementsUpdateManyWithWhereWithoutTransactionInput>
      get copyWith =>
          CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsUpdateManyWithWhereWithoutTransactionInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
    TRes> {
  factory CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput(
    Input$PayementsUpdateManyWithWhereWithoutTransactionInput instance,
    TRes Function(Input$PayementsUpdateManyWithWhereWithoutTransactionInput)
        then,
  ) = _CopyWithImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput;

  factory CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput;

  TRes call({
    Input$PayementsScalarWhereInput? where,
    Input$PayementsUpdateManyMutationInput? data,
  });
  CopyWith$Input$PayementsScalarWhereInput<TRes> get where;
  CopyWith$Input$PayementsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
            TRes> {
  _CopyWithImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateManyWithWhereWithoutTransactionInput _instance;

  final TRes Function(Input$PayementsUpdateManyWithWhereWithoutTransactionInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$PayementsUpdateManyWithWhereWithoutTransactionInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$PayementsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$PayementsUpdateManyMutationInput),
      }));
  CopyWith$Input$PayementsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$PayementsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$PayementsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$PayementsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
        TRes>
    implements
        CopyWith$Input$PayementsUpdateManyWithWhereWithoutTransactionInput<
            TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateManyWithWhereWithoutTransactionInput(
      this._res);

  TRes _res;

  call({
    Input$PayementsScalarWhereInput? where,
    Input$PayementsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$PayementsScalarWhereInput<TRes> get where =>
      CopyWith$Input$PayementsScalarWhereInput.stub(_res);
  CopyWith$Input$PayementsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$PayementsUpdateManyMutationInput.stub(_res);
}

class Input$PayementsScalarWhereInput {
  factory Input$PayementsScalarWhereInput({
    List<Input$PayementsScalarWhereInput>? AND,
    List<Input$PayementsScalarWhereInput>? OR,
    List<Input$PayementsScalarWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
  }) =>
      Input$PayementsScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (payement_id != null) r'payement_id': payement_id,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsScalarWhereInput._(this._$data);

  factory Input$PayementsScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$PayementsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntFilter.fromJson((l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatFilter.fromJson((l$payement as Map<String, dynamic>));
    }
    return Input$PayementsScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$PayementsScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$PayementsScalarWhereInput>?);
  List<Input$PayementsScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$PayementsScalarWhereInput>?);
  List<Input$PayementsScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$PayementsScalarWhereInput>?);
  Input$IntFilter? get payement_id =>
      (_$data['payement_id'] as Input$IntFilter?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$FloatFilter? get payement => (_$data['payement'] as Input$FloatFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsScalarWhereInput<Input$PayementsScalarWhereInput>
      get copyWith => CopyWith$Input$PayementsScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$payement_id = payement_id;
    final l$transaction_id = transaction_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsScalarWhereInput<TRes> {
  factory CopyWith$Input$PayementsScalarWhereInput(
    Input$PayementsScalarWhereInput instance,
    TRes Function(Input$PayementsScalarWhereInput) then,
  ) = _CopyWithImpl$Input$PayementsScalarWhereInput;

  factory CopyWith$Input$PayementsScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsScalarWhereInput;

  TRes call({
    List<Input$PayementsScalarWhereInput>? AND,
    List<Input$PayementsScalarWhereInput>? OR,
    List<Input$PayementsScalarWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
  });
  TRes AND(
      Iterable<Input$PayementsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereInput<
                      Input$PayementsScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$PayementsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereInput<
                      Input$PayementsScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$PayementsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$PayementsScalarWhereInput<
                      Input$PayementsScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get payement_id;
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$FloatFilter<TRes> get payement;
}

class _CopyWithImpl$Input$PayementsScalarWhereInput<TRes>
    implements CopyWith$Input$PayementsScalarWhereInput<TRes> {
  _CopyWithImpl$Input$PayementsScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$PayementsScalarWhereInput _instance;

  final TRes Function(Input$PayementsScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? payement_id = _undefined,
    Object? transaction_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$PayementsScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$PayementsScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$PayementsScalarWhereInput>?),
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntFilter?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatFilter?),
      }));
  TRes AND(
          Iterable<Input$PayementsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereInput<
                          Input$PayementsScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$PayementsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$PayementsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereInput<
                          Input$PayementsScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$PayementsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$PayementsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$PayementsScalarWhereInput<
                          Input$PayementsScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$PayementsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$FloatFilter<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$payement, (e) => call(payement: e));
  }
}

class _CopyWithStubImpl$Input$PayementsScalarWhereInput<TRes>
    implements CopyWith$Input$PayementsScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$PayementsScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$PayementsScalarWhereInput>? AND,
    List<Input$PayementsScalarWhereInput>? OR,
    List<Input$PayementsScalarWhereInput>? NOT,
    Input$IntFilter? payement_id,
    Input$IntFilter? transaction_id,
    Input$FloatFilter? payement,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get payement_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get payement =>
      CopyWith$Input$FloatFilter.stub(_res);
}

class Input$PayementsUpdateManyMutationInput {
  factory Input$PayementsUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  }) =>
      Input$PayementsUpdateManyMutationInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (payement != null) r'payement': payement,
      });

  Input$PayementsUpdateManyMutationInput._(this._$data);

  factory Input$PayementsUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$payement as Map<String, dynamic>));
    }
    return Input$PayementsUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get payement_id =>
      (_$data['payement_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get payement =>
      (_$data['payement'] as Input$FloatFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsUpdateManyMutationInput<
          Input$PayementsUpdateManyMutationInput>
      get copyWith => CopyWith$Input$PayementsUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$payement = payement;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$PayementsUpdateManyMutationInput(
    Input$PayementsUpdateManyMutationInput instance,
    TRes Function(Input$PayementsUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$PayementsUpdateManyMutationInput;

  factory CopyWith$Input$PayementsUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement;
}

class _CopyWithImpl$Input$PayementsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$PayementsUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$PayementsUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateManyMutationInput _instance;

  final TRes Function(Input$PayementsUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? payement = _undefined,
  }) =>
      _then(Input$PayementsUpdateManyMutationInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntFieldUpdateOperationsInput?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$payement, (e) => call(payement: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$PayementsUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionsUpdateWithWhereUniqueWithoutCityInput {
  factory Input$TransactionsUpdateWithWhereUniqueWithoutCityInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutCityInput data,
  }) =>
      Input$TransactionsUpdateWithWhereUniqueWithoutCityInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateWithWhereUniqueWithoutCityInput._(this._$data);

  factory Input$TransactionsUpdateWithWhereUniqueWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateWithoutCityInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateWithWhereUniqueWithoutCityInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutCityInput get data =>
      (_$data['data'] as Input$TransactionsUpdateWithoutCityInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
          Input$TransactionsUpdateWithWhereUniqueWithoutCityInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithWhereUniqueWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput(
    Input$TransactionsUpdateWithWhereUniqueWithoutCityInput instance,
    TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput;

  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutCityInput? data,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithWhereUniqueWithoutCityInput _instance;

  final TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutCityInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithWhereUniqueWithoutCityInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateWithoutCityInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateWithoutCityInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutCityInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutCityInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutCityInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateWithoutCityInput.stub(_res);
}

class Input$TransactionsUpdateManyWithWhereWithoutCityInput {
  factory Input$TransactionsUpdateManyWithWhereWithoutCityInput({
    required Input$TransactionsScalarWhereInput where,
    required Input$TransactionsUpdateManyMutationInput data,
  }) =>
      Input$TransactionsUpdateManyWithWhereWithoutCityInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateManyWithWhereWithoutCityInput._(this._$data);

  factory Input$TransactionsUpdateManyWithWhereWithoutCityInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateManyWithWhereWithoutCityInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsScalarWhereInput get where =>
      (_$data['where'] as Input$TransactionsScalarWhereInput);
  Input$TransactionsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$TransactionsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<
          Input$TransactionsUpdateManyWithWhereWithoutCityInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithWhereWithoutCityInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput(
    Input$TransactionsUpdateManyWithWhereWithoutCityInput instance,
    TRes Function(Input$TransactionsUpdateManyWithWhereWithoutCityInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput;

  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput;

  TRes call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  });
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithWhereWithoutCityInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithWhereWithoutCityInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithWhereWithoutCityInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateManyMutationInput),
      }));
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutCityInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutCityInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where =>
      CopyWith$Input$TransactionsScalarWhereInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateManyMutationInput.stub(_res);
}

class Input$TransactionsScalarWhereInput {
  factory Input$TransactionsScalarWhereInput({
    List<Input$TransactionsScalarWhereInput>? AND,
    List<Input$TransactionsScalarWhereInput>? OR,
    List<Input$TransactionsScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$IntFilter? transaction_type_id,
    Input$IntFilter? status_id,
  }) =>
      Input$TransactionsScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (seller_id != null) r'seller_id': seller_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (city_id != null) r'city_id': city_id,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (transaction_type_id != null)
          r'transaction_type_id': transaction_type_id,
        if (status_id != null) r'status_id': status_id,
      });

  Input$TransactionsScalarWhereInput._(this._$data);

  factory Input$TransactionsScalarWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('seller_id')) {
      final l$seller_id = data['seller_id'];
      result$data['seller_id'] = l$seller_id == null
          ? null
          : Input$IntFilter.fromJson((l$seller_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFilter.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFilter.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFilter.fromJson((l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFilter.fromJson((l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFilter.fromJson((l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = data['transaction_type_id'];
      result$data['transaction_type_id'] = l$transaction_type_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_type_id as Map<String, dynamic>));
    }
    if (data.containsKey('status_id')) {
      final l$status_id = data['status_id'];
      result$data['status_id'] = l$status_id == null
          ? null
          : Input$IntFilter.fromJson((l$status_id as Map<String, dynamic>));
    }
    return Input$TransactionsScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionsScalarWhereInput>?);
  List<Input$TransactionsScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionsScalarWhereInput>?);
  List<Input$TransactionsScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionsScalarWhereInput>?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$IntFilter? get seller_id => (_$data['seller_id'] as Input$IntFilter?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$StringFilter? get customer_name =>
      (_$data['customer_name'] as Input$StringFilter?);
  Input$StringFilter? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFilter?);
  Input$IntFilter? get city_id => (_$data['city_id'] as Input$IntFilter?);
  Input$StringFilter? get address => (_$data['address'] as Input$StringFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Input$DateTimeFilter? get date => (_$data['date'] as Input$DateTimeFilter?);
  Input$FloatFilter? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFilter?);
  Input$FloatFilter? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFilter?);
  Input$IntFilter? get transaction_type_id =>
      (_$data['transaction_type_id'] as Input$IntFilter?);
  Input$IntFilter? get status_id => (_$data['status_id'] as Input$IntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('seller_id')) {
      final l$seller_id = seller_id;
      result$data['seller_id'] = l$seller_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('transaction_type_id')) {
      final l$transaction_type_id = transaction_type_id;
      result$data['transaction_type_id'] = l$transaction_type_id?.toJson();
    }
    if (_$data.containsKey('status_id')) {
      final l$status_id = status_id;
      result$data['status_id'] = l$status_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsScalarWhereInput<
          Input$TransactionsScalarWhereInput>
      get copyWith => CopyWith$Input$TransactionsScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$seller_id = seller_id;
    final lOther$seller_id = other.seller_id;
    if (_$data.containsKey('seller_id') !=
        other._$data.containsKey('seller_id')) {
      return false;
    }
    if (l$seller_id != lOther$seller_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$transaction_type_id = transaction_type_id;
    final lOther$transaction_type_id = other.transaction_type_id;
    if (_$data.containsKey('transaction_type_id') !=
        other._$data.containsKey('transaction_type_id')) {
      return false;
    }
    if (l$transaction_type_id != lOther$transaction_type_id) {
      return false;
    }
    final l$status_id = status_id;
    final lOther$status_id = other.status_id;
    if (_$data.containsKey('status_id') !=
        other._$data.containsKey('status_id')) {
      return false;
    }
    if (l$status_id != lOther$status_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$seller_id = seller_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$city_id = city_id;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$transaction_type_id = transaction_type_id;
    final l$status_id = status_id;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('seller_id') ? l$seller_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('transaction_type_id')
          ? l$transaction_type_id
          : const {},
      _$data.containsKey('status_id') ? l$status_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsScalarWhereInput<TRes> {
  factory CopyWith$Input$TransactionsScalarWhereInput(
    Input$TransactionsScalarWhereInput instance,
    TRes Function(Input$TransactionsScalarWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionsScalarWhereInput;

  factory CopyWith$Input$TransactionsScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsScalarWhereInput;

  TRes call({
    List<Input$TransactionsScalarWhereInput>? AND,
    List<Input$TransactionsScalarWhereInput>? OR,
    List<Input$TransactionsScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$IntFilter? transaction_type_id,
    Input$IntFilter? status_id,
  });
  TRes AND(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$IntFilter<TRes> get seller_id;
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$StringFilter<TRes> get customer_name;
  CopyWith$Input$StringFilter<TRes> get customer_phone;
  CopyWith$Input$IntFilter<TRes> get city_id;
  CopyWith$Input$StringFilter<TRes> get address;
  CopyWith$Input$IntFilter<TRes> get quantity;
  CopyWith$Input$DateTimeFilter<TRes> get date;
  CopyWith$Input$FloatFilter<TRes> get remainingPayement;
  CopyWith$Input$FloatFilter<TRes> get totalPayement;
  CopyWith$Input$IntFilter<TRes> get transaction_type_id;
  CopyWith$Input$IntFilter<TRes> get status_id;
}

class _CopyWithImpl$Input$TransactionsScalarWhereInput<TRes>
    implements CopyWith$Input$TransactionsScalarWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionsScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsScalarWhereInput _instance;

  final TRes Function(Input$TransactionsScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? seller_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? city_id = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? transaction_type_id = _undefined,
    Object? status_id = _undefined,
  }) =>
      _then(Input$TransactionsScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionsScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionsScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionsScalarWhereInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (seller_id != _undefined)
          'seller_id': (seller_id as Input$IntFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (customer_name != _undefined)
          'customer_name': (customer_name as Input$StringFilter?),
        if (customer_phone != _undefined)
          'customer_phone': (customer_phone as Input$StringFilter?),
        if (city_id != _undefined) 'city_id': (city_id as Input$IntFilter?),
        if (address != _undefined) 'address': (address as Input$StringFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
        if (date != _undefined) 'date': (date as Input$DateTimeFilter?),
        if (remainingPayement != _undefined)
          'remainingPayement': (remainingPayement as Input$FloatFilter?),
        if (totalPayement != _undefined)
          'totalPayement': (totalPayement as Input$FloatFilter?),
        if (transaction_type_id != _undefined)
          'transaction_type_id': (transaction_type_id as Input$IntFilter?),
        if (status_id != _undefined)
          'status_id': (status_id as Input$IntFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get seller_id {
    final local$seller_id = _instance.seller_id;
    return local$seller_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$seller_id, (e) => call(seller_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFilter<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$IntFilter<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFilter<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFilter<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFilter.stub(_then(_instance))
        : CopyWith$Input$DateTimeFilter(local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFilter<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFilter<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$IntFilter<TRes> get transaction_type_id {
    final local$transaction_type_id = _instance.transaction_type_id;
    return local$transaction_type_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_type_id, (e) => call(transaction_type_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get status_id {
    final local$status_id = _instance.status_id;
    return local$status_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$status_id, (e) => call(status_id: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsScalarWhereInput<TRes>
    implements CopyWith$Input$TransactionsScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionsScalarWhereInput>? AND,
    List<Input$TransactionsScalarWhereInput>? OR,
    List<Input$TransactionsScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? seller_id,
    Input$IntFilter? product_id,
    Input$StringFilter? customer_name,
    Input$StringFilter? customer_phone,
    Input$IntFilter? city_id,
    Input$StringFilter? address,
    Input$IntFilter? quantity,
    Input$DateTimeFilter? date,
    Input$FloatFilter? remainingPayement,
    Input$FloatFilter? totalPayement,
    Input$IntFilter? transaction_type_id,
    Input$IntFilter? status_id,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get seller_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get customer_name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get customer_phone =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get city_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get address =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$DateTimeFilter<TRes> get date =>
      CopyWith$Input$DateTimeFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get remainingPayement =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get totalPayement =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get transaction_type_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get status_id =>
      CopyWith$Input$IntFilter.stub(_res);
}

class Input$TransactionsUpdateManyMutationInput {
  factory Input$TransactionsUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
  }) =>
      Input$TransactionsUpdateManyMutationInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
      });

  Input$TransactionsUpdateManyMutationInput._(this._$data);

  factory Input$TransactionsUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyMutationInput<
          Input$TransactionsUpdateManyMutationInput>
      get copyWith => CopyWith$Input$TransactionsUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateManyMutationInput(
    Input$TransactionsUpdateManyMutationInput instance,
    TRes Function(Input$TransactionsUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyMutationInput;

  factory CopyWith$Input$TransactionsUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
}

class _CopyWithImpl$Input$TransactionsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyMutationInput _instance;

  final TRes Function(Input$TransactionsUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyMutationInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
}

class Input$ColorsCreateInput {
  factory Input$ColorsCreateInput({
    required int id,
    required String color,
    Input$ProductModelCreateNestedManyWithoutColorInput? ProductModel,
  }) =>
      Input$ColorsCreateInput._({
        r'id': id,
        r'color': color,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ColorsCreateInput._(this._$data);

  factory Input$ColorsCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as int);
    final l$color = data['color'];
    result$data['color'] = (l$color as String);
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelCreateNestedManyWithoutColorInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ColorsCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get id => (_$data['id'] as int);
  String get color => (_$data['color'] as String);
  Input$ProductModelCreateNestedManyWithoutColorInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelCreateNestedManyWithoutColorInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$color = color;
    result$data['color'] = l$color;
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsCreateInput<Input$ColorsCreateInput> get copyWith =>
      CopyWith$Input$ColorsCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      l$id,
      l$color,
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsCreateInput<TRes> {
  factory CopyWith$Input$ColorsCreateInput(
    Input$ColorsCreateInput instance,
    TRes Function(Input$ColorsCreateInput) then,
  ) = _CopyWithImpl$Input$ColorsCreateInput;

  factory CopyWith$Input$ColorsCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsCreateInput;

  TRes call({
    int? id,
    String? color,
    Input$ProductModelCreateNestedManyWithoutColorInput? ProductModel,
  });
  CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$ColorsCreateInput<TRes>
    implements CopyWith$Input$ColorsCreateInput<TRes> {
  _CopyWithImpl$Input$ColorsCreateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsCreateInput _instance;

  final TRes Function(Input$ColorsCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ColorsCreateInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as int),
        if (color != _undefined && color != null) 'color': (color as String),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelCreateNestedManyWithoutColorInput?),
      }));
  CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ColorsCreateInput<TRes>
    implements CopyWith$Input$ColorsCreateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsCreateInput(this._res);

  TRes _res;

  call({
    int? id,
    String? color,
    Input$ProductModelCreateNestedManyWithoutColorInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput.stub(
              _res);
}

class Input$ProductModelCreateNestedManyWithoutColorInput {
  factory Input$ProductModelCreateNestedManyWithoutColorInput({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      Input$ProductModelCreateNestedManyWithoutColorInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductModelCreateNestedManyWithoutColorInput._(this._$data);

  factory Input$ProductModelCreateNestedManyWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutColorInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutColorInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelCreateNestedManyWithoutColorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutColorInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutColorInput>?);
  List<Input$ProductModelCreateOrConnectWithoutColorInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutColorInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<
          Input$ProductModelCreateNestedManyWithoutColorInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateNestedManyWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput(
    Input$ProductModelCreateNestedManyWithoutColorInput instance,
    TRes Function(Input$ProductModelCreateNestedManyWithoutColorInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutColorInput;

  factory CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutColorInput;

  TRes call({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutColorInput<
                      Input$ProductModelCreateWithoutColorInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
                      Input$ProductModelCreateOrConnectWithoutColorInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutColorInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateNestedManyWithoutColorInput _instance;

  final TRes Function(Input$ProductModelCreateNestedManyWithoutColorInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductModelCreateNestedManyWithoutColorInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$ProductModelCreateWithoutColorInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutColorInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutColorInput<
                          Input$ProductModelCreateWithoutColorInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutColorInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
                          Input$ProductModelCreateOrConnectWithoutColorInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutColorInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutColorInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$ProductModelCreateWithoutColorInput {
  factory Input$ProductModelCreateWithoutColorInput({
    required int quantity,
    required Input$ProductsCreateNestedOneWithoutProductModelInput product,
    required Input$SizesCreateNestedOneWithoutProductModelInput size,
  }) =>
      Input$ProductModelCreateWithoutColorInput._({
        r'quantity': quantity,
        r'product': product,
        r'size': size,
      });

  Input$ProductModelCreateWithoutColorInput._(this._$data);

  factory Input$ProductModelCreateWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$product = data['product'];
    result$data['product'] =
        Input$ProductsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$product as Map<String, dynamic>));
    final l$size = data['size'];
    result$data['size'] =
        Input$SizesCreateNestedOneWithoutProductModelInput.fromJson(
            (l$size as Map<String, dynamic>));
    return Input$ProductModelCreateWithoutColorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  Input$ProductsCreateNestedOneWithoutProductModelInput get product =>
      (_$data['product']
          as Input$ProductsCreateNestedOneWithoutProductModelInput);
  Input$SizesCreateNestedOneWithoutProductModelInput get size =>
      (_$data['size'] as Input$SizesCreateNestedOneWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$product = product;
    result$data['product'] = l$product.toJson();
    final l$size = size;
    result$data['size'] = l$size.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateWithoutColorInput<
          Input$ProductModelCreateWithoutColorInput>
      get copyWith => CopyWith$Input$ProductModelCreateWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    return Object.hashAll([
      l$quantity,
      l$product,
      l$size,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> {
  factory CopyWith$Input$ProductModelCreateWithoutColorInput(
    Input$ProductModelCreateWithoutColorInput instance,
    TRes Function(Input$ProductModelCreateWithoutColorInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateWithoutColorInput;

  factory CopyWith$Input$ProductModelCreateWithoutColorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateWithoutColorInput;

  TRes call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
  });
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product;
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size;
}

class _CopyWithImpl$Input$ProductModelCreateWithoutColorInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateWithoutColorInput _instance;

  final TRes Function(Input$ProductModelCreateWithoutColorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$ProductModelCreateWithoutColorInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (product != _undefined && product != null)
          'product': (product
              as Input$ProductsCreateNestedOneWithoutProductModelInput),
        if (size != _undefined && size != null)
          'size': (size as Input$SizesCreateNestedOneWithoutProductModelInput),
      }));
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product {
    final local$product = _instance.product;
    return CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput(
        local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size {
    final local$size = _instance.size;
    return CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput(
        local$size, (e) => call(size: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateWithoutColorInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateWithoutColorInput(this._res);

  TRes _res;

  call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product =>
          CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size =>
      CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput.stub(_res);
}

class Input$ProductsCreateNestedOneWithoutProductModelInput {
  factory Input$ProductsCreateNestedOneWithoutProductModelInput({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  }) =>
      Input$ProductsCreateNestedOneWithoutProductModelInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductsCreateNestedOneWithoutProductModelInput._(this._$data);

  factory Input$ProductsCreateNestedOneWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductsCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductsCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$ProductsCreateNestedOneWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$ProductsCreateWithoutProductModelInput?);
  Input$ProductsCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ProductsCreateOrConnectWithoutProductModelInput?);
  Input$ProductsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductsWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<
          Input$ProductsCreateNestedOneWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateNestedOneWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput(
    Input$ProductsCreateNestedOneWithoutProductModelInput instance,
    TRes Function(Input$ProductsCreateNestedOneWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateNestedOneWithoutProductModelInput;

  factory CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutProductModelInput;

  TRes call({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  });
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateNestedOneWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateNestedOneWithoutProductModelInput _instance;

  final TRes Function(Input$ProductsCreateNestedOneWithoutProductModelInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductsCreateNestedOneWithoutProductModelInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ProductsCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductsCreateOrConnectWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductsWhereUniqueInput?),
      }));
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutProductModelInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
}

class Input$ProductsCreateWithoutProductModelInput {
  factory Input$ProductsCreateWithoutProductModelInput({
    required int reference,
    required String name,
    required double buyingPrice,
    required double sellingPrice,
    required String description,
    required String picture,
    required Input$ProductFamilyCreateNestedOneWithoutProductsInput family,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      Input$ProductsCreateWithoutProductModelInput._({
        r'reference': reference,
        r'name': name,
        r'buyingPrice': buyingPrice,
        r'sellingPrice': sellingPrice,
        r'description': description,
        r'picture': picture,
        r'family': family,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsCreateWithoutProductModelInput._(this._$data);

  factory Input$ProductsCreateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reference = data['reference'];
    result$data['reference'] = (l$reference as int);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$buyingPrice = data['buyingPrice'];
    result$data['buyingPrice'] = (l$buyingPrice as num).toDouble();
    final l$sellingPrice = data['sellingPrice'];
    result$data['sellingPrice'] = (l$sellingPrice as num).toDouble();
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    final l$family = data['family'];
    result$data['family'] =
        Input$ProductFamilyCreateNestedOneWithoutProductsInput.fromJson(
            (l$family as Map<String, dynamic>));
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductCreateNestedManyWithoutProductInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsCreateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get reference => (_$data['reference'] as int);
  String get name => (_$data['name'] as String);
  double get buyingPrice => (_$data['buyingPrice'] as double);
  double get sellingPrice => (_$data['sellingPrice'] as double);
  String get description => (_$data['description'] as String);
  String get picture => (_$data['picture'] as String);
  Input$ProductFamilyCreateNestedOneWithoutProductsInput get family =>
      (_$data['family']
          as Input$ProductFamilyCreateNestedOneWithoutProductsInput);
  Input$TransactionProductCreateNestedManyWithoutProductInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductCreateNestedManyWithoutProductInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reference = reference;
    result$data['reference'] = l$reference;
    final l$name = name;
    result$data['name'] = l$name;
    final l$buyingPrice = buyingPrice;
    result$data['buyingPrice'] = l$buyingPrice;
    final l$sellingPrice = sellingPrice;
    result$data['sellingPrice'] = l$sellingPrice;
    final l$description = description;
    result$data['description'] = l$description;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    final l$family = family;
    result$data['family'] = l$family.toJson();
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateWithoutProductModelInput<
          Input$ProductsCreateWithoutProductModelInput>
      get copyWith => CopyWith$Input$ProductsCreateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (l$family != lOther$family) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      l$reference,
      l$name,
      l$buyingPrice,
      l$sellingPrice,
      l$description,
      l$picture,
      l$family,
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ProductsCreateWithoutProductModelInput(
    Input$ProductsCreateWithoutProductModelInput instance,
    TRes Function(Input$ProductsCreateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateWithoutProductModelInput;

  factory CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateWithoutProductModelInput;

  TRes call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  });
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family;
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateWithoutProductModelInput _instance;

  final TRes Function(Input$ProductsCreateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsCreateWithoutProductModelInput._({
        ..._instance._$data,
        if (reference != _undefined && reference != null)
          'reference': (reference as int),
        if (name != _undefined && name != null) 'name': (name as String),
        if (buyingPrice != _undefined && buyingPrice != null)
          'buyingPrice': (buyingPrice as double),
        if (sellingPrice != _undefined && sellingPrice != null)
          'sellingPrice': (sellingPrice as double),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
        if (family != _undefined && family != null)
          'family': (family
              as Input$ProductFamilyCreateNestedOneWithoutProductsInput),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductCreateNestedManyWithoutProductInput?),
      }));
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family {
    final local$family = _instance.family;
    return CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
        local$family, (e) => call(family: e));
  }

  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput.stub(
              _res);
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
              .stub(_res);
}

class Input$ProductFamilyCreateNestedOneWithoutProductsInput {
  factory Input$ProductFamilyCreateNestedOneWithoutProductsInput({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyWhereUniqueInput? connect,
  }) =>
      Input$ProductFamilyCreateNestedOneWithoutProductsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductFamilyCreateNestedOneWithoutProductsInput._(this._$data);

  factory Input$ProductFamilyCreateNestedOneWithoutProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductFamilyCreateWithoutProductsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductFamilyCreateOrConnectWithoutProductsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductFamilyWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$ProductFamilyCreateNestedOneWithoutProductsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductFamilyCreateWithoutProductsInput? get create =>
      (_$data['create'] as Input$ProductFamilyCreateWithoutProductsInput?);
  Input$ProductFamilyCreateOrConnectWithoutProductsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ProductFamilyCreateOrConnectWithoutProductsInput?);
  Input$ProductFamilyWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductFamilyWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<
          Input$ProductFamilyCreateNestedOneWithoutProductsInput>
      get copyWith =>
          CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyCreateNestedOneWithoutProductsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<
    TRes> {
  factory CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
    Input$ProductFamilyCreateNestedOneWithoutProductsInput instance,
    TRes Function(Input$ProductFamilyCreateNestedOneWithoutProductsInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput;

  factory CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput;

  TRes call({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyWhereUniqueInput? connect,
  });
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create;
  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
    implements
        CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyCreateNestedOneWithoutProductsInput _instance;

  final TRes Function(Input$ProductFamilyCreateNestedOneWithoutProductsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductFamilyCreateNestedOneWithoutProductsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ProductFamilyCreateWithoutProductsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductFamilyCreateOrConnectWithoutProductsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductFamilyWhereUniqueInput?),
      }));
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductFamilyWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductFamilyWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput<
        TRes>
    implements
        CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
      this._res);

  TRes _res;

  call({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create =>
      CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(_res);
  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput.stub(
              _res);
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductFamilyWhereUniqueInput.stub(_res);
}

class Input$ProductFamilyCreateWithoutProductsInput {
  factory Input$ProductFamilyCreateWithoutProductsInput(
          {required String name}) =>
      Input$ProductFamilyCreateWithoutProductsInput._({
        r'name': name,
      });

  Input$ProductFamilyCreateWithoutProductsInput._(this._$data);

  factory Input$ProductFamilyCreateWithoutProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    return Input$ProductFamilyCreateWithoutProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    return result$data;
  }

  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<
          Input$ProductFamilyCreateWithoutProductsInput>
      get copyWith => CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyCreateWithoutProductsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([l$name]);
  }
}

abstract class CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> {
  factory CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
    Input$ProductFamilyCreateWithoutProductsInput instance,
    TRes Function(Input$ProductFamilyCreateWithoutProductsInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyCreateWithoutProductsInput;

  factory CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyCreateWithoutProductsInput;

  TRes call({String? name});
}

class _CopyWithImpl$Input$ProductFamilyCreateWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyCreateWithoutProductsInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyCreateWithoutProductsInput _instance;

  final TRes Function(Input$ProductFamilyCreateWithoutProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) =>
      _then(Input$ProductFamilyCreateWithoutProductsInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
      }));
}

class _CopyWithStubImpl$Input$ProductFamilyCreateWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyCreateWithoutProductsInput(this._res);

  TRes _res;

  call({String? name}) => _res;
}

class Input$ProductFamilyCreateOrConnectWithoutProductsInput {
  factory Input$ProductFamilyCreateOrConnectWithoutProductsInput({
    required Input$ProductFamilyWhereUniqueInput where,
    required Input$ProductFamilyCreateWithoutProductsInput create,
  }) =>
      Input$ProductFamilyCreateOrConnectWithoutProductsInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductFamilyCreateOrConnectWithoutProductsInput._(this._$data);

  factory Input$ProductFamilyCreateOrConnectWithoutProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductFamilyWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductFamilyCreateWithoutProductsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductFamilyCreateOrConnectWithoutProductsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductFamilyWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductFamilyWhereUniqueInput);
  Input$ProductFamilyCreateWithoutProductsInput get create =>
      (_$data['create'] as Input$ProductFamilyCreateWithoutProductsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<
          Input$ProductFamilyCreateOrConnectWithoutProductsInput>
      get copyWith =>
          CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyCreateOrConnectWithoutProductsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<
    TRes> {
  factory CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
    Input$ProductFamilyCreateOrConnectWithoutProductsInput instance,
    TRes Function(Input$ProductFamilyCreateOrConnectWithoutProductsInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput;

  factory CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput;

  TRes call({
    Input$ProductFamilyWhereUniqueInput? where,
    Input$ProductFamilyCreateWithoutProductsInput? create,
  });
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
    implements
        CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyCreateOrConnectWithoutProductsInput _instance;

  final TRes Function(Input$ProductFamilyCreateOrConnectWithoutProductsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductFamilyCreateOrConnectWithoutProductsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductFamilyWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductFamilyCreateWithoutProductsInput),
      }));
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductFamilyWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput<
        TRes>
    implements
        CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
      this._res);

  TRes _res;

  call({
    Input$ProductFamilyWhereUniqueInput? where,
    Input$ProductFamilyCreateWithoutProductsInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductFamilyWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create =>
      CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(_res);
}

class Input$TransactionProductCreateNestedManyWithoutProductInput {
  factory Input$TransactionProductCreateNestedManyWithoutProductInput({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductWhereUniqueInput>? connect,
  }) =>
      Input$TransactionProductCreateNestedManyWithoutProductInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionProductCreateNestedManyWithoutProductInput._(this._$data);

  factory Input$TransactionProductCreateNestedManyWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductCreateWithoutProductInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductCreateOrConnectWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionProductCreateNestedManyWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionProductCreateWithoutProductInput>? get create =>
      (_$data['create']
          as List<Input$TransactionProductCreateWithoutProductInput>?);
  List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionProductCreateOrConnectWithoutProductInput>?);
  List<Input$TransactionProductWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionProductWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<
          Input$TransactionProductCreateNestedManyWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductCreateNestedManyWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput(
    Input$TransactionProductCreateNestedManyWithoutProductInput instance,
    TRes Function(Input$TransactionProductCreateNestedManyWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductCreateNestedManyWithoutProductInput;

  factory CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductCreateNestedManyWithoutProductInput;

  TRes call({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$TransactionProductCreateWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductCreateWithoutProductInput<
                      Input$TransactionProductCreateWithoutProductInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionProductCreateOrConnectWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
                      Input$TransactionProductCreateOrConnectWithoutProductInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionProductWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereUniqueInput<
                      Input$TransactionProductWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionProductCreateNestedManyWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductCreateNestedManyWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductCreateNestedManyWithoutProductInput _instance;

  final TRes Function(
      Input$TransactionProductCreateNestedManyWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionProductCreateNestedManyWithoutProductInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as List<Input$TransactionProductCreateWithoutProductInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate as List<
              Input$TransactionProductCreateOrConnectWithoutProductInput>?),
        if (connect != _undefined)
          'connect':
              (connect as List<Input$TransactionProductWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionProductCreateWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductCreateWithoutProductInput<
                          Input$TransactionProductCreateWithoutProductInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map(
              (e) => CopyWith$Input$TransactionProductCreateWithoutProductInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionProductCreateOrConnectWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
                          Input$TransactionProductCreateOrConnectWithoutProductInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$TransactionProductWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereUniqueInput<
                          Input$TransactionProductWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionProductWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionProductCreateNestedManyWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductCreateNestedManyWithoutProductInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$TransactionProductCreateWithoutProductInput {
  factory Input$TransactionProductCreateWithoutProductInput({
    required int quantity,
    required double price,
    required String product_name,
  }) =>
      Input$TransactionProductCreateWithoutProductInput._({
        r'quantity': quantity,
        r'price': price,
        r'product_name': product_name,
      });

  Input$TransactionProductCreateWithoutProductInput._(this._$data);

  factory Input$TransactionProductCreateWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$price = data['price'];
    result$data['price'] = (l$price as num).toDouble();
    final l$product_name = data['product_name'];
    result$data['product_name'] = (l$product_name as String);
    return Input$TransactionProductCreateWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  double get price => (_$data['price'] as double);
  String get product_name => (_$data['product_name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$price = price;
    result$data['price'] = l$price;
    final l$product_name = product_name;
    result$data['product_name'] = l$product_name;
    return result$data;
  }

  CopyWith$Input$TransactionProductCreateWithoutProductInput<
          Input$TransactionProductCreateWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductCreateWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductCreateWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      l$quantity,
      l$price,
      l$product_name,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductCreateWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductCreateWithoutProductInput(
    Input$TransactionProductCreateWithoutProductInput instance,
    TRes Function(Input$TransactionProductCreateWithoutProductInput) then,
  ) = _CopyWithImpl$Input$TransactionProductCreateWithoutProductInput;

  factory CopyWith$Input$TransactionProductCreateWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductCreateWithoutProductInput;

  TRes call({
    int? quantity,
    double? price,
    String? product_name,
  });
}

class _CopyWithImpl$Input$TransactionProductCreateWithoutProductInput<TRes>
    implements
        CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> {
  _CopyWithImpl$Input$TransactionProductCreateWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductCreateWithoutProductInput _instance;

  final TRes Function(Input$TransactionProductCreateWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductCreateWithoutProductInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (price != _undefined && price != null) 'price': (price as double),
        if (product_name != _undefined && product_name != null)
          'product_name': (product_name as String),
      }));
}

class _CopyWithStubImpl$Input$TransactionProductCreateWithoutProductInput<TRes>
    implements
        CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductCreateWithoutProductInput(
      this._res);

  TRes _res;

  call({
    int? quantity,
    double? price,
    String? product_name,
  }) =>
      _res;
}

class Input$TransactionProductCreateOrConnectWithoutProductInput {
  factory Input$TransactionProductCreateOrConnectWithoutProductInput({
    required Input$TransactionProductWhereUniqueInput where,
    required Input$TransactionProductCreateWithoutProductInput create,
  }) =>
      Input$TransactionProductCreateOrConnectWithoutProductInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionProductCreateOrConnectWithoutProductInput._(this._$data);

  factory Input$TransactionProductCreateOrConnectWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionProductWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionProductCreateWithoutProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionProductCreateOrConnectWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionProductWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionProductWhereUniqueInput);
  Input$TransactionProductCreateWithoutProductInput get create =>
      (_$data['create'] as Input$TransactionProductCreateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
          Input$TransactionProductCreateOrConnectWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductCreateOrConnectWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput(
    Input$TransactionProductCreateOrConnectWithoutProductInput instance,
    TRes Function(Input$TransactionProductCreateOrConnectWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductCreateOrConnectWithoutProductInput;

  factory CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductCreateOrConnectWithoutProductInput;

  TRes call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductCreateWithoutProductInput? create,
  });
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionProductCreateOrConnectWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductCreateOrConnectWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductCreateOrConnectWithoutProductInput _instance;

  final TRes Function(
      Input$TransactionProductCreateOrConnectWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionProductCreateOrConnectWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionProductWhereUniqueInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionProductCreateWithoutProductInput),
      }));
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionProductWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionProductCreateWithoutProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductCreateOrConnectWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductCreateOrConnectWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductCreateWithoutProductInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionProductWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create =>
      CopyWith$Input$TransactionProductCreateWithoutProductInput.stub(_res);
}

class Input$ProductsCreateOrConnectWithoutProductModelInput {
  factory Input$ProductsCreateOrConnectWithoutProductModelInput({
    required Input$ProductsWhereUniqueInput where,
    required Input$ProductsCreateWithoutProductModelInput create,
  }) =>
      Input$ProductsCreateOrConnectWithoutProductModelInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductsCreateOrConnectWithoutProductModelInput._(this._$data);

  factory Input$ProductsCreateOrConnectWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductsCreateWithoutProductModelInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductsCreateOrConnectWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductsWhereUniqueInput);
  Input$ProductsCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<
          Input$ProductsCreateOrConnectWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateOrConnectWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput(
    Input$ProductsCreateOrConnectWithoutProductModelInput instance,
    TRes Function(Input$ProductsCreateOrConnectWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateOrConnectWithoutProductModelInput;

  factory CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutProductModelInput;

  TRes call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateOrConnectWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateOrConnectWithoutProductModelInput _instance;

  final TRes Function(Input$ProductsCreateOrConnectWithoutProductModelInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsCreateOrConnectWithoutProductModelInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductsCreateWithoutProductModelInput),
      }));
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutProductModelInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(_res);
}

class Input$SizesCreateNestedOneWithoutProductModelInput {
  factory Input$SizesCreateNestedOneWithoutProductModelInput({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesWhereUniqueInput? connect,
  }) =>
      Input$SizesCreateNestedOneWithoutProductModelInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$SizesCreateNestedOneWithoutProductModelInput._(this._$data);

  factory Input$SizesCreateNestedOneWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$SizesCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$SizesCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$SizesWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$SizesCreateNestedOneWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SizesCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$SizesCreateWithoutProductModelInput?);
  Input$SizesCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$SizesCreateOrConnectWithoutProductModelInput?);
  Input$SizesWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$SizesWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<
          Input$SizesCreateNestedOneWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesCreateNestedOneWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput(
    Input$SizesCreateNestedOneWithoutProductModelInput instance,
    TRes Function(Input$SizesCreateNestedOneWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$SizesCreateNestedOneWithoutProductModelInput;

  factory CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SizesCreateNestedOneWithoutProductModelInput;

  TRes call({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesWhereUniqueInput? connect,
  });
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$SizesCreateNestedOneWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$SizesCreateNestedOneWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$SizesCreateNestedOneWithoutProductModelInput _instance;

  final TRes Function(Input$SizesCreateNestedOneWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$SizesCreateNestedOneWithoutProductModelInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$SizesCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$SizesCreateOrConnectWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$SizesWhereUniqueInput?),
      }));
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$SizesCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$SizesWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$SizesWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$SizesCreateNestedOneWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$SizesCreateNestedOneWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$SizesCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$SizesWhereUniqueInput.stub(_res);
}

class Input$SizesCreateWithoutProductModelInput {
  factory Input$SizesCreateWithoutProductModelInput({
    required int id,
    required String size,
  }) =>
      Input$SizesCreateWithoutProductModelInput._({
        r'id': id,
        r'size': size,
      });

  Input$SizesCreateWithoutProductModelInput._(this._$data);

  factory Input$SizesCreateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as int);
    final l$size = data['size'];
    result$data['size'] = (l$size as String);
    return Input$SizesCreateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get id => (_$data['id'] as int);
  String get size => (_$data['size'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$size = size;
    result$data['size'] = l$size;
    return result$data;
  }

  CopyWith$Input$SizesCreateWithoutProductModelInput<
          Input$SizesCreateWithoutProductModelInput>
      get copyWith => CopyWith$Input$SizesCreateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesCreateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      l$id,
      l$size,
    ]);
  }
}

abstract class CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$SizesCreateWithoutProductModelInput(
    Input$SizesCreateWithoutProductModelInput instance,
    TRes Function(Input$SizesCreateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$SizesCreateWithoutProductModelInput;

  factory CopyWith$Input$SizesCreateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesCreateWithoutProductModelInput;

  TRes call({
    int? id,
    String? size,
  });
}

class _CopyWithImpl$Input$SizesCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$SizesCreateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$SizesCreateWithoutProductModelInput _instance;

  final TRes Function(Input$SizesCreateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesCreateWithoutProductModelInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as int),
        if (size != _undefined && size != null) 'size': (size as String),
      }));
}

class _CopyWithStubImpl$Input$SizesCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$SizesCreateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    int? id,
    String? size,
  }) =>
      _res;
}

class Input$SizesCreateOrConnectWithoutProductModelInput {
  factory Input$SizesCreateOrConnectWithoutProductModelInput({
    required Input$SizesWhereUniqueInput where,
    required Input$SizesCreateWithoutProductModelInput create,
  }) =>
      Input$SizesCreateOrConnectWithoutProductModelInput._({
        r'where': where,
        r'create': create,
      });

  Input$SizesCreateOrConnectWithoutProductModelInput._(this._$data);

  factory Input$SizesCreateOrConnectWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$SizesWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$SizesCreateWithoutProductModelInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$SizesCreateOrConnectWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SizesWhereUniqueInput get where =>
      (_$data['where'] as Input$SizesWhereUniqueInput);
  Input$SizesCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$SizesCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<
          Input$SizesCreateOrConnectWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesCreateOrConnectWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput(
    Input$SizesCreateOrConnectWithoutProductModelInput instance,
    TRes Function(Input$SizesCreateOrConnectWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$SizesCreateOrConnectWithoutProductModelInput;

  factory CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SizesCreateOrConnectWithoutProductModelInput;

  TRes call({
    Input$SizesWhereUniqueInput? where,
    Input$SizesCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$SizesWhereUniqueInput<TRes> get where;
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$SizesCreateOrConnectWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$SizesCreateOrConnectWithoutProductModelInput _instance;

  final TRes Function(Input$SizesCreateOrConnectWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$SizesCreateOrConnectWithoutProductModelInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$SizesWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$SizesCreateWithoutProductModelInput),
      }));
  CopyWith$Input$SizesWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$SizesWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$SizesCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$SizesCreateOrConnectWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$SizesWhereUniqueInput? where,
    Input$SizesCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$SizesWhereUniqueInput<TRes> get where =>
      CopyWith$Input$SizesWhereUniqueInput.stub(_res);
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$SizesCreateWithoutProductModelInput.stub(_res);
}

class Input$ProductModelCreateOrConnectWithoutColorInput {
  factory Input$ProductModelCreateOrConnectWithoutColorInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelCreateWithoutColorInput create,
  }) =>
      Input$ProductModelCreateOrConnectWithoutColorInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductModelCreateOrConnectWithoutColorInput._(this._$data);

  factory Input$ProductModelCreateOrConnectWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductModelCreateWithoutColorInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductModelCreateOrConnectWithoutColorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelCreateWithoutColorInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutColorInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
          Input$ProductModelCreateOrConnectWithoutColorInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateOrConnectWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput(
    Input$ProductModelCreateOrConnectWithoutColorInput instance,
    TRes Function(Input$ProductModelCreateOrConnectWithoutColorInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutColorInput;

  factory CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutColorInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutColorInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutColorInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateOrConnectWithoutColorInput _instance;

  final TRes Function(Input$ProductModelCreateOrConnectWithoutColorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelCreateOrConnectWithoutColorInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutColorInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutColorInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutColorInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutColorInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutColorInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutColorInput.stub(_res);
}

class Input$ColorsUpdateManyMutationInput {
  factory Input$ColorsUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  }) =>
      Input$ColorsUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsUpdateManyMutationInput._(this._$data);

  factory Input$ColorsUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$color as Map<String, dynamic>));
    }
    return Input$ColorsUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get color =>
      (_$data['color'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsUpdateManyMutationInput<
          Input$ColorsUpdateManyMutationInput>
      get copyWith => CopyWith$Input$ColorsUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$ColorsUpdateManyMutationInput(
    Input$ColorsUpdateManyMutationInput instance,
    TRes Function(Input$ColorsUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$ColorsUpdateManyMutationInput;

  factory CopyWith$Input$ColorsUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color;
}

class _CopyWithImpl$Input$ColorsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ColorsUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$ColorsUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$ColorsUpdateManyMutationInput _instance;

  final TRes Function(Input$ColorsUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (color != _undefined)
          'color': (color as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ColorsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ColorsUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$ColorsUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ColorsUpdateInput {
  factory Input$ColorsUpdateInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
    Input$ProductModelUpdateManyWithoutColorNestedInput? ProductModel,
  }) =>
      Input$ColorsUpdateInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ColorsUpdateInput._(this._$data);

  factory Input$ColorsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$color as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelUpdateManyWithoutColorNestedInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ColorsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get color =>
      (_$data['color'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductModelUpdateManyWithoutColorNestedInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelUpdateManyWithoutColorNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsUpdateInput<Input$ColorsUpdateInput> get copyWith =>
      CopyWith$Input$ColorsUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsUpdateInput<TRes> {
  factory CopyWith$Input$ColorsUpdateInput(
    Input$ColorsUpdateInput instance,
    TRes Function(Input$ColorsUpdateInput) then,
  ) = _CopyWithImpl$Input$ColorsUpdateInput;

  factory CopyWith$Input$ColorsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
    Input$ProductModelUpdateManyWithoutColorNestedInput? ProductModel,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color;
  CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$ColorsUpdateInput<TRes>
    implements CopyWith$Input$ColorsUpdateInput<TRes> {
  _CopyWithImpl$Input$ColorsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ColorsUpdateInput _instance;

  final TRes Function(Input$ColorsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ColorsUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (color != _undefined)
          'color': (color as Input$StringFieldUpdateOperationsInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelUpdateManyWithoutColorNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$color, (e) => call(color: e));
  }

  CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ColorsUpdateInput<TRes>
    implements CopyWith$Input$ColorsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ColorsUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
    Input$ProductModelUpdateManyWithoutColorNestedInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput.stub(
              _res);
}

class Input$ProductModelUpdateManyWithoutColorNestedInput {
  factory Input$ProductModelUpdateManyWithoutColorNestedInput({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      Input$ProductModelUpdateManyWithoutColorNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$ProductModelUpdateManyWithoutColorNestedInput._(this._$data);

  factory Input$ProductModelUpdateManyWithoutColorNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutColorInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutColorInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpsertWithWhereUniqueWithoutColorInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateWithWhereUniqueWithoutColorInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateManyWithWhereWithoutColorInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelUpdateManyWithoutColorNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutColorInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutColorInput>?);
  List<Input$ProductModelCreateOrConnectWithoutColorInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutColorInput>?);
  List<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? get upsert =>
      (_$data['upsert']
          as List<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>?);
  List<Input$ProductModelWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? get update =>
      (_$data['update']
          as List<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>?);
  List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>?);
  List<Input$ProductModelScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$ProductModelScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<
          Input$ProductModelUpdateManyWithoutColorNestedInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithoutColorNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput(
    Input$ProductModelUpdateManyWithoutColorNestedInput instance,
    TRes Function(Input$ProductModelUpdateManyWithoutColorNestedInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithoutColorNestedInput;

  factory CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutColorNestedInput;

  TRes call({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutColorInput<
                      Input$ProductModelCreateWithoutColorInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
                      Input$ProductModelCreateOrConnectWithoutColorInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
                      Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
                      Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$ProductModelUpdateManyWithWhereWithoutColorInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<
                      Input$ProductModelUpdateManyWithWhereWithoutColorInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithoutColorNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithoutColorNestedInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithoutColorNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithoutColorNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$ProductModelCreateWithoutColorInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutColorInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$ProductModelWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$ProductModelWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$ProductModelWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$ProductModelScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutColorInput<
                          Input$ProductModelCreateWithoutColorInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutColorInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput<
                          Input$ProductModelCreateOrConnectWithoutColorInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$ProductModelCreateOrConnectWithoutColorInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
                          Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
                          Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$ProductModelUpdateManyWithWhereWithoutColorInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<
                          Input$ProductModelUpdateManyWithWhereWithoutColorInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutColorNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutColorNestedInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutColorNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutColorInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutColorInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutColorInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$ProductModelUpsertWithWhereUniqueWithoutColorInput {
  factory Input$ProductModelUpsertWithWhereUniqueWithoutColorInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutColorInput update,
    required Input$ProductModelCreateWithoutColorInput create,
  }) =>
      Input$ProductModelUpsertWithWhereUniqueWithoutColorInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$ProductModelUpsertWithWhereUniqueWithoutColorInput._(this._$data);

  factory Input$ProductModelUpsertWithWhereUniqueWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$ProductModelUpdateWithoutColorInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductModelCreateWithoutColorInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductModelUpsertWithWhereUniqueWithoutColorInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutColorInput get update =>
      (_$data['update'] as Input$ProductModelUpdateWithoutColorInput);
  Input$ProductModelCreateWithoutColorInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutColorInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
          Input$ProductModelUpsertWithWhereUniqueWithoutColorInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpsertWithWhereUniqueWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput(
    Input$ProductModelUpsertWithWhereUniqueWithoutColorInput instance,
    TRes Function(Input$ProductModelUpsertWithWhereUniqueWithoutColorInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput;

  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutColorInput? update,
    Input$ProductModelCreateWithoutColorInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get update;
  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpsertWithWhereUniqueWithoutColorInput _instance;

  final TRes Function(Input$ProductModelUpsertWithWhereUniqueWithoutColorInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelUpsertWithWhereUniqueWithoutColorInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$ProductModelUpdateWithoutColorInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutColorInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductModelUpdateWithoutColorInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutColorInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutColorInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutColorInput? update,
    Input$ProductModelCreateWithoutColorInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get update =>
      CopyWith$Input$ProductModelUpdateWithoutColorInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutColorInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutColorInput.stub(_res);
}

class Input$ProductModelUpdateWithoutColorInput {
  factory Input$ProductModelUpdateWithoutColorInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
  }) =>
      Input$ProductModelUpdateWithoutColorInput._({
        if (quantity != null) r'quantity': quantity,
        if (product != null) r'product': product,
        if (size != null) r'size': size,
      });

  Input$ProductModelUpdateWithoutColorInput._(this._$data);

  factory Input$ProductModelUpdateWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$product as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$SizesUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    return Input$ProductModelUpdateWithoutColorInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? get product =>
      (_$data['product']
          as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?);
  Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? get size =>
      (_$data['size']
          as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithoutColorInput<
          Input$ProductModelUpdateWithoutColorInput>
      get copyWith => CopyWith$Input$ProductModelUpdateWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('product') ? l$product : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> {
  factory CopyWith$Input$ProductModelUpdateWithoutColorInput(
    Input$ProductModelUpdateWithoutColorInput instance,
    TRes Function(Input$ProductModelUpdateWithoutColorInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithoutColorInput;

  factory CopyWith$Input$ProductModelUpdateWithoutColorInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithoutColorInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product;
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size;
}

class _CopyWithImpl$Input$ProductModelUpdateWithoutColorInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithoutColorInput _instance;

  final TRes Function(Input$ProductModelUpdateWithoutColorInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithoutColorInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (product != _undefined)
          'product': (product
              as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?),
        if (size != _undefined)
          'size': (size
              as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
            local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
            local$size, (e) => call(size: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithoutColorInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithoutColorInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size =>
          CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
}

class Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput {
  factory Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsUpsertWithoutProductModelInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutProductModelInput? update,
  }) =>
      Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput._(this._$data);

  factory Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductsCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductsCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$ProductsUpsertWithoutProductModelInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$ProductsUpdateWithoutProductModelInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$ProductsCreateWithoutProductModelInput?);
  Input$ProductsCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ProductsCreateOrConnectWithoutProductModelInput?);
  Input$ProductsUpsertWithoutProductModelInput? get upsert =>
      (_$data['upsert'] as Input$ProductsUpsertWithoutProductModelInput?);
  Input$ProductsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductsWhereUniqueInput?);
  Input$ProductsUpdateWithoutProductModelInput? get update =>
      (_$data['update'] as Input$ProductsUpdateWithoutProductModelInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
          Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput>
      get copyWith =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
    TRes> {
  factory CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput instance,
    TRes Function(Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput)
        then,
  ) = _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput;

  factory CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput;

  TRes call({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsUpsertWithoutProductModelInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutProductModelInput? update,
  });
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> get upsert;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect;
  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update;
}

class _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput _instance;

  final TRes Function(
      Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ProductsCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductsCreateOrConnectWithoutProductModelInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$ProductsUpsertWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductsWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$ProductsUpdateWithoutProductModelInput?),
      }));
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$ProductsUpsertWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsUpsertWithoutProductModelInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$ProductsUpdateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsUpdateWithoutProductModelInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsCreateWithoutProductModelInput? create,
    Input$ProductsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ProductsUpsertWithoutProductModelInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutProductModelInput? update,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductsCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> get upsert =>
      CopyWith$Input$ProductsUpsertWithoutProductModelInput.stub(_res);
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$ProductsUpdateWithoutProductModelInput.stub(_res);
}

class Input$ProductsUpsertWithoutProductModelInput {
  factory Input$ProductsUpsertWithoutProductModelInput({
    required Input$ProductsUpdateWithoutProductModelInput update,
    required Input$ProductsCreateWithoutProductModelInput create,
  }) =>
      Input$ProductsUpsertWithoutProductModelInput._({
        r'update': update,
        r'create': create,
      });

  Input$ProductsUpsertWithoutProductModelInput._(this._$data);

  factory Input$ProductsUpsertWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$ProductsUpdateWithoutProductModelInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductsCreateWithoutProductModelInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductsUpsertWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsUpdateWithoutProductModelInput get update =>
      (_$data['update'] as Input$ProductsUpdateWithoutProductModelInput);
  Input$ProductsCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsUpsertWithoutProductModelInput<
          Input$ProductsUpsertWithoutProductModelInput>
      get copyWith => CopyWith$Input$ProductsUpsertWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpsertWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ProductsUpsertWithoutProductModelInput(
    Input$ProductsUpsertWithoutProductModelInput instance,
    TRes Function(Input$ProductsUpsertWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ProductsUpsertWithoutProductModelInput;

  factory CopyWith$Input$ProductsUpsertWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsUpsertWithoutProductModelInput;

  TRes call({
    Input$ProductsUpdateWithoutProductModelInput? update,
    Input$ProductsCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update;
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ProductsUpsertWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpsertWithoutProductModelInput _instance;

  final TRes Function(Input$ProductsUpsertWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsUpsertWithoutProductModelInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$ProductsUpdateWithoutProductModelInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductsCreateWithoutProductModelInput),
      }));
  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductsUpdateWithoutProductModelInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsUpsertWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpsertWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$ProductsUpdateWithoutProductModelInput? update,
    Input$ProductsCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$ProductsUpdateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ProductsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutProductModelInput.stub(_res);
}

class Input$ProductsUpdateWithoutProductModelInput {
  factory Input$ProductsUpdateWithoutProductModelInput({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      Input$ProductsUpdateWithoutProductModelInput._({
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family != null) r'family': family,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsUpdateWithoutProductModelInput._(this._$data);

  factory Input$ProductsUpdateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family')) {
      final l$family = data['family'];
      result$data['family'] = l$family == null
          ? null
          : Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .fromJson((l$family as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductUpdateManyWithoutProductNestedInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsUpdateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get reference =>
      (_$data['reference'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? get family =>
      (_$data['family']
          as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?);
  Input$TransactionProductUpdateManyWithoutProductNestedInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductUpdateManyWithoutProductNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family')) {
      final l$family = family;
      result$data['family'] = l$family?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateWithoutProductModelInput<
          Input$ProductsUpdateWithoutProductModelInput>
      get copyWith => CopyWith$Input$ProductsUpdateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (_$data.containsKey('family') != other._$data.containsKey('family')) {
      return false;
    }
    if (l$family != lOther$family) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family') ? l$family : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ProductsUpdateWithoutProductModelInput(
    Input$ProductsUpdateWithoutProductModelInput instance,
    TRes Function(Input$ProductsUpdateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateWithoutProductModelInput;

  factory CopyWith$Input$ProductsUpdateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateWithoutProductModelInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family;
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateWithoutProductModelInput _instance;

  final TRes Function(Input$ProductsUpdateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsUpdateWithoutProductModelInput._({
        ..._instance._$data,
        if (reference != _undefined)
          'reference': (reference as Input$IntFieldUpdateOperationsInput?),
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (buyingPrice != _undefined)
          'buyingPrice':
              (buyingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (sellingPrice != _undefined)
          'sellingPrice':
              (sellingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
        if (family != _undefined)
          'family': (family
              as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductUpdateManyWithoutProductNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family {
    final local$family = _instance.family;
    return local$family == null
        ? CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
            local$family, (e) => call(family: e));
  }

  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ProductsUpdateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
              .stub(_res);
}

class Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput {
  factory Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyUpsertWithoutProductsInput? upsert,
    Input$ProductFamilyWhereUniqueInput? connect,
    Input$ProductFamilyUpdateWithoutProductsInput? update,
  }) =>
      Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput._(this._$data);

  factory Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductFamilyCreateWithoutProductsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductFamilyCreateOrConnectWithoutProductsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$ProductFamilyUpsertWithoutProductsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductFamilyWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$ProductFamilyUpdateWithoutProductsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductFamilyCreateWithoutProductsInput? get create =>
      (_$data['create'] as Input$ProductFamilyCreateWithoutProductsInput?);
  Input$ProductFamilyCreateOrConnectWithoutProductsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ProductFamilyCreateOrConnectWithoutProductsInput?);
  Input$ProductFamilyUpsertWithoutProductsInput? get upsert =>
      (_$data['upsert'] as Input$ProductFamilyUpsertWithoutProductsInput?);
  Input$ProductFamilyWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductFamilyWhereUniqueInput?);
  Input$ProductFamilyUpdateWithoutProductsInput? get update =>
      (_$data['update'] as Input$ProductFamilyUpdateWithoutProductsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
          Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput>
      get copyWith =>
          CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
    TRes> {
  factory CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput instance,
    TRes Function(
            Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput)
        then,
  ) = _CopyWithImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput;

  factory CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput;

  TRes call({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyUpsertWithoutProductsInput? upsert,
    Input$ProductFamilyWhereUniqueInput? connect,
    Input$ProductFamilyUpdateWithoutProductsInput? update,
  });
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create;
  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> get upsert;
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect;
  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update;
}

class _CopyWithImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
            TRes> {
  _CopyWithImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
      _instance;

  final TRes Function(
      Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ProductFamilyCreateWithoutProductsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductFamilyCreateOrConnectWithoutProductsInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$ProductFamilyUpsertWithoutProductsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductFamilyWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$ProductFamilyUpdateWithoutProductsInput?),
      }));
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$ProductFamilyUpsertWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyUpsertWithoutProductsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductFamilyWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductFamilyWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$ProductFamilyUpdateWithoutProductsInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductFamilyUpdateWithoutProductsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$ProductFamilyCreateWithoutProductsInput? create,
    Input$ProductFamilyCreateOrConnectWithoutProductsInput? connectOrCreate,
    Input$ProductFamilyUpsertWithoutProductsInput? upsert,
    Input$ProductFamilyWhereUniqueInput? connect,
    Input$ProductFamilyUpdateWithoutProductsInput? update,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create =>
      CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(_res);
  CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductFamilyCreateOrConnectWithoutProductsInput.stub(
              _res);
  CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> get upsert =>
      CopyWith$Input$ProductFamilyUpsertWithoutProductsInput.stub(_res);
  CopyWith$Input$ProductFamilyWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductFamilyWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update =>
      CopyWith$Input$ProductFamilyUpdateWithoutProductsInput.stub(_res);
}

class Input$ProductFamilyUpsertWithoutProductsInput {
  factory Input$ProductFamilyUpsertWithoutProductsInput({
    required Input$ProductFamilyUpdateWithoutProductsInput update,
    required Input$ProductFamilyCreateWithoutProductsInput create,
  }) =>
      Input$ProductFamilyUpsertWithoutProductsInput._({
        r'update': update,
        r'create': create,
      });

  Input$ProductFamilyUpsertWithoutProductsInput._(this._$data);

  factory Input$ProductFamilyUpsertWithoutProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$ProductFamilyUpdateWithoutProductsInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductFamilyCreateWithoutProductsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductFamilyUpsertWithoutProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductFamilyUpdateWithoutProductsInput get update =>
      (_$data['update'] as Input$ProductFamilyUpdateWithoutProductsInput);
  Input$ProductFamilyCreateWithoutProductsInput get create =>
      (_$data['create'] as Input$ProductFamilyCreateWithoutProductsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<
          Input$ProductFamilyUpsertWithoutProductsInput>
      get copyWith => CopyWith$Input$ProductFamilyUpsertWithoutProductsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyUpsertWithoutProductsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> {
  factory CopyWith$Input$ProductFamilyUpsertWithoutProductsInput(
    Input$ProductFamilyUpsertWithoutProductsInput instance,
    TRes Function(Input$ProductFamilyUpsertWithoutProductsInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyUpsertWithoutProductsInput;

  factory CopyWith$Input$ProductFamilyUpsertWithoutProductsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyUpsertWithoutProductsInput;

  TRes call({
    Input$ProductFamilyUpdateWithoutProductsInput? update,
    Input$ProductFamilyCreateWithoutProductsInput? create,
  });
  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update;
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductFamilyUpsertWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyUpsertWithoutProductsInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyUpsertWithoutProductsInput _instance;

  final TRes Function(Input$ProductFamilyUpsertWithoutProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductFamilyUpsertWithoutProductsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$ProductFamilyUpdateWithoutProductsInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductFamilyCreateWithoutProductsInput),
      }));
  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductFamilyUpdateWithoutProductsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductFamilyCreateWithoutProductsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyUpsertWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyUpsertWithoutProductsInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyUpsertWithoutProductsInput(this._res);

  TRes _res;

  call({
    Input$ProductFamilyUpdateWithoutProductsInput? update,
    Input$ProductFamilyCreateWithoutProductsInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> get update =>
      CopyWith$Input$ProductFamilyUpdateWithoutProductsInput.stub(_res);
  CopyWith$Input$ProductFamilyCreateWithoutProductsInput<TRes> get create =>
      CopyWith$Input$ProductFamilyCreateWithoutProductsInput.stub(_res);
}

class Input$ProductFamilyUpdateWithoutProductsInput {
  factory Input$ProductFamilyUpdateWithoutProductsInput(
          {Input$StringFieldUpdateOperationsInput? name}) =>
      Input$ProductFamilyUpdateWithoutProductsInput._({
        if (name != null) r'name': name,
      });

  Input$ProductFamilyUpdateWithoutProductsInput._(this._$data);

  factory Input$ProductFamilyUpdateWithoutProductsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    return Input$ProductFamilyUpdateWithoutProductsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<
          Input$ProductFamilyUpdateWithoutProductsInput>
      get copyWith => CopyWith$Input$ProductFamilyUpdateWithoutProductsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyUpdateWithoutProductsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([_$data.containsKey('name') ? l$name : const {}]);
  }
}

abstract class CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> {
  factory CopyWith$Input$ProductFamilyUpdateWithoutProductsInput(
    Input$ProductFamilyUpdateWithoutProductsInput instance,
    TRes Function(Input$ProductFamilyUpdateWithoutProductsInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyUpdateWithoutProductsInput;

  factory CopyWith$Input$ProductFamilyUpdateWithoutProductsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyUpdateWithoutProductsInput;

  TRes call({Input$StringFieldUpdateOperationsInput? name});
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
}

class _CopyWithImpl$Input$ProductFamilyUpdateWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyUpdateWithoutProductsInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyUpdateWithoutProductsInput _instance;

  final TRes Function(Input$ProductFamilyUpdateWithoutProductsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) =>
      _then(Input$ProductFamilyUpdateWithoutProductsInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyUpdateWithoutProductsInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateWithoutProductsInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyUpdateWithoutProductsInput(this._res);

  TRes _res;

  call({Input$StringFieldUpdateOperationsInput? name}) => _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionProductUpdateManyWithoutProductNestedInput {
  factory Input$TransactionProductUpdateManyWithoutProductNestedInput({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?
        upsert,
    List<Input$TransactionProductWhereUniqueInput>? $set,
    List<Input$TransactionProductWhereUniqueInput>? disconnect,
    List<Input$TransactionProductWhereUniqueInput>? delete,
    List<Input$TransactionProductWhereUniqueInput>? connect,
    List<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?
        update,
    List<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?
        updateMany,
    List<Input$TransactionProductScalarWhereInput>? deleteMany,
  }) =>
      Input$TransactionProductUpdateManyWithoutProductNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$TransactionProductUpdateManyWithoutProductNestedInput._(this._$data);

  factory Input$TransactionProductUpdateManyWithoutProductNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductCreateWithoutProductInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductCreateOrConnectWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionProductWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionProductUpdateManyWithWhereWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$TransactionProductScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionProductUpdateManyWithoutProductNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionProductCreateWithoutProductInput>? get create =>
      (_$data['create']
          as List<Input$TransactionProductCreateWithoutProductInput>?);
  List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionProductCreateOrConnectWithoutProductInput>?);
  List<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?
      get upsert => (_$data['upsert'] as List<
          Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?);
  List<Input$TransactionProductWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$TransactionProductWhereUniqueInput>?);
  List<Input$TransactionProductWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$TransactionProductWhereUniqueInput>?);
  List<Input$TransactionProductWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$TransactionProductWhereUniqueInput>?);
  List<Input$TransactionProductWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionProductWhereUniqueInput>?);
  List<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?
      get update => (_$data['update'] as List<
          Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?);
  List<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?
      get updateMany => (_$data['updateMany'] as List<
          Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?);
  List<Input$TransactionProductScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$TransactionProductScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<
          Input$TransactionProductUpdateManyWithoutProductNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductUpdateManyWithoutProductNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput(
    Input$TransactionProductUpdateManyWithoutProductNestedInput instance,
    TRes Function(Input$TransactionProductUpdateManyWithoutProductNestedInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput;

  factory CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput;

  TRes call({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?
        upsert,
    List<Input$TransactionProductWhereUniqueInput>? $set,
    List<Input$TransactionProductWhereUniqueInput>? disconnect,
    List<Input$TransactionProductWhereUniqueInput>? delete,
    List<Input$TransactionProductWhereUniqueInput>? connect,
    List<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?
        update,
    List<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?
        updateMany,
    List<Input$TransactionProductScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$TransactionProductCreateWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductCreateWithoutProductInput<
                      Input$TransactionProductCreateWithoutProductInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionProductCreateOrConnectWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
                      Input$TransactionProductCreateOrConnectWithoutProductInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
                      Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$TransactionProductWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereUniqueInput<
                      Input$TransactionProductWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$TransactionProductWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereUniqueInput<
                      Input$TransactionProductWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$TransactionProductWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereUniqueInput<
                      Input$TransactionProductWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionProductWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductWhereUniqueInput<
                      Input$TransactionProductWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
                      Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
                      Input$TransactionProductUpdateManyWithWhereWithoutProductInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$TransactionProductScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereInput<
                      Input$TransactionProductScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateManyWithoutProductNestedInput _instance;

  final TRes Function(
      Input$TransactionProductUpdateManyWithoutProductNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateManyWithoutProductNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as List<Input$TransactionProductCreateWithoutProductInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate as List<
              Input$TransactionProductCreateOrConnectWithoutProductInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$TransactionProductWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$TransactionProductWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$TransactionProductWhereUniqueInput>?),
        if (connect != _undefined)
          'connect':
              (connect as List<Input$TransactionProductWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$TransactionProductScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionProductCreateWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductCreateWithoutProductInput<
                          Input$TransactionProductCreateWithoutProductInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map(
              (e) => CopyWith$Input$TransactionProductCreateWithoutProductInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionProductCreateOrConnectWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput<
                          Input$TransactionProductCreateOrConnectWithoutProductInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionProductCreateOrConnectWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
                          Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$TransactionProductWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereUniqueInput<
                          Input$TransactionProductWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$TransactionProductWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$TransactionProductWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereUniqueInput<
                          Input$TransactionProductWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$TransactionProductWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$TransactionProductWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereUniqueInput<
                          Input$TransactionProductWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$TransactionProductWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionProductWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductWhereUniqueInput<
                          Input$TransactionProductWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionProductWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
                          Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
                          Input$TransactionProductUpdateManyWithWhereWithoutProductInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$TransactionProductScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereInput<
                          Input$TransactionProductScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$TransactionProductScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateManyWithoutProductNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionProductCreateWithoutProductInput>? create,
    List<Input$TransactionProductCreateOrConnectWithoutProductInput>?
        connectOrCreate,
    List<Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>?
        upsert,
    List<Input$TransactionProductWhereUniqueInput>? $set,
    List<Input$TransactionProductWhereUniqueInput>? disconnect,
    List<Input$TransactionProductWhereUniqueInput>? delete,
    List<Input$TransactionProductWhereUniqueInput>? connect,
    List<Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>?
        update,
    List<Input$TransactionProductUpdateManyWithWhereWithoutProductInput>?
        updateMany,
    List<Input$TransactionProductScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput {
  factory Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput({
    required Input$TransactionProductWhereUniqueInput where,
    required Input$TransactionProductUpdateWithoutProductInput update,
    required Input$TransactionProductCreateWithoutProductInput create,
  }) =>
      Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput._(
      this._$data);

  factory Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionProductWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$TransactionProductUpdateWithoutProductInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionProductCreateWithoutProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionProductWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionProductWhereUniqueInput);
  Input$TransactionProductUpdateWithoutProductInput get update =>
      (_$data['update'] as Input$TransactionProductUpdateWithoutProductInput);
  Input$TransactionProductCreateWithoutProductInput get create =>
      (_$data['create'] as Input$TransactionProductCreateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
          Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput(
    Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput instance,
    TRes Function(
            Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput;

  factory CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput;

  TRes call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductUpdateWithoutProductInput? update,
    Input$TransactionProductCreateWithoutProductInput? create,
  });
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get update;
  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput
      _instance;

  final TRes Function(
      Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionProductWhereUniqueInput),
        if (update != _undefined && update != null)
          'update':
              (update as Input$TransactionProductUpdateWithoutProductInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionProductCreateWithoutProductInput),
      }));
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionProductWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionProductUpdateWithoutProductInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionProductCreateWithoutProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpsertWithWhereUniqueWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductUpdateWithoutProductInput? update,
    Input$TransactionProductCreateWithoutProductInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionProductWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get update =>
      CopyWith$Input$TransactionProductUpdateWithoutProductInput.stub(_res);
  CopyWith$Input$TransactionProductCreateWithoutProductInput<TRes> get create =>
      CopyWith$Input$TransactionProductCreateWithoutProductInput.stub(_res);
}

class Input$TransactionProductUpdateWithoutProductInput {
  factory Input$TransactionProductUpdateWithoutProductInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  }) =>
      Input$TransactionProductUpdateWithoutProductInput._({
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductUpdateWithoutProductInput._(this._$data);

  factory Input$TransactionProductUpdateWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    return Input$TransactionProductUpdateWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get price =>
      (_$data['price'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get product_name =>
      (_$data['product_name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateWithoutProductInput<
          Input$TransactionProductUpdateWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductUpdateWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductUpdateWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductUpdateWithoutProductInput(
    Input$TransactionProductUpdateWithoutProductInput instance,
    TRes Function(Input$TransactionProductUpdateWithoutProductInput) then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateWithoutProductInput;

  factory CopyWith$Input$TransactionProductUpdateWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateWithoutProductInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name;
}

class _CopyWithImpl$Input$TransactionProductUpdateWithoutProductInput<TRes>
    implements
        CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateWithoutProductInput _instance;

  final TRes Function(Input$TransactionProductUpdateWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateWithoutProductInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (price != _undefined)
          'price': (price as Input$FloatFieldUpdateOperationsInput?),
        if (product_name != _undefined)
          'product_name':
              (product_name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$product_name, (e) => call(product_name: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpdateWithoutProductInput<TRes>
    implements
        CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput {
  factory Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput({
    required Input$TransactionProductWhereUniqueInput where,
    required Input$TransactionProductUpdateWithoutProductInput data,
  }) =>
      Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput._(
      this._$data);

  factory Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionProductWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] =
        Input$TransactionProductUpdateWithoutProductInput.fromJson(
            (l$data as Map<String, dynamic>));
    return Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionProductWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionProductWhereUniqueInput);
  Input$TransactionProductUpdateWithoutProductInput get data =>
      (_$data['data'] as Input$TransactionProductUpdateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
          Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput(
    Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput instance,
    TRes Function(
            Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput;

  factory CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput;

  TRes call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductUpdateWithoutProductInput? data,
  });
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput
      _instance;

  final TRes Function(
      Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionProductWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionProductUpdateWithoutProductInput),
      }));
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionProductWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionProductUpdateWithoutProductInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateWithWhereUniqueWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionProductWhereUniqueInput? where,
    Input$TransactionProductUpdateWithoutProductInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionProductWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionProductWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionProductUpdateWithoutProductInput<TRes> get data =>
      CopyWith$Input$TransactionProductUpdateWithoutProductInput.stub(_res);
}

class Input$TransactionProductUpdateManyWithWhereWithoutProductInput {
  factory Input$TransactionProductUpdateManyWithWhereWithoutProductInput({
    required Input$TransactionProductScalarWhereInput where,
    required Input$TransactionProductUpdateManyMutationInput data,
  }) =>
      Input$TransactionProductUpdateManyWithWhereWithoutProductInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionProductUpdateManyWithWhereWithoutProductInput._(this._$data);

  factory Input$TransactionProductUpdateManyWithWhereWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionProductScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] =
        Input$TransactionProductUpdateManyMutationInput.fromJson(
            (l$data as Map<String, dynamic>));
    return Input$TransactionProductUpdateManyWithWhereWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionProductScalarWhereInput get where =>
      (_$data['where'] as Input$TransactionProductScalarWhereInput);
  Input$TransactionProductUpdateManyMutationInput get data =>
      (_$data['data'] as Input$TransactionProductUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
          Input$TransactionProductUpdateManyWithWhereWithoutProductInput>
      get copyWith =>
          CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionProductUpdateManyWithWhereWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
    TRes> {
  factory CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput(
    Input$TransactionProductUpdateManyWithWhereWithoutProductInput instance,
    TRes Function(
            Input$TransactionProductUpdateManyWithWhereWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput;

  factory CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput;

  TRes call({
    Input$TransactionProductScalarWhereInput? where,
    Input$TransactionProductUpdateManyMutationInput? data,
  });
  CopyWith$Input$TransactionProductScalarWhereInput<TRes> get where;
  CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateManyWithWhereWithoutProductInput
      _instance;

  final TRes Function(
      Input$TransactionProductUpdateManyWithWhereWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateManyWithWhereWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionProductScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionProductUpdateManyMutationInput),
      }));
  CopyWith$Input$TransactionProductScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionProductScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionProductUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$TransactionProductUpdateManyWithWhereWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateManyWithWhereWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionProductScalarWhereInput? where,
    Input$TransactionProductUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionProductScalarWhereInput<TRes> get where =>
      CopyWith$Input$TransactionProductScalarWhereInput.stub(_res);
  CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$TransactionProductUpdateManyMutationInput.stub(_res);
}

class Input$TransactionProductScalarWhereInput {
  factory Input$TransactionProductScalarWhereInput({
    List<Input$TransactionProductScalarWhereInput>? AND,
    List<Input$TransactionProductScalarWhereInput>? OR,
    List<Input$TransactionProductScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
  }) =>
      Input$TransactionProductScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductScalarWhereInput._(this._$data);

  factory Input$TransactionProductScalarWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$TransactionProductScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$TransactionProductScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$TransactionProductScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFilter.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatFilter.fromJson((l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringFilter.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    return Input$TransactionProductScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionProductScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$TransactionProductScalarWhereInput>?);
  List<Input$TransactionProductScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$TransactionProductScalarWhereInput>?);
  List<Input$TransactionProductScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$TransactionProductScalarWhereInput>?);
  Input$IntFilter? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFilter?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Input$FloatFilter? get price => (_$data['price'] as Input$FloatFilter?);
  Input$StringFilter? get product_name =>
      (_$data['product_name'] as Input$StringFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductScalarWhereInput<
          Input$TransactionProductScalarWhereInput>
      get copyWith => CopyWith$Input$TransactionProductScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductScalarWhereInput<TRes> {
  factory CopyWith$Input$TransactionProductScalarWhereInput(
    Input$TransactionProductScalarWhereInput instance,
    TRes Function(Input$TransactionProductScalarWhereInput) then,
  ) = _CopyWithImpl$Input$TransactionProductScalarWhereInput;

  factory CopyWith$Input$TransactionProductScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductScalarWhereInput;

  TRes call({
    List<Input$TransactionProductScalarWhereInput>? AND,
    List<Input$TransactionProductScalarWhereInput>? OR,
    List<Input$TransactionProductScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
  });
  TRes AND(
      Iterable<Input$TransactionProductScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereInput<
                      Input$TransactionProductScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$TransactionProductScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereInput<
                      Input$TransactionProductScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$TransactionProductScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionProductScalarWhereInput<
                      Input$TransactionProductScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get transaction_id;
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get quantity;
  CopyWith$Input$FloatFilter<TRes> get price;
  CopyWith$Input$StringFilter<TRes> get product_name;
}

class _CopyWithImpl$Input$TransactionProductScalarWhereInput<TRes>
    implements CopyWith$Input$TransactionProductScalarWhereInput<TRes> {
  _CopyWithImpl$Input$TransactionProductScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductScalarWhereInput _instance;

  final TRes Function(Input$TransactionProductScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$TransactionProductScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$TransactionProductScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$TransactionProductScalarWhereInput>?),
        if (transaction_id != _undefined)
          'transaction_id': (transaction_id as Input$IntFilter?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
        if (price != _undefined) 'price': (price as Input$FloatFilter?),
        if (product_name != _undefined)
          'product_name': (product_name as Input$StringFilter?),
      }));
  TRes AND(
          Iterable<Input$TransactionProductScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereInput<
                          Input$TransactionProductScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$TransactionProductScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$TransactionProductScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereInput<
                          Input$TransactionProductScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$TransactionProductScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$TransactionProductScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionProductScalarWhereInput<
                          Input$TransactionProductScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$TransactionProductScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatFilter<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringFilter<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$product_name, (e) => call(product_name: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductScalarWhereInput<TRes>
    implements CopyWith$Input$TransactionProductScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$TransactionProductScalarWhereInput>? AND,
    List<Input$TransactionProductScalarWhereInput>? OR,
    List<Input$TransactionProductScalarWhereInput>? NOT,
    Input$IntFilter? transaction_id,
    Input$IntFilter? product_id,
    Input$IntFilter? quantity,
    Input$FloatFilter? price,
    Input$StringFilter? product_name,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get transaction_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get price =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get product_name =>
      CopyWith$Input$StringFilter.stub(_res);
}

class Input$TransactionProductUpdateManyMutationInput {
  factory Input$TransactionProductUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  }) =>
      Input$TransactionProductUpdateManyMutationInput._({
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
      });

  Input$TransactionProductUpdateManyMutationInput._(this._$data);

  factory Input$TransactionProductUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    return Input$TransactionProductUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get price =>
      (_$data['price'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get product_name =>
      (_$data['product_name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateManyMutationInput<
          Input$TransactionProductUpdateManyMutationInput>
      get copyWith => CopyWith$Input$TransactionProductUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$TransactionProductUpdateManyMutationInput(
    Input$TransactionProductUpdateManyMutationInput instance,
    TRes Function(Input$TransactionProductUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateManyMutationInput;

  factory CopyWith$Input$TransactionProductUpdateManyMutationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name;
}

class _CopyWithImpl$Input$TransactionProductUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateManyMutationInput _instance;

  final TRes Function(Input$TransactionProductUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateManyMutationInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (price != _undefined)
          'price': (price as Input$FloatFieldUpdateOperationsInput?),
        if (product_name != _undefined)
          'product_name':
              (product_name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$product_name, (e) => call(product_name: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionProductUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$SizesUpdateOneRequiredWithoutProductModelNestedInput {
  factory Input$SizesUpdateOneRequiredWithoutProductModelNestedInput({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesUpsertWithoutProductModelInput? upsert,
    Input$SizesWhereUniqueInput? connect,
    Input$SizesUpdateWithoutProductModelInput? update,
  }) =>
      Input$SizesUpdateOneRequiredWithoutProductModelNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$SizesUpdateOneRequiredWithoutProductModelNestedInput._(this._$data);

  factory Input$SizesUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$SizesCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$SizesCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$SizesUpsertWithoutProductModelInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$SizesWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$SizesUpdateWithoutProductModelInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$SizesUpdateOneRequiredWithoutProductModelNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$SizesCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$SizesCreateWithoutProductModelInput?);
  Input$SizesCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$SizesCreateOrConnectWithoutProductModelInput?);
  Input$SizesUpsertWithoutProductModelInput? get upsert =>
      (_$data['upsert'] as Input$SizesUpsertWithoutProductModelInput?);
  Input$SizesWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$SizesWhereUniqueInput?);
  Input$SizesUpdateWithoutProductModelInput? get update =>
      (_$data['update'] as Input$SizesUpdateWithoutProductModelInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
          Input$SizesUpdateOneRequiredWithoutProductModelNestedInput>
      get copyWith =>
          CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$SizesUpdateOneRequiredWithoutProductModelNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
    TRes> {
  factory CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput instance,
    TRes Function(Input$SizesUpdateOneRequiredWithoutProductModelNestedInput)
        then,
  ) = _CopyWithImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput;

  factory CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput;

  TRes call({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesUpsertWithoutProductModelInput? upsert,
    Input$SizesWhereUniqueInput? connect,
    Input$SizesUpdateWithoutProductModelInput? update,
  });
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> get upsert;
  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect;
  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update;
}

class _CopyWithImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
    this._instance,
    this._then,
  );

  final Input$SizesUpdateOneRequiredWithoutProductModelNestedInput _instance;

  final TRes Function(
      Input$SizesUpdateOneRequiredWithoutProductModelNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$SizesUpdateOneRequiredWithoutProductModelNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$SizesCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$SizesCreateOrConnectWithoutProductModelInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$SizesUpsertWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$SizesWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$SizesUpdateWithoutProductModelInput?),
      }));
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$SizesCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$SizesUpsertWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesUpsertWithoutProductModelInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$SizesWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$SizesWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$SizesUpdateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$SizesUpdateWithoutProductModelInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
      this._res);

  TRes _res;

  call({
    Input$SizesCreateWithoutProductModelInput? create,
    Input$SizesCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$SizesUpsertWithoutProductModelInput? upsert,
    Input$SizesWhereUniqueInput? connect,
    Input$SizesUpdateWithoutProductModelInput? update,
  }) =>
      _res;
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$SizesCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$SizesCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> get upsert =>
      CopyWith$Input$SizesUpsertWithoutProductModelInput.stub(_res);
  CopyWith$Input$SizesWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$SizesWhereUniqueInput.stub(_res);
  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$SizesUpdateWithoutProductModelInput.stub(_res);
}

class Input$SizesUpsertWithoutProductModelInput {
  factory Input$SizesUpsertWithoutProductModelInput({
    required Input$SizesUpdateWithoutProductModelInput update,
    required Input$SizesCreateWithoutProductModelInput create,
  }) =>
      Input$SizesUpsertWithoutProductModelInput._({
        r'update': update,
        r'create': create,
      });

  Input$SizesUpsertWithoutProductModelInput._(this._$data);

  factory Input$SizesUpsertWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$SizesUpdateWithoutProductModelInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$SizesCreateWithoutProductModelInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$SizesUpsertWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$SizesUpdateWithoutProductModelInput get update =>
      (_$data['update'] as Input$SizesUpdateWithoutProductModelInput);
  Input$SizesCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$SizesCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$SizesUpsertWithoutProductModelInput<
          Input$SizesUpsertWithoutProductModelInput>
      get copyWith => CopyWith$Input$SizesUpsertWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesUpsertWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> {
  factory CopyWith$Input$SizesUpsertWithoutProductModelInput(
    Input$SizesUpsertWithoutProductModelInput instance,
    TRes Function(Input$SizesUpsertWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$SizesUpsertWithoutProductModelInput;

  factory CopyWith$Input$SizesUpsertWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesUpsertWithoutProductModelInput;

  TRes call({
    Input$SizesUpdateWithoutProductModelInput? update,
    Input$SizesCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update;
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$SizesUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$SizesUpsertWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$SizesUpsertWithoutProductModelInput _instance;

  final TRes Function(Input$SizesUpsertWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$SizesUpsertWithoutProductModelInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$SizesUpdateWithoutProductModelInput),
        if (create != _undefined && create != null)
          'create': (create as Input$SizesCreateWithoutProductModelInput),
      }));
  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$SizesUpdateWithoutProductModelInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$SizesCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$SizesUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesUpsertWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$SizesUpsertWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$SizesUpdateWithoutProductModelInput? update,
    Input$SizesCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$SizesUpdateWithoutProductModelInput.stub(_res);
  CopyWith$Input$SizesCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$SizesCreateWithoutProductModelInput.stub(_res);
}

class Input$SizesUpdateWithoutProductModelInput {
  factory Input$SizesUpdateWithoutProductModelInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  }) =>
      Input$SizesUpdateWithoutProductModelInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesUpdateWithoutProductModelInput._(this._$data);

  factory Input$SizesUpdateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    return Input$SizesUpdateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get size =>
      (_$data['size'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesUpdateWithoutProductModelInput<
          Input$SizesUpdateWithoutProductModelInput>
      get copyWith => CopyWith$Input$SizesUpdateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesUpdateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$SizesUpdateWithoutProductModelInput(
    Input$SizesUpdateWithoutProductModelInput instance,
    TRes Function(Input$SizesUpdateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$SizesUpdateWithoutProductModelInput;

  factory CopyWith$Input$SizesUpdateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesUpdateWithoutProductModelInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size;
}

class _CopyWithImpl$Input$SizesUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$SizesUpdateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$SizesUpdateWithoutProductModelInput _instance;

  final TRes Function(Input$SizesUpdateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesUpdateWithoutProductModelInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (size != _undefined)
          'size': (size as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$size, (e) => call(size: e));
  }
}

class _CopyWithStubImpl$Input$SizesUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$SizesUpdateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$SizesUpdateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ProductModelUpdateWithWhereUniqueWithoutColorInput {
  factory Input$ProductModelUpdateWithWhereUniqueWithoutColorInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutColorInput data,
  }) =>
      Input$ProductModelUpdateWithWhereUniqueWithoutColorInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateWithWhereUniqueWithoutColorInput._(this._$data);

  factory Input$ProductModelUpdateWithWhereUniqueWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateWithoutColorInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateWithWhereUniqueWithoutColorInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutColorInput get data =>
      (_$data['data'] as Input$ProductModelUpdateWithoutColorInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
          Input$ProductModelUpdateWithWhereUniqueWithoutColorInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateWithWhereUniqueWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput(
    Input$ProductModelUpdateWithWhereUniqueWithoutColorInput instance,
    TRes Function(Input$ProductModelUpdateWithWhereUniqueWithoutColorInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput;

  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutColorInput? data,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithWhereUniqueWithoutColorInput _instance;

  final TRes Function(Input$ProductModelUpdateWithWhereUniqueWithoutColorInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithWhereUniqueWithoutColorInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateWithoutColorInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateWithoutColorInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutColorInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutColorInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutColorInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateWithoutColorInput.stub(_res);
}

class Input$ProductModelUpdateManyWithWhereWithoutColorInput {
  factory Input$ProductModelUpdateManyWithWhereWithoutColorInput({
    required Input$ProductModelScalarWhereInput where,
    required Input$ProductModelUpdateManyMutationInput data,
  }) =>
      Input$ProductModelUpdateManyWithWhereWithoutColorInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateManyWithWhereWithoutColorInput._(this._$data);

  factory Input$ProductModelUpdateManyWithWhereWithoutColorInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateManyWithWhereWithoutColorInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelScalarWhereInput get where =>
      (_$data['where'] as Input$ProductModelScalarWhereInput);
  Input$ProductModelUpdateManyMutationInput get data =>
      (_$data['data'] as Input$ProductModelUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<
          Input$ProductModelUpdateManyWithWhereWithoutColorInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithWhereWithoutColorInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput(
    Input$ProductModelUpdateManyWithWhereWithoutColorInput instance,
    TRes Function(Input$ProductModelUpdateManyWithWhereWithoutColorInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput;

  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput;

  TRes call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  });
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithWhereWithoutColorInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithWhereWithoutColorInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithWhereWithoutColorInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateManyMutationInput),
      }));
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutColorInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutColorInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where =>
      CopyWith$Input$ProductModelScalarWhereInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateManyMutationInput.stub(_res);
}

class Input$ProductModelScalarWhereInput {
  factory Input$ProductModelScalarWhereInput({
    List<Input$ProductModelScalarWhereInput>? AND,
    List<Input$ProductModelScalarWhereInput>? OR,
    List<Input$ProductModelScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
  }) =>
      Input$ProductModelScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (color_id != null) r'color_id': color_id,
        if (size_id != null) r'size_id': size_id,
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelScalarWhereInput._(this._$data);

  factory Input$ProductModelScalarWhereInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('color_id')) {
      final l$color_id = data['color_id'];
      result$data['color_id'] = l$color_id == null
          ? null
          : Input$IntFilter.fromJson((l$color_id as Map<String, dynamic>));
    }
    if (data.containsKey('size_id')) {
      final l$size_id = data['size_id'];
      result$data['size_id'] = l$size_id == null
          ? null
          : Input$IntFilter.fromJson((l$size_id as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFilter.fromJson((l$quantity as Map<String, dynamic>));
    }
    return Input$ProductModelScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductModelScalarWhereInput>?);
  List<Input$ProductModelScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductModelScalarWhereInput>?);
  List<Input$ProductModelScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductModelScalarWhereInput>?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get color_id => (_$data['color_id'] as Input$IntFilter?);
  Input$IntFilter? get size_id => (_$data['size_id'] as Input$IntFilter?);
  Input$IntFilter? get quantity => (_$data['quantity'] as Input$IntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('color_id')) {
      final l$color_id = color_id;
      result$data['color_id'] = l$color_id?.toJson();
    }
    if (_$data.containsKey('size_id')) {
      final l$size_id = size_id;
      result$data['size_id'] = l$size_id?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelScalarWhereInput<
          Input$ProductModelScalarWhereInput>
      get copyWith => CopyWith$Input$ProductModelScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$color_id = color_id;
    final lOther$color_id = other.color_id;
    if (_$data.containsKey('color_id') !=
        other._$data.containsKey('color_id')) {
      return false;
    }
    if (l$color_id != lOther$color_id) {
      return false;
    }
    final l$size_id = size_id;
    final lOther$size_id = other.size_id;
    if (_$data.containsKey('size_id') != other._$data.containsKey('size_id')) {
      return false;
    }
    if (l$size_id != lOther$size_id) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$color_id = color_id;
    final l$size_id = size_id;
    final l$quantity = quantity;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('color_id') ? l$color_id : const {},
      _$data.containsKey('size_id') ? l$size_id : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelScalarWhereInput<TRes> {
  factory CopyWith$Input$ProductModelScalarWhereInput(
    Input$ProductModelScalarWhereInput instance,
    TRes Function(Input$ProductModelScalarWhereInput) then,
  ) = _CopyWithImpl$Input$ProductModelScalarWhereInput;

  factory CopyWith$Input$ProductModelScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelScalarWhereInput;

  TRes call({
    List<Input$ProductModelScalarWhereInput>? AND,
    List<Input$ProductModelScalarWhereInput>? OR,
    List<Input$ProductModelScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
  });
  TRes AND(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get color_id;
  CopyWith$Input$IntFilter<TRes> get size_id;
  CopyWith$Input$IntFilter<TRes> get quantity;
}

class _CopyWithImpl$Input$ProductModelScalarWhereInput<TRes>
    implements CopyWith$Input$ProductModelScalarWhereInput<TRes> {
  _CopyWithImpl$Input$ProductModelScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelScalarWhereInput _instance;

  final TRes Function(Input$ProductModelScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? color_id = _undefined,
    Object? size_id = _undefined,
    Object? quantity = _undefined,
  }) =>
      _then(Input$ProductModelScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductModelScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductModelScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ProductModelScalarWhereInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (color_id != _undefined) 'color_id': (color_id as Input$IntFilter?),
        if (size_id != _undefined) 'size_id': (size_id as Input$IntFilter?),
        if (quantity != _undefined) 'quantity': (quantity as Input$IntFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(_instance.AND
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(_instance.OR
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(_instance.NOT
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get color_id {
    final local$color_id = _instance.color_id;
    return local$color_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$color_id, (e) => call(color_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get size_id {
    final local$size_id = _instance.size_id;
    return local$size_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$size_id, (e) => call(size_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$quantity, (e) => call(quantity: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelScalarWhereInput<TRes>
    implements CopyWith$Input$ProductModelScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ProductModelScalarWhereInput>? AND,
    List<Input$ProductModelScalarWhereInput>? OR,
    List<Input$ProductModelScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? color_id,
    Input$IntFilter? size_id,
    Input$IntFilter? quantity,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get color_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get size_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get quantity =>
      CopyWith$Input$IntFilter.stub(_res);
}

class Input$ProductModelUpdateManyMutationInput {
  factory Input$ProductModelUpdateManyMutationInput(
          {Input$IntFieldUpdateOperationsInput? quantity}) =>
      Input$ProductModelUpdateManyMutationInput._({
        if (quantity != null) r'quantity': quantity,
      });

  Input$ProductModelUpdateManyMutationInput._(this._$data);

  factory Input$ProductModelUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    return Input$ProductModelUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyMutationInput<
          Input$ProductModelUpdateManyMutationInput>
      get copyWith => CopyWith$Input$ProductModelUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    return Object.hashAll(
        [_$data.containsKey('quantity') ? l$quantity : const {}]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$ProductModelUpdateManyMutationInput(
    Input$ProductModelUpdateManyMutationInput instance,
    TRes Function(Input$ProductModelUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyMutationInput;

  factory CopyWith$Input$ProductModelUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyMutationInput;

  TRes call({Input$IntFieldUpdateOperationsInput? quantity});
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
}

class _CopyWithImpl$Input$ProductModelUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyMutationInput _instance;

  final TRes Function(Input$ProductModelUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? quantity = _undefined}) =>
      _then(Input$ProductModelUpdateManyMutationInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyMutationInput(this._res);

  TRes _res;

  call({Input$IntFieldUpdateOperationsInput? quantity}) => _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
}

class Input$PayementsCreateInput {
  factory Input$PayementsCreateInput({
    required int payement_id,
    required double payement,
    required Input$TransactionsCreateNestedOneWithoutPayementsInput transaction,
  }) =>
      Input$PayementsCreateInput._({
        r'payement_id': payement_id,
        r'payement': payement,
        r'transaction': transaction,
      });

  Input$PayementsCreateInput._(this._$data);

  factory Input$PayementsCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$payement_id = data['payement_id'];
    result$data['payement_id'] = (l$payement_id as int);
    final l$payement = data['payement'];
    result$data['payement'] = (l$payement as num).toDouble();
    final l$transaction = data['transaction'];
    result$data['transaction'] =
        Input$TransactionsCreateNestedOneWithoutPayementsInput.fromJson(
            (l$transaction as Map<String, dynamic>));
    return Input$PayementsCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get payement_id => (_$data['payement_id'] as int);
  double get payement => (_$data['payement'] as double);
  Input$TransactionsCreateNestedOneWithoutPayementsInput get transaction =>
      (_$data['transaction']
          as Input$TransactionsCreateNestedOneWithoutPayementsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$payement_id = payement_id;
    result$data['payement_id'] = l$payement_id;
    final l$payement = payement;
    result$data['payement'] = l$payement;
    final l$transaction = transaction;
    result$data['transaction'] = l$transaction.toJson();
    return result$data;
  }

  CopyWith$Input$PayementsCreateInput<Input$PayementsCreateInput>
      get copyWith => CopyWith$Input$PayementsCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (l$payement != lOther$payement) {
      return false;
    }
    final l$transaction = transaction;
    final lOther$transaction = other.transaction;
    if (l$transaction != lOther$transaction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$payement = payement;
    final l$transaction = transaction;
    return Object.hashAll([
      l$payement_id,
      l$payement,
      l$transaction,
    ]);
  }
}

abstract class CopyWith$Input$PayementsCreateInput<TRes> {
  factory CopyWith$Input$PayementsCreateInput(
    Input$PayementsCreateInput instance,
    TRes Function(Input$PayementsCreateInput) then,
  ) = _CopyWithImpl$Input$PayementsCreateInput;

  factory CopyWith$Input$PayementsCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsCreateInput;

  TRes call({
    int? payement_id,
    double? payement,
    Input$TransactionsCreateNestedOneWithoutPayementsInput? transaction,
  });
  CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes>
      get transaction;
}

class _CopyWithImpl$Input$PayementsCreateInput<TRes>
    implements CopyWith$Input$PayementsCreateInput<TRes> {
  _CopyWithImpl$Input$PayementsCreateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsCreateInput _instance;

  final TRes Function(Input$PayementsCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? payement = _undefined,
    Object? transaction = _undefined,
  }) =>
      _then(Input$PayementsCreateInput._({
        ..._instance._$data,
        if (payement_id != _undefined && payement_id != null)
          'payement_id': (payement_id as int),
        if (payement != _undefined && payement != null)
          'payement': (payement as double),
        if (transaction != _undefined && transaction != null)
          'transaction': (transaction
              as Input$TransactionsCreateNestedOneWithoutPayementsInput),
      }));
  CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes>
      get transaction {
    final local$transaction = _instance.transaction;
    return CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput(
        local$transaction, (e) => call(transaction: e));
  }
}

class _CopyWithStubImpl$Input$PayementsCreateInput<TRes>
    implements CopyWith$Input$PayementsCreateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsCreateInput(this._res);

  TRes _res;

  call({
    int? payement_id,
    double? payement,
    Input$TransactionsCreateNestedOneWithoutPayementsInput? transaction,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes>
      get transaction =>
          CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput.stub(
              _res);
}

class Input$TransactionsCreateNestedOneWithoutPayementsInput {
  factory Input$TransactionsCreateNestedOneWithoutPayementsInput({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsWhereUniqueInput? connect,
  }) =>
      Input$TransactionsCreateNestedOneWithoutPayementsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionsCreateNestedOneWithoutPayementsInput._(this._$data);

  factory Input$TransactionsCreateNestedOneWithoutPayementsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionsCreateWithoutPayementsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionsCreateOrConnectWithoutPayementsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$TransactionsCreateNestedOneWithoutPayementsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsCreateWithoutPayementsInput? get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutPayementsInput?);
  Input$TransactionsCreateOrConnectWithoutPayementsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$TransactionsCreateOrConnectWithoutPayementsInput?);
  Input$TransactionsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionsWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<
          Input$TransactionsCreateNestedOneWithoutPayementsInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateNestedOneWithoutPayementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput(
    Input$TransactionsCreateNestedOneWithoutPayementsInput instance,
    TRes Function(Input$TransactionsCreateNestedOneWithoutPayementsInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput;

  factory CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput;

  TRes call({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsWhereUniqueInput? connect,
  });
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create;
  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateNestedOneWithoutPayementsInput _instance;

  final TRes Function(Input$TransactionsCreateNestedOneWithoutPayementsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionsCreateNestedOneWithoutPayementsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$TransactionsCreateWithoutPayementsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionsCreateOrConnectWithoutPayementsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionsWhereUniqueInput?),
      }));
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateWithoutPayementsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedOneWithoutPayementsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateNestedOneWithoutPayementsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(_res);
  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput.stub(
              _res);
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
}

class Input$TransactionsCreateWithoutPayementsInput {
  factory Input$TransactionsCreateWithoutPayementsInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$SellersCreateNestedOneWithoutTransactionsInput seller,
    required Input$CityCreateNestedOneWithoutTransactionsInput city,
    required Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
  }) =>
      Input$TransactionsCreateWithoutPayementsInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'seller': seller,
        r'city': city,
        r'transaction_type': transaction_type,
        if (status != null) r'status': status,
      });

  Input$TransactionsCreateWithoutPayementsInput._(this._$data);

  factory Input$TransactionsCreateWithoutPayementsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$seller = data['seller'];
    result$data['seller'] =
        Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$seller as Map<String, dynamic>));
    final l$city = data['city'];
    result$data['city'] =
        Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$city as Map<String, dynamic>));
    final l$transaction_type = data['transaction_type'];
    result$data['transaction_type'] =
        Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$transaction_type as Map<String, dynamic>));
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    return Input$TransactionsCreateWithoutPayementsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$SellersCreateNestedOneWithoutTransactionsInput get seller =>
      (_$data['seller']
          as Input$SellersCreateNestedOneWithoutTransactionsInput);
  Input$CityCreateNestedOneWithoutTransactionsInput get city =>
      (_$data['city'] as Input$CityCreateNestedOneWithoutTransactionsInput);
  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput);
  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? get status =>
      (_$data['status']
          as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$seller = seller;
    result$data['seller'] = l$seller.toJson();
    final l$city = city;
    result$data['city'] = l$city.toJson();
    final l$transaction_type = transaction_type;
    result$data['transaction_type'] = l$transaction_type.toJson();
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateWithoutPayementsInput<
          Input$TransactionsCreateWithoutPayementsInput>
      get copyWith => CopyWith$Input$TransactionsCreateWithoutPayementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateWithoutPayementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$seller,
      l$city,
      l$transaction_type,
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> {
  factory CopyWith$Input$TransactionsCreateWithoutPayementsInput(
    Input$TransactionsCreateWithoutPayementsInput instance,
    TRes Function(Input$TransactionsCreateWithoutPayementsInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateWithoutPayementsInput;

  factory CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateWithoutPayementsInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
  });
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller;
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city;
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type;
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status;
}

class _CopyWithImpl$Input$TransactionsCreateWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateWithoutPayementsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateWithoutPayementsInput _instance;

  final TRes Function(Input$TransactionsCreateWithoutPayementsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$TransactionsCreateWithoutPayementsInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (seller != _undefined && seller != null)
          'seller':
              (seller as Input$SellersCreateNestedOneWithoutTransactionsInput),
        if (city != _undefined && city != null)
          'city': (city as Input$CityCreateNestedOneWithoutTransactionsInput),
        if (transaction_type != _undefined && transaction_type != null)
          'transaction_type': (transaction_type
              as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?),
      }));
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
        local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city {
    final local$city = _instance.city;
    return CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
        local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
        local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateWithoutPayementsInput(this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
  }) =>
      _res;
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city =>
      CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(_res);
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .stub(_res);
}

class Input$CityCreateNestedOneWithoutTransactionsInput {
  factory Input$CityCreateNestedOneWithoutTransactionsInput({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityWhereUniqueInput? connect,
  }) =>
      Input$CityCreateNestedOneWithoutTransactionsInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$CityCreateNestedOneWithoutTransactionsInput._(this._$data);

  factory Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$CityCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$CityCreateOrConnectWithoutTransactionsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$CityWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$CityCreateNestedOneWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CityCreateWithoutTransactionsInput? get create =>
      (_$data['create'] as Input$CityCreateWithoutTransactionsInput?);
  Input$CityCreateOrConnectWithoutTransactionsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$CityCreateOrConnectWithoutTransactionsInput?);
  Input$CityWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$CityWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<
          Input$CityCreateNestedOneWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityCreateNestedOneWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
    Input$CityCreateNestedOneWithoutTransactionsInput instance,
    TRes Function(Input$CityCreateNestedOneWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$CityCreateNestedOneWithoutTransactionsInput;

  factory CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CityCreateNestedOneWithoutTransactionsInput;

  TRes call({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityWhereUniqueInput? connect,
  });
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create;
  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$CityWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$CityCreateNestedOneWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$CityCreateNestedOneWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$CityCreateNestedOneWithoutTransactionsInput _instance;

  final TRes Function(Input$CityCreateNestedOneWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$CityCreateNestedOneWithoutTransactionsInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$CityCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$CityCreateOrConnectWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$CityWhereUniqueInput?),
      }));
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$CityCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$CityWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$CityWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$CityWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$CityCreateNestedOneWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$CityCreateNestedOneWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$CityCreateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$CityWhereUniqueInput.stub(_res);
}

class Input$CityCreateWithoutTransactionsInput {
  factory Input$CityCreateWithoutTransactionsInput({
    required int city_id,
    required String city_name,
  }) =>
      Input$CityCreateWithoutTransactionsInput._({
        r'city_id': city_id,
        r'city_name': city_name,
      });

  Input$CityCreateWithoutTransactionsInput._(this._$data);

  factory Input$CityCreateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$city_id = data['city_id'];
    result$data['city_id'] = (l$city_id as int);
    final l$city_name = data['city_name'];
    result$data['city_name'] = (l$city_name as String);
    return Input$CityCreateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get city_id => (_$data['city_id'] as int);
  String get city_name => (_$data['city_name'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$city_id = city_id;
    result$data['city_id'] = l$city_id;
    final l$city_name = city_name;
    result$data['city_name'] = l$city_name;
    return result$data;
  }

  CopyWith$Input$CityCreateWithoutTransactionsInput<
          Input$CityCreateWithoutTransactionsInput>
      get copyWith => CopyWith$Input$CityCreateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityCreateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      l$city_id,
      l$city_name,
    ]);
  }
}

abstract class CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$CityCreateWithoutTransactionsInput(
    Input$CityCreateWithoutTransactionsInput instance,
    TRes Function(Input$CityCreateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$CityCreateWithoutTransactionsInput;

  factory CopyWith$Input$CityCreateWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityCreateWithoutTransactionsInput;

  TRes call({
    int? city_id,
    String? city_name,
  });
}

class _CopyWithImpl$Input$CityCreateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$CityCreateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$CityCreateWithoutTransactionsInput _instance;

  final TRes Function(Input$CityCreateWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityCreateWithoutTransactionsInput._({
        ..._instance._$data,
        if (city_id != _undefined && city_id != null)
          'city_id': (city_id as int),
        if (city_name != _undefined && city_name != null)
          'city_name': (city_name as String),
      }));
}

class _CopyWithStubImpl$Input$CityCreateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$CityCreateWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    int? city_id,
    String? city_name,
  }) =>
      _res;
}

class Input$CityCreateOrConnectWithoutTransactionsInput {
  factory Input$CityCreateOrConnectWithoutTransactionsInput({
    required Input$CityWhereUniqueInput where,
    required Input$CityCreateWithoutTransactionsInput create,
  }) =>
      Input$CityCreateOrConnectWithoutTransactionsInput._({
        r'where': where,
        r'create': create,
      });

  Input$CityCreateOrConnectWithoutTransactionsInput._(this._$data);

  factory Input$CityCreateOrConnectWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] =
        Input$CityWhereUniqueInput.fromJson((l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$CityCreateWithoutTransactionsInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$CityCreateOrConnectWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CityWhereUniqueInput get where =>
      (_$data['where'] as Input$CityWhereUniqueInput);
  Input$CityCreateWithoutTransactionsInput get create =>
      (_$data['create'] as Input$CityCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<
          Input$CityCreateOrConnectWithoutTransactionsInput>
      get copyWith =>
          CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityCreateOrConnectWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<
    TRes> {
  factory CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput(
    Input$CityCreateOrConnectWithoutTransactionsInput instance,
    TRes Function(Input$CityCreateOrConnectWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$CityCreateOrConnectWithoutTransactionsInput;

  factory CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CityCreateOrConnectWithoutTransactionsInput;

  TRes call({
    Input$CityWhereUniqueInput? where,
    Input$CityCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$CityWhereUniqueInput<TRes> get where;
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create;
}

class _CopyWithImpl$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$CityCreateOrConnectWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$CityCreateOrConnectWithoutTransactionsInput _instance;

  final TRes Function(Input$CityCreateOrConnectWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$CityCreateOrConnectWithoutTransactionsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$CityWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$CityCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$CityWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$CityWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$CityCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
    implements
        CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$CityCreateOrConnectWithoutTransactionsInput(
      this._res);

  TRes _res;

  call({
    Input$CityWhereUniqueInput? where,
    Input$CityCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$CityWhereUniqueInput<TRes> get where =>
      CopyWith$Input$CityWhereUniqueInput.stub(_res);
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$CityCreateWithoutTransactionsInput.stub(_res);
}

class Input$TransactionsCreateOrConnectWithoutPayementsInput {
  factory Input$TransactionsCreateOrConnectWithoutPayementsInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsCreateWithoutPayementsInput create,
  }) =>
      Input$TransactionsCreateOrConnectWithoutPayementsInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionsCreateOrConnectWithoutPayementsInput._(this._$data);

  factory Input$TransactionsCreateOrConnectWithoutPayementsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionsCreateWithoutPayementsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionsCreateOrConnectWithoutPayementsInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsCreateWithoutPayementsInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutPayementsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<
          Input$TransactionsCreateOrConnectWithoutPayementsInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateOrConnectWithoutPayementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput(
    Input$TransactionsCreateOrConnectWithoutPayementsInput instance,
    TRes Function(Input$TransactionsCreateOrConnectWithoutPayementsInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput;

  factory CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutPayementsInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateOrConnectWithoutPayementsInput _instance;

  final TRes Function(Input$TransactionsCreateOrConnectWithoutPayementsInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsCreateOrConnectWithoutPayementsInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutPayementsInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutPayementsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutPayementsInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutPayementsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(_res);
}

class Input$PayementsUpdateInput {
  factory Input$PayementsUpdateInput({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
    Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput? transaction,
  }) =>
      Input$PayementsUpdateInput._({
        if (payement_id != null) r'payement_id': payement_id,
        if (payement != null) r'payement': payement,
        if (transaction != null) r'transaction': transaction,
      });

  Input$PayementsUpdateInput._(this._$data);

  factory Input$PayementsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('payement_id')) {
      final l$payement_id = data['payement_id'];
      result$data['payement_id'] = l$payement_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$payement_id as Map<String, dynamic>));
    }
    if (data.containsKey('payement')) {
      final l$payement = data['payement'];
      result$data['payement'] = l$payement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$payement as Map<String, dynamic>));
    }
    if (data.containsKey('transaction')) {
      final l$transaction = data['transaction'];
      result$data['transaction'] = l$transaction == null
          ? null
          : Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput
              .fromJson((l$transaction as Map<String, dynamic>));
    }
    return Input$PayementsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get payement_id =>
      (_$data['payement_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get payement =>
      (_$data['payement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput?
      get transaction => (_$data['transaction']
          as Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('payement_id')) {
      final l$payement_id = payement_id;
      result$data['payement_id'] = l$payement_id?.toJson();
    }
    if (_$data.containsKey('payement')) {
      final l$payement = payement;
      result$data['payement'] = l$payement?.toJson();
    }
    if (_$data.containsKey('transaction')) {
      final l$transaction = transaction;
      result$data['transaction'] = l$transaction?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$PayementsUpdateInput<Input$PayementsUpdateInput>
      get copyWith => CopyWith$Input$PayementsUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$PayementsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$payement_id = payement_id;
    final lOther$payement_id = other.payement_id;
    if (_$data.containsKey('payement_id') !=
        other._$data.containsKey('payement_id')) {
      return false;
    }
    if (l$payement_id != lOther$payement_id) {
      return false;
    }
    final l$payement = payement;
    final lOther$payement = other.payement;
    if (_$data.containsKey('payement') !=
        other._$data.containsKey('payement')) {
      return false;
    }
    if (l$payement != lOther$payement) {
      return false;
    }
    final l$transaction = transaction;
    final lOther$transaction = other.transaction;
    if (_$data.containsKey('transaction') !=
        other._$data.containsKey('transaction')) {
      return false;
    }
    if (l$transaction != lOther$transaction) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$payement_id = payement_id;
    final l$payement = payement;
    final l$transaction = transaction;
    return Object.hashAll([
      _$data.containsKey('payement_id') ? l$payement_id : const {},
      _$data.containsKey('payement') ? l$payement : const {},
      _$data.containsKey('transaction') ? l$transaction : const {},
    ]);
  }
}

abstract class CopyWith$Input$PayementsUpdateInput<TRes> {
  factory CopyWith$Input$PayementsUpdateInput(
    Input$PayementsUpdateInput instance,
    TRes Function(Input$PayementsUpdateInput) then,
  ) = _CopyWithImpl$Input$PayementsUpdateInput;

  factory CopyWith$Input$PayementsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$PayementsUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
    Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput? transaction,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement;
  CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<TRes>
      get transaction;
}

class _CopyWithImpl$Input$PayementsUpdateInput<TRes>
    implements CopyWith$Input$PayementsUpdateInput<TRes> {
  _CopyWithImpl$Input$PayementsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$PayementsUpdateInput _instance;

  final TRes Function(Input$PayementsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? payement_id = _undefined,
    Object? payement = _undefined,
    Object? transaction = _undefined,
  }) =>
      _then(Input$PayementsUpdateInput._({
        ..._instance._$data,
        if (payement_id != _undefined)
          'payement_id': (payement_id as Input$IntFieldUpdateOperationsInput?),
        if (payement != _undefined)
          'payement': (payement as Input$FloatFieldUpdateOperationsInput?),
        if (transaction != _undefined)
          'transaction': (transaction
              as Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id {
    final local$payement_id = _instance.payement_id;
    return local$payement_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$payement_id, (e) => call(payement_id: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement {
    final local$payement = _instance.payement;
    return local$payement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$payement, (e) => call(payement: e));
  }

  CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<TRes>
      get transaction {
    final local$transaction = _instance.transaction;
    return local$transaction == null
        ? CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput(
            local$transaction, (e) => call(transaction: e));
  }
}

class _CopyWithStubImpl$Input$PayementsUpdateInput<TRes>
    implements CopyWith$Input$PayementsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$PayementsUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? payement_id,
    Input$FloatFieldUpdateOperationsInput? payement,
    Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput? transaction,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get payement_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get payement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<TRes>
      get transaction =>
          CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput
              .stub(_res);
}

class Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput {
  factory Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsUpsertWithoutPayementsInput? upsert,
    Input$TransactionsWhereUniqueInput? connect,
    Input$TransactionsUpdateWithoutPayementsInput? update,
  }) =>
      Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput._(this._$data);

  factory Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$TransactionsCreateWithoutPayementsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$TransactionsCreateOrConnectWithoutPayementsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$TransactionsUpsertWithoutPayementsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$TransactionsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$TransactionsUpdateWithoutPayementsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsCreateWithoutPayementsInput? get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutPayementsInput?);
  Input$TransactionsCreateOrConnectWithoutPayementsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$TransactionsCreateOrConnectWithoutPayementsInput?);
  Input$TransactionsUpsertWithoutPayementsInput? get upsert =>
      (_$data['upsert'] as Input$TransactionsUpsertWithoutPayementsInput?);
  Input$TransactionsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$TransactionsWhereUniqueInput?);
  Input$TransactionsUpdateWithoutPayementsInput? get update =>
      (_$data['update'] as Input$TransactionsUpdateWithoutPayementsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
          Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput(
    Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput instance,
    TRes Function(
            Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput;

  factory CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput;

  TRes call({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsUpsertWithoutPayementsInput? upsert,
    Input$TransactionsWhereUniqueInput? connect,
    Input$TransactionsUpdateWithoutPayementsInput? update,
  });
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create;
  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> get upsert;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect;
  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update;
}

class _CopyWithImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput
      _instance;

  final TRes Function(
      Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$TransactionsCreateWithoutPayementsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$TransactionsCreateOrConnectWithoutPayementsInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$TransactionsUpsertWithoutPayementsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$TransactionsWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$TransactionsUpdateWithoutPayementsInput?),
      }));
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateWithoutPayementsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$TransactionsUpsertWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsUpsertWithoutPayementsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$TransactionsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$TransactionsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$TransactionsUpdateWithoutPayementsInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsUpdateWithoutPayementsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateOneRequiredWithoutPayementsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsCreateWithoutPayementsInput? create,
    Input$TransactionsCreateOrConnectWithoutPayementsInput? connectOrCreate,
    Input$TransactionsUpsertWithoutPayementsInput? upsert,
    Input$TransactionsWhereUniqueInput? connect,
    Input$TransactionsUpdateWithoutPayementsInput? update,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(_res);
  CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutPayementsInput.stub(
              _res);
  CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> get upsert =>
      CopyWith$Input$TransactionsUpsertWithoutPayementsInput.stub(_res);
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update =>
      CopyWith$Input$TransactionsUpdateWithoutPayementsInput.stub(_res);
}

class Input$TransactionsUpsertWithoutPayementsInput {
  factory Input$TransactionsUpsertWithoutPayementsInput({
    required Input$TransactionsUpdateWithoutPayementsInput update,
    required Input$TransactionsCreateWithoutPayementsInput create,
  }) =>
      Input$TransactionsUpsertWithoutPayementsInput._({
        r'update': update,
        r'create': create,
      });

  Input$TransactionsUpsertWithoutPayementsInput._(this._$data);

  factory Input$TransactionsUpsertWithoutPayementsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$TransactionsUpdateWithoutPayementsInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionsCreateWithoutPayementsInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionsUpsertWithoutPayementsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsUpdateWithoutPayementsInput get update =>
      (_$data['update'] as Input$TransactionsUpdateWithoutPayementsInput);
  Input$TransactionsCreateWithoutPayementsInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutPayementsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpsertWithoutPayementsInput<
          Input$TransactionsUpsertWithoutPayementsInput>
      get copyWith => CopyWith$Input$TransactionsUpsertWithoutPayementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpsertWithoutPayementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> {
  factory CopyWith$Input$TransactionsUpsertWithoutPayementsInput(
    Input$TransactionsUpsertWithoutPayementsInput instance,
    TRes Function(Input$TransactionsUpsertWithoutPayementsInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpsertWithoutPayementsInput;

  factory CopyWith$Input$TransactionsUpsertWithoutPayementsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpsertWithoutPayementsInput;

  TRes call({
    Input$TransactionsUpdateWithoutPayementsInput? update,
    Input$TransactionsCreateWithoutPayementsInput? create,
  });
  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update;
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsUpsertWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpsertWithoutPayementsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpsertWithoutPayementsInput _instance;

  final TRes Function(Input$TransactionsUpsertWithoutPayementsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsUpsertWithoutPayementsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$TransactionsUpdateWithoutPayementsInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutPayementsInput),
      }));
  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionsUpdateWithoutPayementsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutPayementsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpsertWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsUpsertWithoutPayementsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpsertWithoutPayementsInput(this._res);

  TRes _res;

  call({
    Input$TransactionsUpdateWithoutPayementsInput? update,
    Input$TransactionsCreateWithoutPayementsInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> get update =>
      CopyWith$Input$TransactionsUpdateWithoutPayementsInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutPayementsInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutPayementsInput.stub(_res);
}

class Input$TransactionsUpdateWithoutPayementsInput {
  factory Input$TransactionsUpdateWithoutPayementsInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
  }) =>
      Input$TransactionsUpdateWithoutPayementsInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status != null) r'status': status,
      });

  Input$TransactionsUpdateWithoutPayementsInput._(this._$data);

  factory Input$TransactionsUpdateWithoutPayementsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateWithoutPayementsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? get seller =>
      (_$data['seller']
          as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? get city =>
      (_$data['city']
          as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
      get status => (_$data['status']
          as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithoutPayementsInput<
          Input$TransactionsUpdateWithoutPayementsInput>
      get copyWith => CopyWith$Input$TransactionsUpdateWithoutPayementsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithoutPayementsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status') ? l$status : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateWithoutPayementsInput(
    Input$TransactionsUpdateWithoutPayementsInput instance,
    TRes Function(Input$TransactionsUpdateWithoutPayementsInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithoutPayementsInput;

  factory CopyWith$Input$TransactionsUpdateWithoutPayementsInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithoutPayementsInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller;
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city;
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type;
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status;
}

class _CopyWithImpl$Input$TransactionsUpdateWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithoutPayementsInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithoutPayementsInput _instance;

  final TRes Function(Input$TransactionsUpdateWithoutPayementsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithoutPayementsInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (seller != _undefined)
          'seller': (seller
              as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (city != _undefined)
          'city': (city
              as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            local$status, (e) => call(status: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithoutPayementsInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutPayementsInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithoutPayementsInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get status =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
}

class Input$CityUpdateOneRequiredWithoutTransactionsNestedInput {
  factory Input$CityUpdateOneRequiredWithoutTransactionsNestedInput({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityUpsertWithoutTransactionsInput? upsert,
    Input$CityWhereUniqueInput? connect,
    Input$CityUpdateWithoutTransactionsInput? update,
  }) =>
      Input$CityUpdateOneRequiredWithoutTransactionsNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput._(this._$data);

  factory Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$CityCreateWithoutTransactionsInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$CityCreateOrConnectWithoutTransactionsInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$CityUpsertWithoutTransactionsInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$CityWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$CityUpdateWithoutTransactionsInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$CityUpdateOneRequiredWithoutTransactionsNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$CityCreateWithoutTransactionsInput? get create =>
      (_$data['create'] as Input$CityCreateWithoutTransactionsInput?);
  Input$CityCreateOrConnectWithoutTransactionsInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$CityCreateOrConnectWithoutTransactionsInput?);
  Input$CityUpsertWithoutTransactionsInput? get upsert =>
      (_$data['upsert'] as Input$CityUpsertWithoutTransactionsInput?);
  Input$CityWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$CityWhereUniqueInput?);
  Input$CityUpdateWithoutTransactionsInput? get update =>
      (_$data['update'] as Input$CityUpdateWithoutTransactionsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
          Input$CityUpdateOneRequiredWithoutTransactionsNestedInput>
      get copyWith =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityUpdateOneRequiredWithoutTransactionsNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
    TRes> {
  factory CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput instance,
    TRes Function(Input$CityUpdateOneRequiredWithoutTransactionsNestedInput)
        then,
  ) = _CopyWithImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput;

  factory CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput;

  TRes call({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityUpsertWithoutTransactionsInput? upsert,
    Input$CityWhereUniqueInput? connect,
    Input$CityUpdateWithoutTransactionsInput? update,
  });
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create;
  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate;
  CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> get upsert;
  CopyWith$Input$CityWhereUniqueInput<TRes> get connect;
  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update;
}

class _CopyWithImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
    this._instance,
    this._then,
  );

  final Input$CityUpdateOneRequiredWithoutTransactionsNestedInput _instance;

  final TRes Function(Input$CityUpdateOneRequiredWithoutTransactionsNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$CityUpdateOneRequiredWithoutTransactionsNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$CityCreateWithoutTransactionsInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$CityCreateOrConnectWithoutTransactionsInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$CityUpsertWithoutTransactionsInput?),
        if (connect != _undefined)
          'connect': (connect as Input$CityWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$CityUpdateWithoutTransactionsInput?),
      }));
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$CityCreateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityCreateWithoutTransactionsInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$CityUpsertWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityUpsertWithoutTransactionsInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$CityWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$CityWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$CityWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$CityUpdateWithoutTransactionsInput.stub(
            _then(_instance))
        : CopyWith$Input$CityUpdateWithoutTransactionsInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
        TRes>
    implements
        CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
      this._res);

  TRes _res;

  call({
    Input$CityCreateWithoutTransactionsInput? create,
    Input$CityCreateOrConnectWithoutTransactionsInput? connectOrCreate,
    Input$CityUpsertWithoutTransactionsInput? upsert,
    Input$CityWhereUniqueInput? connect,
    Input$CityUpdateWithoutTransactionsInput? update,
  }) =>
      _res;
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$CityCreateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$CityCreateOrConnectWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> get upsert =>
      CopyWith$Input$CityUpsertWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$CityWhereUniqueInput.stub(_res);
  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update =>
      CopyWith$Input$CityUpdateWithoutTransactionsInput.stub(_res);
}

class Input$CityUpsertWithoutTransactionsInput {
  factory Input$CityUpsertWithoutTransactionsInput({
    required Input$CityUpdateWithoutTransactionsInput update,
    required Input$CityCreateWithoutTransactionsInput create,
  }) =>
      Input$CityUpsertWithoutTransactionsInput._({
        r'update': update,
        r'create': create,
      });

  Input$CityUpsertWithoutTransactionsInput._(this._$data);

  factory Input$CityUpsertWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$CityUpdateWithoutTransactionsInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$CityCreateWithoutTransactionsInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$CityUpsertWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$CityUpdateWithoutTransactionsInput get update =>
      (_$data['update'] as Input$CityUpdateWithoutTransactionsInput);
  Input$CityCreateWithoutTransactionsInput get create =>
      (_$data['create'] as Input$CityCreateWithoutTransactionsInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$CityUpsertWithoutTransactionsInput<
          Input$CityUpsertWithoutTransactionsInput>
      get copyWith => CopyWith$Input$CityUpsertWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityUpsertWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$CityUpsertWithoutTransactionsInput(
    Input$CityUpsertWithoutTransactionsInput instance,
    TRes Function(Input$CityUpsertWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$CityUpsertWithoutTransactionsInput;

  factory CopyWith$Input$CityUpsertWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityUpsertWithoutTransactionsInput;

  TRes call({
    Input$CityUpdateWithoutTransactionsInput? update,
    Input$CityCreateWithoutTransactionsInput? create,
  });
  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update;
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create;
}

class _CopyWithImpl$Input$CityUpsertWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$CityUpsertWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$CityUpsertWithoutTransactionsInput _instance;

  final TRes Function(Input$CityUpsertWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$CityUpsertWithoutTransactionsInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$CityUpdateWithoutTransactionsInput),
        if (create != _undefined && create != null)
          'create': (create as Input$CityCreateWithoutTransactionsInput),
      }));
  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$CityUpdateWithoutTransactionsInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$CityCreateWithoutTransactionsInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$CityUpsertWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityUpsertWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$CityUpsertWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    Input$CityUpdateWithoutTransactionsInput? update,
    Input$CityCreateWithoutTransactionsInput? create,
  }) =>
      _res;
  CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> get update =>
      CopyWith$Input$CityUpdateWithoutTransactionsInput.stub(_res);
  CopyWith$Input$CityCreateWithoutTransactionsInput<TRes> get create =>
      CopyWith$Input$CityCreateWithoutTransactionsInput.stub(_res);
}

class Input$CityUpdateWithoutTransactionsInput {
  factory Input$CityUpdateWithoutTransactionsInput({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  }) =>
      Input$CityUpdateWithoutTransactionsInput._({
        if (city_id != null) r'city_id': city_id,
        if (city_name != null) r'city_name': city_name,
      });

  Input$CityUpdateWithoutTransactionsInput._(this._$data);

  factory Input$CityUpdateWithoutTransactionsInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('city_id')) {
      final l$city_id = data['city_id'];
      result$data['city_id'] = l$city_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$city_id as Map<String, dynamic>));
    }
    if (data.containsKey('city_name')) {
      final l$city_name = data['city_name'];
      result$data['city_name'] = l$city_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$city_name as Map<String, dynamic>));
    }
    return Input$CityUpdateWithoutTransactionsInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get city_id =>
      (_$data['city_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get city_name =>
      (_$data['city_name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('city_id')) {
      final l$city_id = city_id;
      result$data['city_id'] = l$city_id?.toJson();
    }
    if (_$data.containsKey('city_name')) {
      final l$city_name = city_name;
      result$data['city_name'] = l$city_name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$CityUpdateWithoutTransactionsInput<
          Input$CityUpdateWithoutTransactionsInput>
      get copyWith => CopyWith$Input$CityUpdateWithoutTransactionsInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$CityUpdateWithoutTransactionsInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$city_id = city_id;
    final lOther$city_id = other.city_id;
    if (_$data.containsKey('city_id') != other._$data.containsKey('city_id')) {
      return false;
    }
    if (l$city_id != lOther$city_id) {
      return false;
    }
    final l$city_name = city_name;
    final lOther$city_name = other.city_name;
    if (_$data.containsKey('city_name') !=
        other._$data.containsKey('city_name')) {
      return false;
    }
    if (l$city_name != lOther$city_name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$city_id = city_id;
    final l$city_name = city_name;
    return Object.hashAll([
      _$data.containsKey('city_id') ? l$city_id : const {},
      _$data.containsKey('city_name') ? l$city_name : const {},
    ]);
  }
}

abstract class CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> {
  factory CopyWith$Input$CityUpdateWithoutTransactionsInput(
    Input$CityUpdateWithoutTransactionsInput instance,
    TRes Function(Input$CityUpdateWithoutTransactionsInput) then,
  ) = _CopyWithImpl$Input$CityUpdateWithoutTransactionsInput;

  factory CopyWith$Input$CityUpdateWithoutTransactionsInput.stub(TRes res) =
      _CopyWithStubImpl$Input$CityUpdateWithoutTransactionsInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name;
}

class _CopyWithImpl$Input$CityUpdateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> {
  _CopyWithImpl$Input$CityUpdateWithoutTransactionsInput(
    this._instance,
    this._then,
  );

  final Input$CityUpdateWithoutTransactionsInput _instance;

  final TRes Function(Input$CityUpdateWithoutTransactionsInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? city_id = _undefined,
    Object? city_name = _undefined,
  }) =>
      _then(Input$CityUpdateWithoutTransactionsInput._({
        ..._instance._$data,
        if (city_id != _undefined)
          'city_id': (city_id as Input$IntFieldUpdateOperationsInput?),
        if (city_name != _undefined)
          'city_name': (city_name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id {
    final local$city_id = _instance.city_id;
    return local$city_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$city_id, (e) => call(city_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name {
    final local$city_name = _instance.city_name;
    return local$city_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$city_name, (e) => call(city_name: e));
  }
}

class _CopyWithStubImpl$Input$CityUpdateWithoutTransactionsInput<TRes>
    implements CopyWith$Input$CityUpdateWithoutTransactionsInput<TRes> {
  _CopyWithStubImpl$Input$CityUpdateWithoutTransactionsInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? city_id,
    Input$StringFieldUpdateOperationsInput? city_name,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get city_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get city_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ProductFamilyCreateInput {
  factory Input$ProductFamilyCreateInput({
    required String name,
    Input$ProductsCreateNestedManyWithoutFamilyInput? Products,
  }) =>
      Input$ProductFamilyCreateInput._({
        r'name': name,
        if (Products != null) r'Products': Products,
      });

  Input$ProductFamilyCreateInput._(this._$data);

  factory Input$ProductFamilyCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    if (data.containsKey('Products')) {
      final l$Products = data['Products'];
      result$data['Products'] = l$Products == null
          ? null
          : Input$ProductsCreateNestedManyWithoutFamilyInput.fromJson(
              (l$Products as Map<String, dynamic>));
    }
    return Input$ProductFamilyCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  Input$ProductsCreateNestedManyWithoutFamilyInput? get Products =>
      (_$data['Products'] as Input$ProductsCreateNestedManyWithoutFamilyInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    if (_$data.containsKey('Products')) {
      final l$Products = Products;
      result$data['Products'] = l$Products?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyCreateInput<Input$ProductFamilyCreateInput>
      get copyWith => CopyWith$Input$ProductFamilyCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$Products = Products;
    final lOther$Products = other.Products;
    if (_$data.containsKey('Products') !=
        other._$data.containsKey('Products')) {
      return false;
    }
    if (l$Products != lOther$Products) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$Products = Products;
    return Object.hashAll([
      l$name,
      _$data.containsKey('Products') ? l$Products : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyCreateInput<TRes> {
  factory CopyWith$Input$ProductFamilyCreateInput(
    Input$ProductFamilyCreateInput instance,
    TRes Function(Input$ProductFamilyCreateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyCreateInput;

  factory CopyWith$Input$ProductFamilyCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyCreateInput;

  TRes call({
    String? name,
    Input$ProductsCreateNestedManyWithoutFamilyInput? Products,
  });
  CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes> get Products;
}

class _CopyWithImpl$Input$ProductFamilyCreateInput<TRes>
    implements CopyWith$Input$ProductFamilyCreateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyCreateInput _instance;

  final TRes Function(Input$ProductFamilyCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? Products = _undefined,
  }) =>
      _then(Input$ProductFamilyCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (Products != _undefined)
          'Products':
              (Products as Input$ProductsCreateNestedManyWithoutFamilyInput?),
      }));
  CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes> get Products {
    final local$Products = _instance.Products;
    return local$Products == null
        ? CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput(
            local$Products, (e) => call(Products: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyCreateInput<TRes>
    implements CopyWith$Input$ProductFamilyCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    Input$ProductsCreateNestedManyWithoutFamilyInput? Products,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes>
      get Products =>
          CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput.stub(_res);
}

class Input$ProductsCreateNestedManyWithoutFamilyInput {
  factory Input$ProductsCreateNestedManyWithoutFamilyInput({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsWhereUniqueInput>? connect,
  }) =>
      Input$ProductsCreateNestedManyWithoutFamilyInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductsCreateNestedManyWithoutFamilyInput._(this._$data);

  factory Input$ProductsCreateNestedManyWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductsCreateWithoutFamilyInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) => Input$ProductsCreateOrConnectWithoutFamilyInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductsCreateNestedManyWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductsCreateWithoutFamilyInput>? get create =>
      (_$data['create'] as List<Input$ProductsCreateWithoutFamilyInput>?);
  List<Input$ProductsCreateOrConnectWithoutFamilyInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$ProductsCreateOrConnectWithoutFamilyInput>?);
  List<Input$ProductsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<
          Input$ProductsCreateNestedManyWithoutFamilyInput>
      get copyWith => CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateNestedManyWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes> {
  factory CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput(
    Input$ProductsCreateNestedManyWithoutFamilyInput instance,
    TRes Function(Input$ProductsCreateNestedManyWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateNestedManyWithoutFamilyInput;

  factory CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateNestedManyWithoutFamilyInput;

  TRes call({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$ProductsCreateWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsCreateWithoutFamilyInput<
                      Input$ProductsCreateWithoutFamilyInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductsCreateOrConnectWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<
                      Input$ProductsCreateOrConnectWithoutFamilyInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereUniqueInput<
                      Input$ProductsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateNestedManyWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateNestedManyWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsCreateNestedManyWithoutFamilyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductsCreateNestedManyWithoutFamilyInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$ProductsCreateWithoutFamilyInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductsCreateOrConnectWithoutFamilyInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$ProductsCreateWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsCreateWithoutFamilyInput<
                          Input$ProductsCreateWithoutFamilyInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductsCreateWithoutFamilyInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductsCreateOrConnectWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<
                          Input$ProductsCreateOrConnectWithoutFamilyInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereUniqueInput<
                          Input$ProductsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateNestedManyWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateNestedManyWithoutFamilyInput(this._res);

  TRes _res;

  call({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$ProductsCreateWithoutFamilyInput {
  factory Input$ProductsCreateWithoutFamilyInput({
    required int reference,
    required String name,
    required double buyingPrice,
    required double sellingPrice,
    required String description,
    required String picture,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      Input$ProductsCreateWithoutFamilyInput._({
        r'reference': reference,
        r'name': name,
        r'buyingPrice': buyingPrice,
        r'sellingPrice': sellingPrice,
        r'description': description,
        r'picture': picture,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsCreateWithoutFamilyInput._(this._$data);

  factory Input$ProductsCreateWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reference = data['reference'];
    result$data['reference'] = (l$reference as int);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$buyingPrice = data['buyingPrice'];
    result$data['buyingPrice'] = (l$buyingPrice as num).toDouble();
    final l$sellingPrice = data['sellingPrice'];
    result$data['sellingPrice'] = (l$sellingPrice as num).toDouble();
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelCreateNestedManyWithoutProductInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductCreateNestedManyWithoutProductInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsCreateWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get reference => (_$data['reference'] as int);
  String get name => (_$data['name'] as String);
  double get buyingPrice => (_$data['buyingPrice'] as double);
  double get sellingPrice => (_$data['sellingPrice'] as double);
  String get description => (_$data['description'] as String);
  String get picture => (_$data['picture'] as String);
  Input$ProductModelCreateNestedManyWithoutProductInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelCreateNestedManyWithoutProductInput?);
  Input$TransactionProductCreateNestedManyWithoutProductInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductCreateNestedManyWithoutProductInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reference = reference;
    result$data['reference'] = l$reference;
    final l$name = name;
    result$data['name'] = l$name;
    final l$buyingPrice = buyingPrice;
    result$data['buyingPrice'] = l$buyingPrice;
    final l$sellingPrice = sellingPrice;
    result$data['sellingPrice'] = l$sellingPrice;
    final l$description = description;
    result$data['description'] = l$description;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateWithoutFamilyInput<
          Input$ProductsCreateWithoutFamilyInput>
      get copyWith => CopyWith$Input$ProductsCreateWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      l$reference,
      l$name,
      l$buyingPrice,
      l$sellingPrice,
      l$description,
      l$picture,
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> {
  factory CopyWith$Input$ProductsCreateWithoutFamilyInput(
    Input$ProductsCreateWithoutFamilyInput instance,
    TRes Function(Input$ProductsCreateWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateWithoutFamilyInput;

  factory CopyWith$Input$ProductsCreateWithoutFamilyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateWithoutFamilyInput;

  TRes call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  });
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel;
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsCreateWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsCreateWithoutFamilyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsCreateWithoutFamilyInput._({
        ..._instance._$data,
        if (reference != _undefined && reference != null)
          'reference': (reference as int),
        if (name != _undefined && name != null) 'name': (name as String),
        if (buyingPrice != _undefined && buyingPrice != null)
          'buyingPrice': (buyingPrice as double),
        if (sellingPrice != _undefined && sellingPrice != null)
          'sellingPrice': (sellingPrice as double),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelCreateNestedManyWithoutProductInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductCreateNestedManyWithoutProductInput?),
      }));
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateWithoutFamilyInput(this._res);

  TRes _res;

  call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
              _res);
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
              .stub(_res);
}

class Input$ProductModelCreateNestedManyWithoutProductInput {
  factory Input$ProductModelCreateNestedManyWithoutProductInput({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      Input$ProductModelCreateNestedManyWithoutProductInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductModelCreateNestedManyWithoutProductInput._(this._$data);

  factory Input$ProductModelCreateNestedManyWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutProductInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutProductInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelCreateNestedManyWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutProductInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutProductInput>?);
  List<Input$ProductModelCreateOrConnectWithoutProductInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutProductInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<
          Input$ProductModelCreateNestedManyWithoutProductInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateNestedManyWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput(
    Input$ProductModelCreateNestedManyWithoutProductInput instance,
    TRes Function(Input$ProductModelCreateNestedManyWithoutProductInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutProductInput;

  factory CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutProductInput;

  TRes call({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutProductInput<
                      Input$ProductModelCreateWithoutProductInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
                      Input$ProductModelCreateOrConnectWithoutProductInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateNestedManyWithoutProductInput _instance;

  final TRes Function(Input$ProductModelCreateNestedManyWithoutProductInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductModelCreateNestedManyWithoutProductInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$ProductModelCreateWithoutProductInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutProductInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutProductInput<
                          Input$ProductModelCreateWithoutProductInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutProductInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
                          Input$ProductModelCreateOrConnectWithoutProductInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutProductInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$ProductModelCreateWithoutProductInput {
  factory Input$ProductModelCreateWithoutProductInput({
    required int quantity,
    required Input$SizesCreateNestedOneWithoutProductModelInput size,
    required Input$ColorsCreateNestedOneWithoutProductModelInput color,
  }) =>
      Input$ProductModelCreateWithoutProductInput._({
        r'quantity': quantity,
        r'size': size,
        r'color': color,
      });

  Input$ProductModelCreateWithoutProductInput._(this._$data);

  factory Input$ProductModelCreateWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$size = data['size'];
    result$data['size'] =
        Input$SizesCreateNestedOneWithoutProductModelInput.fromJson(
            (l$size as Map<String, dynamic>));
    final l$color = data['color'];
    result$data['color'] =
        Input$ColorsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$color as Map<String, dynamic>));
    return Input$ProductModelCreateWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  Input$SizesCreateNestedOneWithoutProductModelInput get size =>
      (_$data['size'] as Input$SizesCreateNestedOneWithoutProductModelInput);
  Input$ColorsCreateNestedOneWithoutProductModelInput get color =>
      (_$data['color'] as Input$ColorsCreateNestedOneWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$size = size;
    result$data['size'] = l$size.toJson();
    final l$color = color;
    result$data['color'] = l$color.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateWithoutProductInput<
          Input$ProductModelCreateWithoutProductInput>
      get copyWith => CopyWith$Input$ProductModelCreateWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      l$quantity,
      l$size,
      l$color,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> {
  factory CopyWith$Input$ProductModelCreateWithoutProductInput(
    Input$ProductModelCreateWithoutProductInput instance,
    TRes Function(Input$ProductModelCreateWithoutProductInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateWithoutProductInput;

  factory CopyWith$Input$ProductModelCreateWithoutProductInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateWithoutProductInput;

  TRes call({
    int? quantity,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  });
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size;
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color;
}

class _CopyWithImpl$Input$ProductModelCreateWithoutProductInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateWithoutProductInput _instance;

  final TRes Function(Input$ProductModelCreateWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelCreateWithoutProductInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (size != _undefined && size != null)
          'size': (size as Input$SizesCreateNestedOneWithoutProductModelInput),
        if (color != _undefined && color != null)
          'color':
              (color as Input$ColorsCreateNestedOneWithoutProductModelInput),
      }));
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size {
    final local$size = _instance.size;
    return CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput(
        local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color {
    final local$color = _instance.color;
    return CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput(
        local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateWithoutProductInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateWithoutProductInput(this._res);

  TRes _res;

  call({
    int? quantity,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  }) =>
      _res;
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size =>
      CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes>
      get color =>
          CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput.stub(
              _res);
}

class Input$ColorsCreateNestedOneWithoutProductModelInput {
  factory Input$ColorsCreateNestedOneWithoutProductModelInput({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsWhereUniqueInput? connect,
  }) =>
      Input$ColorsCreateNestedOneWithoutProductModelInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ColorsCreateNestedOneWithoutProductModelInput._(this._$data);

  factory Input$ColorsCreateNestedOneWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ColorsCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ColorsCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ColorsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$ColorsCreateNestedOneWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ColorsCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$ColorsCreateWithoutProductModelInput?);
  Input$ColorsCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ColorsCreateOrConnectWithoutProductModelInput?);
  Input$ColorsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ColorsWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<
          Input$ColorsCreateNestedOneWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsCreateNestedOneWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput(
    Input$ColorsCreateNestedOneWithoutProductModelInput instance,
    TRes Function(Input$ColorsCreateNestedOneWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ColorsCreateNestedOneWithoutProductModelInput;

  factory CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ColorsCreateNestedOneWithoutProductModelInput;

  TRes call({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsWhereUniqueInput? connect,
  });
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ColorsCreateNestedOneWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ColorsCreateNestedOneWithoutProductModelInput _instance;

  final TRes Function(Input$ColorsCreateNestedOneWithoutProductModelInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ColorsCreateNestedOneWithoutProductModelInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ColorsCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ColorsCreateOrConnectWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ColorsWhereUniqueInput?),
      }));
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ColorsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ColorsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$ColorsCreateNestedOneWithoutProductModelInput<
        TRes>
    implements
        CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ColorsCreateNestedOneWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ColorsWhereUniqueInput.stub(_res);
}

class Input$ColorsCreateWithoutProductModelInput {
  factory Input$ColorsCreateWithoutProductModelInput({
    required int id,
    required String color,
  }) =>
      Input$ColorsCreateWithoutProductModelInput._({
        r'id': id,
        r'color': color,
      });

  Input$ColorsCreateWithoutProductModelInput._(this._$data);

  factory Input$ColorsCreateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as int);
    final l$color = data['color'];
    result$data['color'] = (l$color as String);
    return Input$ColorsCreateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get id => (_$data['id'] as int);
  String get color => (_$data['color'] as String);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$color = color;
    result$data['color'] = l$color;
    return result$data;
  }

  CopyWith$Input$ColorsCreateWithoutProductModelInput<
          Input$ColorsCreateWithoutProductModelInput>
      get copyWith => CopyWith$Input$ColorsCreateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsCreateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      l$id,
      l$color,
    ]);
  }
}

abstract class CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ColorsCreateWithoutProductModelInput(
    Input$ColorsCreateWithoutProductModelInput instance,
    TRes Function(Input$ColorsCreateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ColorsCreateWithoutProductModelInput;

  factory CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsCreateWithoutProductModelInput;

  TRes call({
    int? id,
    String? color,
  });
}

class _CopyWithImpl$Input$ColorsCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ColorsCreateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ColorsCreateWithoutProductModelInput _instance;

  final TRes Function(Input$ColorsCreateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsCreateWithoutProductModelInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as int),
        if (color != _undefined && color != null) 'color': (color as String),
      }));
}

class _CopyWithStubImpl$Input$ColorsCreateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ColorsCreateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    int? id,
    String? color,
  }) =>
      _res;
}

class Input$ColorsCreateOrConnectWithoutProductModelInput {
  factory Input$ColorsCreateOrConnectWithoutProductModelInput({
    required Input$ColorsWhereUniqueInput where,
    required Input$ColorsCreateWithoutProductModelInput create,
  }) =>
      Input$ColorsCreateOrConnectWithoutProductModelInput._({
        r'where': where,
        r'create': create,
      });

  Input$ColorsCreateOrConnectWithoutProductModelInput._(this._$data);

  factory Input$ColorsCreateOrConnectWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ColorsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ColorsCreateWithoutProductModelInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ColorsCreateOrConnectWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ColorsWhereUniqueInput get where =>
      (_$data['where'] as Input$ColorsWhereUniqueInput);
  Input$ColorsCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$ColorsCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<
          Input$ColorsCreateOrConnectWithoutProductModelInput>
      get copyWith =>
          CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsCreateOrConnectWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<
    TRes> {
  factory CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput(
    Input$ColorsCreateOrConnectWithoutProductModelInput instance,
    TRes Function(Input$ColorsCreateOrConnectWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ColorsCreateOrConnectWithoutProductModelInput;

  factory CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ColorsCreateOrConnectWithoutProductModelInput;

  TRes call({
    Input$ColorsWhereUniqueInput? where,
    Input$ColorsCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
    implements
        CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ColorsCreateOrConnectWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ColorsCreateOrConnectWithoutProductModelInput _instance;

  final TRes Function(Input$ColorsCreateOrConnectWithoutProductModelInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ColorsCreateOrConnectWithoutProductModelInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ColorsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ColorsCreateWithoutProductModelInput),
      }));
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ColorsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ColorsCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ColorsCreateOrConnectWithoutProductModelInput<
        TRes>
    implements
        CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ColorsCreateOrConnectWithoutProductModelInput(
      this._res);

  TRes _res;

  call({
    Input$ColorsWhereUniqueInput? where,
    Input$ColorsCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ColorsWhereUniqueInput.stub(_res);
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(_res);
}

class Input$ProductModelCreateOrConnectWithoutProductInput {
  factory Input$ProductModelCreateOrConnectWithoutProductInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelCreateWithoutProductInput create,
  }) =>
      Input$ProductModelCreateOrConnectWithoutProductInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductModelCreateOrConnectWithoutProductInput._(this._$data);

  factory Input$ProductModelCreateOrConnectWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductModelCreateWithoutProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductModelCreateOrConnectWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelCreateWithoutProductInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
          Input$ProductModelCreateOrConnectWithoutProductInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateOrConnectWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput(
    Input$ProductModelCreateOrConnectWithoutProductInput instance,
    TRes Function(Input$ProductModelCreateOrConnectWithoutProductInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutProductInput;

  factory CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutProductInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutProductInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutProductInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateOrConnectWithoutProductInput _instance;

  final TRes Function(Input$ProductModelCreateOrConnectWithoutProductInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelCreateOrConnectWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutProductInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutProductInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutProductInput.stub(_res);
}

class Input$ProductsCreateOrConnectWithoutFamilyInput {
  factory Input$ProductsCreateOrConnectWithoutFamilyInput({
    required Input$ProductsWhereUniqueInput where,
    required Input$ProductsCreateWithoutFamilyInput create,
  }) =>
      Input$ProductsCreateOrConnectWithoutFamilyInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductsCreateOrConnectWithoutFamilyInput._(this._$data);

  factory Input$ProductsCreateOrConnectWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductsCreateWithoutFamilyInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductsCreateOrConnectWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductsWhereUniqueInput);
  Input$ProductsCreateWithoutFamilyInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutFamilyInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<
          Input$ProductsCreateOrConnectWithoutFamilyInput>
      get copyWith => CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateOrConnectWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<TRes> {
  factory CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput(
    Input$ProductsCreateOrConnectWithoutFamilyInput instance,
    TRes Function(Input$ProductsCreateOrConnectWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateOrConnectWithoutFamilyInput;

  factory CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutFamilyInput;

  TRes call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutFamilyInput? create,
  });
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsCreateOrConnectWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateOrConnectWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateOrConnectWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsCreateOrConnectWithoutFamilyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsCreateOrConnectWithoutFamilyInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductsCreateWithoutFamilyInput),
      }));
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutFamilyInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutFamilyInput(this._res);

  TRes _res;

  call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutFamilyInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutFamilyInput.stub(_res);
}

class Input$ProductFamilyUpdateManyMutationInput {
  factory Input$ProductFamilyUpdateManyMutationInput(
          {Input$StringFieldUpdateOperationsInput? name}) =>
      Input$ProductFamilyUpdateManyMutationInput._({
        if (name != null) r'name': name,
      });

  Input$ProductFamilyUpdateManyMutationInput._(this._$data);

  factory Input$ProductFamilyUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    return Input$ProductFamilyUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyUpdateManyMutationInput<
          Input$ProductFamilyUpdateManyMutationInput>
      get copyWith => CopyWith$Input$ProductFamilyUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    return Object.hashAll([_$data.containsKey('name') ? l$name : const {}]);
  }
}

abstract class CopyWith$Input$ProductFamilyUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$ProductFamilyUpdateManyMutationInput(
    Input$ProductFamilyUpdateManyMutationInput instance,
    TRes Function(Input$ProductFamilyUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyUpdateManyMutationInput;

  factory CopyWith$Input$ProductFamilyUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyUpdateManyMutationInput;

  TRes call({Input$StringFieldUpdateOperationsInput? name});
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
}

class _CopyWithImpl$Input$ProductFamilyUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyUpdateManyMutationInput _instance;

  final TRes Function(Input$ProductFamilyUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({Object? name = _undefined}) =>
      _then(Input$ProductFamilyUpdateManyMutationInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyUpdateManyMutationInput(this._res);

  TRes _res;

  call({Input$StringFieldUpdateOperationsInput? name}) => _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ProductFamilyUpdateInput {
  factory Input$ProductFamilyUpdateInput({
    Input$StringFieldUpdateOperationsInput? name,
    Input$ProductsUpdateManyWithoutFamilyNestedInput? Products,
  }) =>
      Input$ProductFamilyUpdateInput._({
        if (name != null) r'name': name,
        if (Products != null) r'Products': Products,
      });

  Input$ProductFamilyUpdateInput._(this._$data);

  factory Input$ProductFamilyUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('Products')) {
      final l$Products = data['Products'];
      result$data['Products'] = l$Products == null
          ? null
          : Input$ProductsUpdateManyWithoutFamilyNestedInput.fromJson(
              (l$Products as Map<String, dynamic>));
    }
    return Input$ProductFamilyUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductsUpdateManyWithoutFamilyNestedInput? get Products =>
      (_$data['Products'] as Input$ProductsUpdateManyWithoutFamilyNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('Products')) {
      final l$Products = Products;
      result$data['Products'] = l$Products?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductFamilyUpdateInput<Input$ProductFamilyUpdateInput>
      get copyWith => CopyWith$Input$ProductFamilyUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductFamilyUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$Products = Products;
    final lOther$Products = other.Products;
    if (_$data.containsKey('Products') !=
        other._$data.containsKey('Products')) {
      return false;
    }
    if (l$Products != lOther$Products) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$Products = Products;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('Products') ? l$Products : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductFamilyUpdateInput<TRes> {
  factory CopyWith$Input$ProductFamilyUpdateInput(
    Input$ProductFamilyUpdateInput instance,
    TRes Function(Input$ProductFamilyUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductFamilyUpdateInput;

  factory CopyWith$Input$ProductFamilyUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductFamilyUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$ProductsUpdateManyWithoutFamilyNestedInput? Products,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes> get Products;
}

class _CopyWithImpl$Input$ProductFamilyUpdateInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductFamilyUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductFamilyUpdateInput _instance;

  final TRes Function(Input$ProductFamilyUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? Products = _undefined,
  }) =>
      _then(Input$ProductFamilyUpdateInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (Products != _undefined)
          'Products':
              (Products as Input$ProductsUpdateManyWithoutFamilyNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes> get Products {
    final local$Products = _instance.Products;
    return local$Products == null
        ? CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput(
            local$Products, (e) => call(Products: e));
  }
}

class _CopyWithStubImpl$Input$ProductFamilyUpdateInput<TRes>
    implements CopyWith$Input$ProductFamilyUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductFamilyUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$ProductsUpdateManyWithoutFamilyNestedInput? Products,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes>
      get Products =>
          CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput.stub(_res);
}

class Input$ProductsUpdateManyWithoutFamilyNestedInput {
  factory Input$ProductsUpdateManyWithoutFamilyNestedInput({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? upsert,
    List<Input$ProductsWhereUniqueInput>? $set,
    List<Input$ProductsWhereUniqueInput>? disconnect,
    List<Input$ProductsWhereUniqueInput>? delete,
    List<Input$ProductsWhereUniqueInput>? connect,
    List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? update,
    List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? updateMany,
    List<Input$ProductsScalarWhereInput>? deleteMany,
  }) =>
      Input$ProductsUpdateManyWithoutFamilyNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$ProductsUpdateManyWithoutFamilyNestedInput._(this._$data);

  factory Input$ProductsUpdateManyWithoutFamilyNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductsCreateWithoutFamilyInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) => Input$ProductsCreateOrConnectWithoutFamilyInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$ProductsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$ProductsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$ProductsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$ProductsUpdateManyWithWhereWithoutFamilyInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductsUpdateManyWithoutFamilyNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductsCreateWithoutFamilyInput>? get create =>
      (_$data['create'] as List<Input$ProductsCreateWithoutFamilyInput>?);
  List<Input$ProductsCreateOrConnectWithoutFamilyInput>? get connectOrCreate =>
      (_$data['connectOrCreate']
          as List<Input$ProductsCreateOrConnectWithoutFamilyInput>?);
  List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? get upsert =>
      (_$data['upsert']
          as List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>?);
  List<Input$ProductsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$ProductsWhereUniqueInput>?);
  List<Input$ProductsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$ProductsWhereUniqueInput>?);
  List<Input$ProductsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$ProductsWhereUniqueInput>?);
  List<Input$ProductsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductsWhereUniqueInput>?);
  List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? get update =>
      (_$data['update']
          as List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>?);
  List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>?);
  List<Input$ProductsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$ProductsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<
          Input$ProductsUpdateManyWithoutFamilyNestedInput>
      get copyWith => CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateManyWithoutFamilyNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes> {
  factory CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput(
    Input$ProductsUpdateManyWithoutFamilyNestedInput instance,
    TRes Function(Input$ProductsUpdateManyWithoutFamilyNestedInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput;

  factory CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput;

  TRes call({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? upsert,
    List<Input$ProductsWhereUniqueInput>? $set,
    List<Input$ProductsWhereUniqueInput>? disconnect,
    List<Input$ProductsWhereUniqueInput>? delete,
    List<Input$ProductsWhereUniqueInput>? connect,
    List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? update,
    List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? updateMany,
    List<Input$ProductsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$ProductsCreateWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsCreateWithoutFamilyInput<
                      Input$ProductsCreateWithoutFamilyInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductsCreateOrConnectWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<
                      Input$ProductsCreateOrConnectWithoutFamilyInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<
                      Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$ProductsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereUniqueInput<
                      Input$ProductsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$ProductsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereUniqueInput<
                      Input$ProductsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$ProductsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereUniqueInput<
                      Input$ProductsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsWhereUniqueInput<
                      Input$ProductsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<
                      Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<
                      Input$ProductsUpdateManyWithWhereWithoutFamilyInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$ProductsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereInput<
                      Input$ProductsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes>
    implements CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateManyWithoutFamilyNestedInput _instance;

  final TRes Function(Input$ProductsUpdateManyWithoutFamilyNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$ProductsUpdateManyWithoutFamilyNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$ProductsCreateWithoutFamilyInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductsCreateOrConnectWithoutFamilyInput>?),
        if (upsert != _undefined)
          'upsert': (upsert
              as List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$ProductsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect': (disconnect as List<Input$ProductsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$ProductsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update
              as List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>?),
        if (deleteMany != _undefined)
          'deleteMany': (deleteMany as List<Input$ProductsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$ProductsCreateWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsCreateWithoutFamilyInput<
                          Input$ProductsCreateWithoutFamilyInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductsCreateWithoutFamilyInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductsCreateOrConnectWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput<
                          Input$ProductsCreateOrConnectWithoutFamilyInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$ProductsCreateOrConnectWithoutFamilyInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<
                          Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$ProductsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereUniqueInput<
                          Input$ProductsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$ProductsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$ProductsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereUniqueInput<
                          Input$ProductsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$ProductsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$ProductsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereUniqueInput<
                          Input$ProductsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$ProductsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsWhereUniqueInput<
                          Input$ProductsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<
                          Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<
                          Input$ProductsUpdateManyWithWhereWithoutFamilyInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$ProductsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereInput<
                          Input$ProductsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$ProductsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes>
    implements CopyWith$Input$ProductsUpdateManyWithoutFamilyNestedInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateManyWithoutFamilyNestedInput(this._res);

  TRes _res;

  call({
    List<Input$ProductsCreateWithoutFamilyInput>? create,
    List<Input$ProductsCreateOrConnectWithoutFamilyInput>? connectOrCreate,
    List<Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>? upsert,
    List<Input$ProductsWhereUniqueInput>? $set,
    List<Input$ProductsWhereUniqueInput>? disconnect,
    List<Input$ProductsWhereUniqueInput>? delete,
    List<Input$ProductsWhereUniqueInput>? connect,
    List<Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>? update,
    List<Input$ProductsUpdateManyWithWhereWithoutFamilyInput>? updateMany,
    List<Input$ProductsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput {
  factory Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput({
    required Input$ProductsWhereUniqueInput where,
    required Input$ProductsUpdateWithoutFamilyInput update,
    required Input$ProductsCreateWithoutFamilyInput create,
  }) =>
      Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput._(this._$data);

  factory Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$ProductsUpdateWithoutFamilyInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductsCreateWithoutFamilyInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductsWhereUniqueInput);
  Input$ProductsUpdateWithoutFamilyInput get update =>
      (_$data['update'] as Input$ProductsUpdateWithoutFamilyInput);
  Input$ProductsCreateWithoutFamilyInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutFamilyInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<
          Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput>
      get copyWith =>
          CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<
    TRes> {
  factory CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput(
    Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput instance,
    TRes Function(Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput;

  factory CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput;

  TRes call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsUpdateWithoutFamilyInput? update,
    Input$ProductsCreateWithoutFamilyInput? create,
  });
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get update;
  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<TRes>
    implements
        CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$ProductsUpdateWithoutFamilyInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductsCreateWithoutFamilyInput),
      }));
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductsUpdateWithoutFamilyInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutFamilyInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpsertWithWhereUniqueWithoutFamilyInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsUpdateWithoutFamilyInput? update,
    Input$ProductsCreateWithoutFamilyInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get update =>
      CopyWith$Input$ProductsUpdateWithoutFamilyInput.stub(_res);
  CopyWith$Input$ProductsCreateWithoutFamilyInput<TRes> get create =>
      CopyWith$Input$ProductsCreateWithoutFamilyInput.stub(_res);
}

class Input$ProductsUpdateWithoutFamilyInput {
  factory Input$ProductsUpdateWithoutFamilyInput({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      Input$ProductsUpdateWithoutFamilyInput._({
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsUpdateWithoutFamilyInput._(this._$data);

  factory Input$ProductsUpdateWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelUpdateManyWithoutProductNestedInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductUpdateManyWithoutProductNestedInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsUpdateWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get reference =>
      (_$data['reference'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductModelUpdateManyWithoutProductNestedInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelUpdateManyWithoutProductNestedInput?);
  Input$TransactionProductUpdateManyWithoutProductNestedInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductUpdateManyWithoutProductNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateWithoutFamilyInput<
          Input$ProductsUpdateWithoutFamilyInput>
      get copyWith => CopyWith$Input$ProductsUpdateWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> {
  factory CopyWith$Input$ProductsUpdateWithoutFamilyInput(
    Input$ProductsUpdateWithoutFamilyInput instance,
    TRes Function(Input$ProductsUpdateWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateWithoutFamilyInput;

  factory CopyWith$Input$ProductsUpdateWithoutFamilyInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateWithoutFamilyInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel;
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsUpdateWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsUpdateWithoutFamilyInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsUpdateWithoutFamilyInput._({
        ..._instance._$data,
        if (reference != _undefined)
          'reference': (reference as Input$IntFieldUpdateOperationsInput?),
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (buyingPrice != _undefined)
          'buyingPrice':
              (buyingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (sellingPrice != _undefined)
          'sellingPrice':
              (sellingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelUpdateManyWithoutProductNestedInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductUpdateManyWithoutProductNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateWithoutFamilyInput<TRes>
    implements CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateWithoutFamilyInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
              _res);
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
              .stub(_res);
}

class Input$ProductModelUpdateManyWithoutProductNestedInput {
  factory Input$ProductModelUpdateManyWithoutProductNestedInput({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutProductInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      Input$ProductModelUpdateManyWithoutProductNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$ProductModelUpdateManyWithoutProductNestedInput._(this._$data);

  factory Input$ProductModelUpdateManyWithoutProductNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutProductInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutProductInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpsertWithWhereUniqueWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateWithWhereUniqueWithoutProductInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateManyWithWhereWithoutProductInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelUpdateManyWithoutProductNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutProductInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutProductInput>?);
  List<Input$ProductModelCreateOrConnectWithoutProductInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutProductInput>?);
  List<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>?
      get upsert => (_$data['upsert']
          as List<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>?);
  List<Input$ProductModelWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>?
      get update => (_$data['update']
          as List<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>?);
  List<Input$ProductModelUpdateManyWithWhereWithoutProductInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$ProductModelUpdateManyWithWhereWithoutProductInput>?);
  List<Input$ProductModelScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$ProductModelScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<
          Input$ProductModelUpdateManyWithoutProductNestedInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithoutProductNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput(
    Input$ProductModelUpdateManyWithoutProductNestedInput instance,
    TRes Function(Input$ProductModelUpdateManyWithoutProductNestedInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithoutProductNestedInput;

  factory CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutProductNestedInput;

  TRes call({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutProductInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutProductInput<
                      Input$ProductModelCreateWithoutProductInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
                      Input$ProductModelCreateOrConnectWithoutProductInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
                      Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
                      Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$ProductModelUpdateManyWithWhereWithoutProductInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
                      Input$ProductModelUpdateManyWithWhereWithoutProductInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithoutProductNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithoutProductNestedInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithoutProductNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithoutProductNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$ProductModelCreateWithoutProductInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutProductInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$ProductModelWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$ProductModelWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$ProductModelWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$ProductModelUpdateManyWithWhereWithoutProductInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$ProductModelScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutProductInput<
                          Input$ProductModelCreateWithoutProductInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutProductInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput<
                          Input$ProductModelCreateOrConnectWithoutProductInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$ProductModelCreateOrConnectWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
                          Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
                          Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$ProductModelUpdateManyWithWhereWithoutProductInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
                          Input$ProductModelUpdateManyWithWhereWithoutProductInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutProductNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutProductNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutProductInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutProductInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutProductInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$ProductModelUpsertWithWhereUniqueWithoutProductInput {
  factory Input$ProductModelUpsertWithWhereUniqueWithoutProductInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutProductInput update,
    required Input$ProductModelCreateWithoutProductInput create,
  }) =>
      Input$ProductModelUpsertWithWhereUniqueWithoutProductInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$ProductModelUpsertWithWhereUniqueWithoutProductInput._(this._$data);

  factory Input$ProductModelUpsertWithWhereUniqueWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$ProductModelUpdateWithoutProductInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductModelCreateWithoutProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductModelUpsertWithWhereUniqueWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutProductInput get update =>
      (_$data['update'] as Input$ProductModelUpdateWithoutProductInput);
  Input$ProductModelCreateWithoutProductInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
          Input$ProductModelUpsertWithWhereUniqueWithoutProductInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductModelUpsertWithWhereUniqueWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput(
    Input$ProductModelUpsertWithWhereUniqueWithoutProductInput instance,
    TRes Function(Input$ProductModelUpsertWithWhereUniqueWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput;

  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutProductInput? update,
    Input$ProductModelCreateWithoutProductInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get update;
  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpsertWithWhereUniqueWithoutProductInput _instance;

  final TRes Function(
      Input$ProductModelUpsertWithWhereUniqueWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelUpsertWithWhereUniqueWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$ProductModelUpdateWithoutProductInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutProductInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductModelUpdateWithoutProductInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutProductInput? update,
    Input$ProductModelCreateWithoutProductInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get update =>
      CopyWith$Input$ProductModelUpdateWithoutProductInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutProductInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutProductInput.stub(_res);
}

class Input$ProductModelUpdateWithoutProductInput {
  factory Input$ProductModelUpdateWithoutProductInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      Input$ProductModelUpdateWithoutProductInput._({
        if (quantity != null) r'quantity': quantity,
        if (size != null) r'size': size,
        if (color != null) r'color': color,
      });

  Input$ProductModelUpdateWithoutProductInput._(this._$data);

  factory Input$ProductModelUpdateWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$SizesUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$color as Map<String, dynamic>));
    }
    return Input$ProductModelUpdateWithoutProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? get size =>
      (_$data['size']
          as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?);
  Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? get color =>
      (_$data['color']
          as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithoutProductInput<
          Input$ProductModelUpdateWithoutProductInput>
      get copyWith => CopyWith$Input$ProductModelUpdateWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> {
  factory CopyWith$Input$ProductModelUpdateWithoutProductInput(
    Input$ProductModelUpdateWithoutProductInput instance,
    TRes Function(Input$ProductModelUpdateWithoutProductInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithoutProductInput;

  factory CopyWith$Input$ProductModelUpdateWithoutProductInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithoutProductInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size;
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color;
}

class _CopyWithImpl$Input$ProductModelUpdateWithoutProductInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithoutProductInput _instance;

  final TRes Function(Input$ProductModelUpdateWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithoutProductInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (size != _undefined)
          'size': (size
              as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?),
        if (color != _undefined)
          'color': (color
              as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
            local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithoutProductInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithoutProductInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size =>
          CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color =>
          CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
}

class Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput {
  factory Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsUpsertWithoutProductModelInput? upsert,
    Input$ColorsWhereUniqueInput? connect,
    Input$ColorsUpdateWithoutProductModelInput? update,
  }) =>
      Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput._(this._$data);

  factory Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ColorsCreateWithoutProductModelInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ColorsCreateOrConnectWithoutProductModelInput.fromJson(
              (l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$ColorsUpsertWithoutProductModelInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ColorsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$ColorsUpdateWithoutProductModelInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ColorsCreateWithoutProductModelInput? get create =>
      (_$data['create'] as Input$ColorsCreateWithoutProductModelInput?);
  Input$ColorsCreateOrConnectWithoutProductModelInput? get connectOrCreate =>
      (_$data['connectOrCreate']
          as Input$ColorsCreateOrConnectWithoutProductModelInput?);
  Input$ColorsUpsertWithoutProductModelInput? get upsert =>
      (_$data['upsert'] as Input$ColorsUpsertWithoutProductModelInput?);
  Input$ColorsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ColorsWhereUniqueInput?);
  Input$ColorsUpdateWithoutProductModelInput? get update =>
      (_$data['update'] as Input$ColorsUpdateWithoutProductModelInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
          Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput>
      get copyWith =>
          CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
    TRes> {
  factory CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput instance,
    TRes Function(Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput)
        then,
  ) = _CopyWithImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput;

  factory CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput;

  TRes call({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsUpsertWithoutProductModelInput? upsert,
    Input$ColorsWhereUniqueInput? connect,
    Input$ColorsUpdateWithoutProductModelInput? update,
  });
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create;
  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> get upsert;
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect;
  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update;
}

class _CopyWithImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
    this._instance,
    this._then,
  );

  final Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput _instance;

  final TRes Function(
      Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as Input$ColorsCreateWithoutProductModelInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ColorsCreateOrConnectWithoutProductModelInput?),
        if (upsert != _undefined)
          'upsert': (upsert as Input$ColorsUpsertWithoutProductModelInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ColorsWhereUniqueInput?),
        if (update != _undefined)
          'update': (update as Input$ColorsUpdateWithoutProductModelInput?),
      }));
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsCreateWithoutProductModelInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$ColorsUpsertWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsUpsertWithoutProductModelInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ColorsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ColorsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$ColorsUpdateWithoutProductModelInput.stub(
            _then(_instance))
        : CopyWith$Input$ColorsUpdateWithoutProductModelInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
        TRes>
    implements
        CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
      this._res);

  TRes _res;

  call({
    Input$ColorsCreateWithoutProductModelInput? create,
    Input$ColorsCreateOrConnectWithoutProductModelInput? connectOrCreate,
    Input$ColorsUpsertWithoutProductModelInput? upsert,
    Input$ColorsWhereUniqueInput? connect,
    Input$ColorsUpdateWithoutProductModelInput? update,
  }) =>
      _res;
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ColorsCreateOrConnectWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> get upsert =>
      CopyWith$Input$ColorsUpsertWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ColorsWhereUniqueInput.stub(_res);
  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$ColorsUpdateWithoutProductModelInput.stub(_res);
}

class Input$ColorsUpsertWithoutProductModelInput {
  factory Input$ColorsUpsertWithoutProductModelInput({
    required Input$ColorsUpdateWithoutProductModelInput update,
    required Input$ColorsCreateWithoutProductModelInput create,
  }) =>
      Input$ColorsUpsertWithoutProductModelInput._({
        r'update': update,
        r'create': create,
      });

  Input$ColorsUpsertWithoutProductModelInput._(this._$data);

  factory Input$ColorsUpsertWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] = Input$ColorsUpdateWithoutProductModelInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ColorsCreateWithoutProductModelInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ColorsUpsertWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ColorsUpdateWithoutProductModelInput get update =>
      (_$data['update'] as Input$ColorsUpdateWithoutProductModelInput);
  Input$ColorsCreateWithoutProductModelInput get create =>
      (_$data['create'] as Input$ColorsCreateWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ColorsUpsertWithoutProductModelInput<
          Input$ColorsUpsertWithoutProductModelInput>
      get copyWith => CopyWith$Input$ColorsUpsertWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsUpsertWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ColorsUpsertWithoutProductModelInput(
    Input$ColorsUpsertWithoutProductModelInput instance,
    TRes Function(Input$ColorsUpsertWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ColorsUpsertWithoutProductModelInput;

  factory CopyWith$Input$ColorsUpsertWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsUpsertWithoutProductModelInput;

  TRes call({
    Input$ColorsUpdateWithoutProductModelInput? update,
    Input$ColorsCreateWithoutProductModelInput? create,
  });
  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update;
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create;
}

class _CopyWithImpl$Input$ColorsUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ColorsUpsertWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ColorsUpsertWithoutProductModelInput _instance;

  final TRes Function(Input$ColorsUpsertWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ColorsUpsertWithoutProductModelInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update': (update as Input$ColorsUpdateWithoutProductModelInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ColorsCreateWithoutProductModelInput),
      }));
  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ColorsUpdateWithoutProductModelInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ColorsCreateWithoutProductModelInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ColorsUpsertWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsUpsertWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ColorsUpsertWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$ColorsUpdateWithoutProductModelInput? update,
    Input$ColorsCreateWithoutProductModelInput? create,
  }) =>
      _res;
  CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> get update =>
      CopyWith$Input$ColorsUpdateWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsCreateWithoutProductModelInput<TRes> get create =>
      CopyWith$Input$ColorsCreateWithoutProductModelInput.stub(_res);
}

class Input$ColorsUpdateWithoutProductModelInput {
  factory Input$ColorsUpdateWithoutProductModelInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  }) =>
      Input$ColorsUpdateWithoutProductModelInput._({
        if (id != null) r'id': id,
        if (color != null) r'color': color,
      });

  Input$ColorsUpdateWithoutProductModelInput._(this._$data);

  factory Input$ColorsUpdateWithoutProductModelInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$color as Map<String, dynamic>));
    }
    return Input$ColorsUpdateWithoutProductModelInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get color =>
      (_$data['color'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ColorsUpdateWithoutProductModelInput<
          Input$ColorsUpdateWithoutProductModelInput>
      get copyWith => CopyWith$Input$ColorsUpdateWithoutProductModelInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ColorsUpdateWithoutProductModelInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> {
  factory CopyWith$Input$ColorsUpdateWithoutProductModelInput(
    Input$ColorsUpdateWithoutProductModelInput instance,
    TRes Function(Input$ColorsUpdateWithoutProductModelInput) then,
  ) = _CopyWithImpl$Input$ColorsUpdateWithoutProductModelInput;

  factory CopyWith$Input$ColorsUpdateWithoutProductModelInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ColorsUpdateWithoutProductModelInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color;
}

class _CopyWithImpl$Input$ColorsUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> {
  _CopyWithImpl$Input$ColorsUpdateWithoutProductModelInput(
    this._instance,
    this._then,
  );

  final Input$ColorsUpdateWithoutProductModelInput _instance;

  final TRes Function(Input$ColorsUpdateWithoutProductModelInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ColorsUpdateWithoutProductModelInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (color != _undefined)
          'color': (color as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ColorsUpdateWithoutProductModelInput<TRes>
    implements CopyWith$Input$ColorsUpdateWithoutProductModelInput<TRes> {
  _CopyWithStubImpl$Input$ColorsUpdateWithoutProductModelInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? color,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get color =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ProductModelUpdateWithWhereUniqueWithoutProductInput {
  factory Input$ProductModelUpdateWithWhereUniqueWithoutProductInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutProductInput data,
  }) =>
      Input$ProductModelUpdateWithWhereUniqueWithoutProductInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateWithWhereUniqueWithoutProductInput._(this._$data);

  factory Input$ProductModelUpdateWithWhereUniqueWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateWithoutProductInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateWithWhereUniqueWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutProductInput get data =>
      (_$data['data'] as Input$ProductModelUpdateWithoutProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
          Input$ProductModelUpdateWithWhereUniqueWithoutProductInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductModelUpdateWithWhereUniqueWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput(
    Input$ProductModelUpdateWithWhereUniqueWithoutProductInput instance,
    TRes Function(Input$ProductModelUpdateWithWhereUniqueWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput;

  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutProductInput? data,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithWhereUniqueWithoutProductInput _instance;

  final TRes Function(
      Input$ProductModelUpdateWithWhereUniqueWithoutProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithWhereUniqueWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateWithoutProductInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateWithoutProductInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutProductInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutProductInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateWithoutProductInput.stub(_res);
}

class Input$ProductModelUpdateManyWithWhereWithoutProductInput {
  factory Input$ProductModelUpdateManyWithWhereWithoutProductInput({
    required Input$ProductModelScalarWhereInput where,
    required Input$ProductModelUpdateManyMutationInput data,
  }) =>
      Input$ProductModelUpdateManyWithWhereWithoutProductInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateManyWithWhereWithoutProductInput._(this._$data);

  factory Input$ProductModelUpdateManyWithWhereWithoutProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateManyWithWhereWithoutProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelScalarWhereInput get where =>
      (_$data['where'] as Input$ProductModelScalarWhereInput);
  Input$ProductModelUpdateManyMutationInput get data =>
      (_$data['data'] as Input$ProductModelUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
          Input$ProductModelUpdateManyWithWhereWithoutProductInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithWhereWithoutProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput(
    Input$ProductModelUpdateManyWithWhereWithoutProductInput instance,
    TRes Function(Input$ProductModelUpdateManyWithWhereWithoutProductInput)
        then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput;

  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput;

  TRes call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  });
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
            TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithWhereWithoutProductInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithWhereWithoutProductInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithWhereWithoutProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateManyMutationInput),
      }));
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutProductInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where =>
      CopyWith$Input$ProductModelScalarWhereInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateManyMutationInput.stub(_res);
}

class Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput {
  factory Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput({
    required Input$ProductsWhereUniqueInput where,
    required Input$ProductsUpdateWithoutFamilyInput data,
  }) =>
      Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput._(this._$data);

  factory Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductsUpdateWithoutFamilyInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductsWhereUniqueInput);
  Input$ProductsUpdateWithoutFamilyInput get data =>
      (_$data['data'] as Input$ProductsUpdateWithoutFamilyInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<
          Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput>
      get copyWith =>
          CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<
    TRes> {
  factory CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput(
    Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput instance,
    TRes Function(Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput;

  factory CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput;

  TRes call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsUpdateWithoutFamilyInput? data,
  });
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<TRes>
    implements
        CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductsUpdateWithoutFamilyInput),
      }));
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductsUpdateWithoutFamilyInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateWithWhereUniqueWithoutFamilyInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsUpdateWithoutFamilyInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsUpdateWithoutFamilyInput<TRes> get data =>
      CopyWith$Input$ProductsUpdateWithoutFamilyInput.stub(_res);
}

class Input$ProductsUpdateManyWithWhereWithoutFamilyInput {
  factory Input$ProductsUpdateManyWithWhereWithoutFamilyInput({
    required Input$ProductsScalarWhereInput where,
    required Input$ProductsUpdateManyMutationInput data,
  }) =>
      Input$ProductsUpdateManyWithWhereWithoutFamilyInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductsUpdateManyWithWhereWithoutFamilyInput._(this._$data);

  factory Input$ProductsUpdateManyWithWhereWithoutFamilyInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductsUpdateManyWithWhereWithoutFamilyInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsScalarWhereInput get where =>
      (_$data['where'] as Input$ProductsScalarWhereInput);
  Input$ProductsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$ProductsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<
          Input$ProductsUpdateManyWithWhereWithoutFamilyInput>
      get copyWith =>
          CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateManyWithWhereWithoutFamilyInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<
    TRes> {
  factory CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput(
    Input$ProductsUpdateManyWithWhereWithoutFamilyInput instance,
    TRes Function(Input$ProductsUpdateManyWithWhereWithoutFamilyInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput;

  factory CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput;

  TRes call({
    Input$ProductsScalarWhereInput? where,
    Input$ProductsUpdateManyMutationInput? data,
  });
  CopyWith$Input$ProductsScalarWhereInput<TRes> get where;
  CopyWith$Input$ProductsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<TRes>
    implements
        CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateManyWithWhereWithoutFamilyInput _instance;

  final TRes Function(Input$ProductsUpdateManyWithWhereWithoutFamilyInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductsUpdateManyWithWhereWithoutFamilyInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductsUpdateManyMutationInput),
      }));
  CopyWith$Input$ProductsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateManyWithWhereWithoutFamilyInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateManyWithWhereWithoutFamilyInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsScalarWhereInput? where,
    Input$ProductsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductsScalarWhereInput<TRes> get where =>
      CopyWith$Input$ProductsScalarWhereInput.stub(_res);
  CopyWith$Input$ProductsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$ProductsUpdateManyMutationInput.stub(_res);
}

class Input$ProductsScalarWhereInput {
  factory Input$ProductsScalarWhereInput({
    List<Input$ProductsScalarWhereInput>? AND,
    List<Input$ProductsScalarWhereInput>? OR,
    List<Input$ProductsScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
  }) =>
      Input$ProductsScalarWhereInput._({
        if (AND != null) r'AND': AND,
        if (OR != null) r'OR': OR,
        if (NOT != null) r'NOT': NOT,
        if (product_id != null) r'product_id': product_id,
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family_id != null) r'family_id': family_id,
      });

  Input$ProductsScalarWhereInput._(this._$data);

  factory Input$ProductsScalarWhereInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('AND')) {
      final l$AND = data['AND'];
      result$data['AND'] = (l$AND as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('OR')) {
      final l$OR = data['OR'];
      result$data['OR'] = (l$OR as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('NOT')) {
      final l$NOT = data['NOT'];
      result$data['NOT'] = (l$NOT as List<dynamic>?)
          ?.map((e) => Input$ProductsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFilter.fromJson((l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFilter.fromJson((l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFilter.fromJson((l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFilter.fromJson((l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFilter.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFilter.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFilter.fromJson((l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family_id')) {
      final l$family_id = data['family_id'];
      result$data['family_id'] = l$family_id == null
          ? null
          : Input$IntFilter.fromJson((l$family_id as Map<String, dynamic>));
    }
    return Input$ProductsScalarWhereInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductsScalarWhereInput>? get AND =>
      (_$data['AND'] as List<Input$ProductsScalarWhereInput>?);
  List<Input$ProductsScalarWhereInput>? get OR =>
      (_$data['OR'] as List<Input$ProductsScalarWhereInput>?);
  List<Input$ProductsScalarWhereInput>? get NOT =>
      (_$data['NOT'] as List<Input$ProductsScalarWhereInput>?);
  Input$IntFilter? get product_id => (_$data['product_id'] as Input$IntFilter?);
  Input$IntFilter? get reference => (_$data['reference'] as Input$IntFilter?);
  Input$StringFilter? get name => (_$data['name'] as Input$StringFilter?);
  Input$FloatFilter? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFilter?);
  Input$FloatFilter? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFilter?);
  Input$StringFilter? get description =>
      (_$data['description'] as Input$StringFilter?);
  Input$StringFilter? get picture => (_$data['picture'] as Input$StringFilter?);
  Input$IntFilter? get family_id => (_$data['family_id'] as Input$IntFilter?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('AND')) {
      final l$AND = AND;
      result$data['AND'] = l$AND?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('OR')) {
      final l$OR = OR;
      result$data['OR'] = l$OR?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('NOT')) {
      final l$NOT = NOT;
      result$data['NOT'] = l$NOT?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family_id')) {
      final l$family_id = family_id;
      result$data['family_id'] = l$family_id?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsScalarWhereInput<Input$ProductsScalarWhereInput>
      get copyWith => CopyWith$Input$ProductsScalarWhereInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsScalarWhereInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$AND = AND;
    final lOther$AND = other.AND;
    if (_$data.containsKey('AND') != other._$data.containsKey('AND')) {
      return false;
    }
    if (l$AND != null && lOther$AND != null) {
      if (l$AND.length != lOther$AND.length) {
        return false;
      }
      for (int i = 0; i < l$AND.length; i++) {
        final l$AND$entry = l$AND[i];
        final lOther$AND$entry = lOther$AND[i];
        if (l$AND$entry != lOther$AND$entry) {
          return false;
        }
      }
    } else if (l$AND != lOther$AND) {
      return false;
    }
    final l$OR = OR;
    final lOther$OR = other.OR;
    if (_$data.containsKey('OR') != other._$data.containsKey('OR')) {
      return false;
    }
    if (l$OR != null && lOther$OR != null) {
      if (l$OR.length != lOther$OR.length) {
        return false;
      }
      for (int i = 0; i < l$OR.length; i++) {
        final l$OR$entry = l$OR[i];
        final lOther$OR$entry = lOther$OR[i];
        if (l$OR$entry != lOther$OR$entry) {
          return false;
        }
      }
    } else if (l$OR != lOther$OR) {
      return false;
    }
    final l$NOT = NOT;
    final lOther$NOT = other.NOT;
    if (_$data.containsKey('NOT') != other._$data.containsKey('NOT')) {
      return false;
    }
    if (l$NOT != null && lOther$NOT != null) {
      if (l$NOT.length != lOther$NOT.length) {
        return false;
      }
      for (int i = 0; i < l$NOT.length; i++) {
        final l$NOT$entry = l$NOT[i];
        final lOther$NOT$entry = lOther$NOT[i];
        if (l$NOT$entry != lOther$NOT$entry) {
          return false;
        }
      }
    } else if (l$NOT != lOther$NOT) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family_id = family_id;
    final lOther$family_id = other.family_id;
    if (_$data.containsKey('family_id') !=
        other._$data.containsKey('family_id')) {
      return false;
    }
    if (l$family_id != lOther$family_id) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$AND = AND;
    final l$OR = OR;
    final l$NOT = NOT;
    final l$product_id = product_id;
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family_id = family_id;
    return Object.hashAll([
      _$data.containsKey('AND')
          ? l$AND == null
              ? null
              : Object.hashAll(l$AND.map((v) => v))
          : const {},
      _$data.containsKey('OR')
          ? l$OR == null
              ? null
              : Object.hashAll(l$OR.map((v) => v))
          : const {},
      _$data.containsKey('NOT')
          ? l$NOT == null
              ? null
              : Object.hashAll(l$NOT.map((v) => v))
          : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family_id') ? l$family_id : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsScalarWhereInput<TRes> {
  factory CopyWith$Input$ProductsScalarWhereInput(
    Input$ProductsScalarWhereInput instance,
    TRes Function(Input$ProductsScalarWhereInput) then,
  ) = _CopyWithImpl$Input$ProductsScalarWhereInput;

  factory CopyWith$Input$ProductsScalarWhereInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsScalarWhereInput;

  TRes call({
    List<Input$ProductsScalarWhereInput>? AND,
    List<Input$ProductsScalarWhereInput>? OR,
    List<Input$ProductsScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
  });
  TRes AND(
      Iterable<Input$ProductsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereInput<
                      Input$ProductsScalarWhereInput>>?)
          _fn);
  TRes OR(
      Iterable<Input$ProductsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereInput<
                      Input$ProductsScalarWhereInput>>?)
          _fn);
  TRes NOT(
      Iterable<Input$ProductsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductsScalarWhereInput<
                      Input$ProductsScalarWhereInput>>?)
          _fn);
  CopyWith$Input$IntFilter<TRes> get product_id;
  CopyWith$Input$IntFilter<TRes> get reference;
  CopyWith$Input$StringFilter<TRes> get name;
  CopyWith$Input$FloatFilter<TRes> get buyingPrice;
  CopyWith$Input$FloatFilter<TRes> get sellingPrice;
  CopyWith$Input$StringFilter<TRes> get description;
  CopyWith$Input$StringFilter<TRes> get picture;
  CopyWith$Input$IntFilter<TRes> get family_id;
}

class _CopyWithImpl$Input$ProductsScalarWhereInput<TRes>
    implements CopyWith$Input$ProductsScalarWhereInput<TRes> {
  _CopyWithImpl$Input$ProductsScalarWhereInput(
    this._instance,
    this._then,
  );

  final Input$ProductsScalarWhereInput _instance;

  final TRes Function(Input$ProductsScalarWhereInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? AND = _undefined,
    Object? OR = _undefined,
    Object? NOT = _undefined,
    Object? product_id = _undefined,
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family_id = _undefined,
  }) =>
      _then(Input$ProductsScalarWhereInput._({
        ..._instance._$data,
        if (AND != _undefined)
          'AND': (AND as List<Input$ProductsScalarWhereInput>?),
        if (OR != _undefined)
          'OR': (OR as List<Input$ProductsScalarWhereInput>?),
        if (NOT != _undefined)
          'NOT': (NOT as List<Input$ProductsScalarWhereInput>?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFilter?),
        if (reference != _undefined)
          'reference': (reference as Input$IntFilter?),
        if (name != _undefined) 'name': (name as Input$StringFilter?),
        if (buyingPrice != _undefined)
          'buyingPrice': (buyingPrice as Input$FloatFilter?),
        if (sellingPrice != _undefined)
          'sellingPrice': (sellingPrice as Input$FloatFilter?),
        if (description != _undefined)
          'description': (description as Input$StringFilter?),
        if (picture != _undefined) 'picture': (picture as Input$StringFilter?),
        if (family_id != _undefined)
          'family_id': (family_id as Input$IntFilter?),
      }));
  TRes AND(
          Iterable<Input$ProductsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereInput<
                          Input$ProductsScalarWhereInput>>?)
              _fn) =>
      call(
          AND: _fn(
              _instance.AND?.map((e) => CopyWith$Input$ProductsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes OR(
          Iterable<Input$ProductsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereInput<
                          Input$ProductsScalarWhereInput>>?)
              _fn) =>
      call(
          OR: _fn(
              _instance.OR?.map((e) => CopyWith$Input$ProductsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes NOT(
          Iterable<Input$ProductsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductsScalarWhereInput<
                          Input$ProductsScalarWhereInput>>?)
              _fn) =>
      call(
          NOT: _fn(
              _instance.NOT?.map((e) => CopyWith$Input$ProductsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
  CopyWith$Input$IntFilter<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$IntFilter<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFilter<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFilter<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFilter<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFilter.stub(_then(_instance))
        : CopyWith$Input$FloatFilter(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFilter<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFilter<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFilter.stub(_then(_instance))
        : CopyWith$Input$StringFilter(local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$IntFilter<TRes> get family_id {
    final local$family_id = _instance.family_id;
    return local$family_id == null
        ? CopyWith$Input$IntFilter.stub(_then(_instance))
        : CopyWith$Input$IntFilter(local$family_id, (e) => call(family_id: e));
  }
}

class _CopyWithStubImpl$Input$ProductsScalarWhereInput<TRes>
    implements CopyWith$Input$ProductsScalarWhereInput<TRes> {
  _CopyWithStubImpl$Input$ProductsScalarWhereInput(this._res);

  TRes _res;

  call({
    List<Input$ProductsScalarWhereInput>? AND,
    List<Input$ProductsScalarWhereInput>? OR,
    List<Input$ProductsScalarWhereInput>? NOT,
    Input$IntFilter? product_id,
    Input$IntFilter? reference,
    Input$StringFilter? name,
    Input$FloatFilter? buyingPrice,
    Input$FloatFilter? sellingPrice,
    Input$StringFilter? description,
    Input$StringFilter? picture,
    Input$IntFilter? family_id,
  }) =>
      _res;
  AND(_fn) => _res;
  OR(_fn) => _res;
  NOT(_fn) => _res;
  CopyWith$Input$IntFilter<TRes> get product_id =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get reference =>
      CopyWith$Input$IntFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get name =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get buyingPrice =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$FloatFilter<TRes> get sellingPrice =>
      CopyWith$Input$FloatFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get description =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$StringFilter<TRes> get picture =>
      CopyWith$Input$StringFilter.stub(_res);
  CopyWith$Input$IntFilter<TRes> get family_id =>
      CopyWith$Input$IntFilter.stub(_res);
}

class Input$ProductsUpdateManyMutationInput {
  factory Input$ProductsUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      Input$ProductsUpdateManyMutationInput._({
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
      });

  Input$ProductsUpdateManyMutationInput._(this._$data);

  factory Input$ProductsUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    return Input$ProductsUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get reference =>
      (_$data['reference'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateManyMutationInput<
          Input$ProductsUpdateManyMutationInput>
      get copyWith => CopyWith$Input$ProductsUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$ProductsUpdateManyMutationInput(
    Input$ProductsUpdateManyMutationInput instance,
    TRes Function(Input$ProductsUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateManyMutationInput;

  factory CopyWith$Input$ProductsUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
}

class _CopyWithImpl$Input$ProductsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductsUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateManyMutationInput _instance;

  final TRes Function(Input$ProductsUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$ProductsUpdateManyMutationInput._({
        ..._instance._$data,
        if (reference != _undefined)
          'reference': (reference as Input$IntFieldUpdateOperationsInput?),
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (buyingPrice != _undefined)
          'buyingPrice':
              (buyingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (sellingPrice != _undefined)
          'sellingPrice':
              (sellingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateManyMutationInput<TRes>
    implements CopyWith$Input$ProductsUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$ProductModelCreateInput {
  factory Input$ProductModelCreateInput({
    required int quantity,
    required Input$ProductsCreateNestedOneWithoutProductModelInput product,
    required Input$SizesCreateNestedOneWithoutProductModelInput size,
    required Input$ColorsCreateNestedOneWithoutProductModelInput color,
  }) =>
      Input$ProductModelCreateInput._({
        r'quantity': quantity,
        r'product': product,
        r'size': size,
        r'color': color,
      });

  Input$ProductModelCreateInput._(this._$data);

  factory Input$ProductModelCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$product = data['product'];
    result$data['product'] =
        Input$ProductsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$product as Map<String, dynamic>));
    final l$size = data['size'];
    result$data['size'] =
        Input$SizesCreateNestedOneWithoutProductModelInput.fromJson(
            (l$size as Map<String, dynamic>));
    final l$color = data['color'];
    result$data['color'] =
        Input$ColorsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$color as Map<String, dynamic>));
    return Input$ProductModelCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  Input$ProductsCreateNestedOneWithoutProductModelInput get product =>
      (_$data['product']
          as Input$ProductsCreateNestedOneWithoutProductModelInput);
  Input$SizesCreateNestedOneWithoutProductModelInput get size =>
      (_$data['size'] as Input$SizesCreateNestedOneWithoutProductModelInput);
  Input$ColorsCreateNestedOneWithoutProductModelInput get color =>
      (_$data['color'] as Input$ColorsCreateNestedOneWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$product = product;
    result$data['product'] = l$product.toJson();
    final l$size = size;
    result$data['size'] = l$size.toJson();
    final l$color = color;
    result$data['color'] = l$color.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateInput<Input$ProductModelCreateInput>
      get copyWith => CopyWith$Input$ProductModelCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      l$quantity,
      l$product,
      l$size,
      l$color,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateInput<TRes> {
  factory CopyWith$Input$ProductModelCreateInput(
    Input$ProductModelCreateInput instance,
    TRes Function(Input$ProductModelCreateInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateInput;

  factory CopyWith$Input$ProductModelCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateInput;

  TRes call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  });
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product;
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size;
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color;
}

class _CopyWithImpl$Input$ProductModelCreateInput<TRes>
    implements CopyWith$Input$ProductModelCreateInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateInput _instance;

  final TRes Function(Input$ProductModelCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelCreateInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (product != _undefined && product != null)
          'product': (product
              as Input$ProductsCreateNestedOneWithoutProductModelInput),
        if (size != _undefined && size != null)
          'size': (size as Input$SizesCreateNestedOneWithoutProductModelInput),
        if (color != _undefined && color != null)
          'color':
              (color as Input$ColorsCreateNestedOneWithoutProductModelInput),
      }));
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product {
    final local$product = _instance.product;
    return CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput(
        local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size {
    final local$size = _instance.size;
    return CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput(
        local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color {
    final local$color = _instance.color;
    return CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput(
        local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateInput<TRes>
    implements CopyWith$Input$ProductModelCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateInput(this._res);

  TRes _res;

  call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$SizesCreateNestedOneWithoutProductModelInput? size,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product =>
          CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput<TRes> get size =>
      CopyWith$Input$SizesCreateNestedOneWithoutProductModelInput.stub(_res);
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes>
      get color =>
          CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput.stub(
              _res);
}

class Input$ProductModelUpdateInput {
  factory Input$ProductModelUpdateInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      Input$ProductModelUpdateInput._({
        if (quantity != null) r'quantity': quantity,
        if (product != null) r'product': product,
        if (size != null) r'size': size,
        if (color != null) r'color': color,
      });

  Input$ProductModelUpdateInput._(this._$data);

  factory Input$ProductModelUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$product as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$SizesUpdateOneRequiredWithoutProductModelNestedInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$color as Map<String, dynamic>));
    }
    return Input$ProductModelUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? get product =>
      (_$data['product']
          as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?);
  Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? get size =>
      (_$data['size']
          as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?);
  Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? get color =>
      (_$data['color']
          as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateInput<Input$ProductModelUpdateInput>
      get copyWith => CopyWith$Input$ProductModelUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$size = size;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('product') ? l$product : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateInput<TRes> {
  factory CopyWith$Input$ProductModelUpdateInput(
    Input$ProductModelUpdateInput instance,
    TRes Function(Input$ProductModelUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateInput;

  factory CopyWith$Input$ProductModelUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product;
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size;
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color;
}

class _CopyWithImpl$Input$ProductModelUpdateInput<TRes>
    implements CopyWith$Input$ProductModelUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateInput _instance;

  final TRes Function(Input$ProductModelUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? size = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelUpdateInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (product != _undefined)
          'product': (product
              as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?),
        if (size != _undefined)
          'size': (size
              as Input$SizesUpdateOneRequiredWithoutProductModelNestedInput?),
        if (color != _undefined)
          'color': (color
              as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
            local$product, (e) => call(product: e));
  }

  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput(
            local$size, (e) => call(size: e));
  }

  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateInput<TRes>
    implements CopyWith$Input$ProductModelUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$SizesUpdateOneRequiredWithoutProductModelNestedInput? size,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
  CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get size =>
          CopyWith$Input$SizesUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color =>
          CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
}

class Input$ProductsCreateInput {
  factory Input$ProductsCreateInput({
    required int reference,
    required String name,
    required double buyingPrice,
    required double sellingPrice,
    required String description,
    required String picture,
    required Input$ProductFamilyCreateNestedOneWithoutProductsInput family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      Input$ProductsCreateInput._({
        r'reference': reference,
        r'name': name,
        r'buyingPrice': buyingPrice,
        r'sellingPrice': sellingPrice,
        r'description': description,
        r'picture': picture,
        r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsCreateInput._(this._$data);

  factory Input$ProductsCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reference = data['reference'];
    result$data['reference'] = (l$reference as int);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$buyingPrice = data['buyingPrice'];
    result$data['buyingPrice'] = (l$buyingPrice as num).toDouble();
    final l$sellingPrice = data['sellingPrice'];
    result$data['sellingPrice'] = (l$sellingPrice as num).toDouble();
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    final l$family = data['family'];
    result$data['family'] =
        Input$ProductFamilyCreateNestedOneWithoutProductsInput.fromJson(
            (l$family as Map<String, dynamic>));
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelCreateNestedManyWithoutProductInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductCreateNestedManyWithoutProductInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get reference => (_$data['reference'] as int);
  String get name => (_$data['name'] as String);
  double get buyingPrice => (_$data['buyingPrice'] as double);
  double get sellingPrice => (_$data['sellingPrice'] as double);
  String get description => (_$data['description'] as String);
  String get picture => (_$data['picture'] as String);
  Input$ProductFamilyCreateNestedOneWithoutProductsInput get family =>
      (_$data['family']
          as Input$ProductFamilyCreateNestedOneWithoutProductsInput);
  Input$ProductModelCreateNestedManyWithoutProductInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelCreateNestedManyWithoutProductInput?);
  Input$TransactionProductCreateNestedManyWithoutProductInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductCreateNestedManyWithoutProductInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reference = reference;
    result$data['reference'] = l$reference;
    final l$name = name;
    result$data['name'] = l$name;
    final l$buyingPrice = buyingPrice;
    result$data['buyingPrice'] = l$buyingPrice;
    final l$sellingPrice = sellingPrice;
    result$data['sellingPrice'] = l$sellingPrice;
    final l$description = description;
    result$data['description'] = l$description;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    final l$family = family;
    result$data['family'] = l$family.toJson();
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateInput<Input$ProductsCreateInput> get copyWith =>
      CopyWith$Input$ProductsCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      l$reference,
      l$name,
      l$buyingPrice,
      l$sellingPrice,
      l$description,
      l$picture,
      l$family,
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateInput<TRes> {
  factory CopyWith$Input$ProductsCreateInput(
    Input$ProductsCreateInput instance,
    TRes Function(Input$ProductsCreateInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateInput;

  factory CopyWith$Input$ProductsCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateInput;

  TRes call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  });
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family;
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel;
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsCreateInput<TRes>
    implements CopyWith$Input$ProductsCreateInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateInput _instance;

  final TRes Function(Input$ProductsCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsCreateInput._({
        ..._instance._$data,
        if (reference != _undefined && reference != null)
          'reference': (reference as int),
        if (name != _undefined && name != null) 'name': (name as String),
        if (buyingPrice != _undefined && buyingPrice != null)
          'buyingPrice': (buyingPrice as double),
        if (sellingPrice != _undefined && sellingPrice != null)
          'sellingPrice': (sellingPrice as double),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
        if (family != _undefined && family != null)
          'family': (family
              as Input$ProductFamilyCreateNestedOneWithoutProductsInput),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelCreateNestedManyWithoutProductInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductCreateNestedManyWithoutProductInput?),
      }));
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family {
    final local$family = _instance.family;
    return CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
        local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateInput<TRes>
    implements CopyWith$Input$ProductsCreateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateInput(this._res);

  TRes _res;

  call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
    Input$TransactionProductCreateNestedManyWithoutProductInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput.stub(
              _res);
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
              _res);
  CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductCreateNestedManyWithoutProductInput
              .stub(_res);
}

class Input$ProductsUpdateInput {
  factory Input$ProductsUpdateInput({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      Input$ProductsUpdateInput._({
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family != null) r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
        if (TransactionProduct != null)
          r'TransactionProduct': TransactionProduct,
      });

  Input$ProductsUpdateInput._(this._$data);

  factory Input$ProductsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family')) {
      final l$family = data['family'];
      result$data['family'] = l$family == null
          ? null
          : Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .fromJson((l$family as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelUpdateManyWithoutProductNestedInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    if (data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = data['TransactionProduct'];
      result$data['TransactionProduct'] = l$TransactionProduct == null
          ? null
          : Input$TransactionProductUpdateManyWithoutProductNestedInput
              .fromJson((l$TransactionProduct as Map<String, dynamic>));
    }
    return Input$ProductsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get reference =>
      (_$data['reference'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? get family =>
      (_$data['family']
          as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?);
  Input$ProductModelUpdateManyWithoutProductNestedInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelUpdateManyWithoutProductNestedInput?);
  Input$TransactionProductUpdateManyWithoutProductNestedInput?
      get TransactionProduct => (_$data['TransactionProduct']
          as Input$TransactionProductUpdateManyWithoutProductNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family')) {
      final l$family = family;
      result$data['family'] = l$family?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    if (_$data.containsKey('TransactionProduct')) {
      final l$TransactionProduct = TransactionProduct;
      result$data['TransactionProduct'] = l$TransactionProduct?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateInput<Input$ProductsUpdateInput> get copyWith =>
      CopyWith$Input$ProductsUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (_$data.containsKey('family') != other._$data.containsKey('family')) {
      return false;
    }
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    final l$TransactionProduct = TransactionProduct;
    final lOther$TransactionProduct = other.TransactionProduct;
    if (_$data.containsKey('TransactionProduct') !=
        other._$data.containsKey('TransactionProduct')) {
      return false;
    }
    if (l$TransactionProduct != lOther$TransactionProduct) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$ProductModel = ProductModel;
    final l$TransactionProduct = TransactionProduct;
    return Object.hashAll([
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family') ? l$family : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
      _$data.containsKey('TransactionProduct')
          ? l$TransactionProduct
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateInput<TRes> {
  factory CopyWith$Input$ProductsUpdateInput(
    Input$ProductsUpdateInput instance,
    TRes Function(Input$ProductsUpdateInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateInput;

  factory CopyWith$Input$ProductsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family;
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel;
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct;
}

class _CopyWithImpl$Input$ProductsUpdateInput<TRes>
    implements CopyWith$Input$ProductsUpdateInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateInput _instance;

  final TRes Function(Input$ProductsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
    Object? TransactionProduct = _undefined,
  }) =>
      _then(Input$ProductsUpdateInput._({
        ..._instance._$data,
        if (reference != _undefined)
          'reference': (reference as Input$IntFieldUpdateOperationsInput?),
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (buyingPrice != _undefined)
          'buyingPrice':
              (buyingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (sellingPrice != _undefined)
          'sellingPrice':
              (sellingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
        if (family != _undefined)
          'family': (family
              as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelUpdateManyWithoutProductNestedInput?),
        if (TransactionProduct != _undefined)
          'TransactionProduct': (TransactionProduct
              as Input$TransactionProductUpdateManyWithoutProductNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family {
    final local$family = _instance.family;
    return local$family == null
        ? CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
            local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }

  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct {
    final local$TransactionProduct = _instance.TransactionProduct;
    return local$TransactionProduct == null
        ? CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput(
            local$TransactionProduct, (e) => call(TransactionProduct: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateInput<TRes>
    implements CopyWith$Input$ProductsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
    Input$TransactionProductUpdateManyWithoutProductNestedInput?
        TransactionProduct,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .stub(_res);
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
              _res);
  CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput<TRes>
      get TransactionProduct =>
          CopyWith$Input$TransactionProductUpdateManyWithoutProductNestedInput
              .stub(_res);
}

class Input$SellersCreateInput {
  factory Input$SellersCreateInput({
    required String seller_name,
    required String seller_phone,
    required String picture,
    Input$TransactionsCreateNestedManyWithoutSellerInput? Transactions,
  }) =>
      Input$SellersCreateInput._({
        r'seller_name': seller_name,
        r'seller_phone': seller_phone,
        r'picture': picture,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$SellersCreateInput._(this._$data);

  factory Input$SellersCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$seller_name = data['seller_name'];
    result$data['seller_name'] = (l$seller_name as String);
    final l$seller_phone = data['seller_phone'];
    result$data['seller_phone'] = (l$seller_phone as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsCreateNestedManyWithoutSellerInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$SellersCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get seller_name => (_$data['seller_name'] as String);
  String get seller_phone => (_$data['seller_phone'] as String);
  String get picture => (_$data['picture'] as String);
  Input$TransactionsCreateNestedManyWithoutSellerInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsCreateNestedManyWithoutSellerInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$seller_name = seller_name;
    result$data['seller_name'] = l$seller_name;
    final l$seller_phone = seller_phone;
    result$data['seller_phone'] = l$seller_phone;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersCreateInput<Input$SellersCreateInput> get copyWith =>
      CopyWith$Input$SellersCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    final l$Transactions = Transactions;
    return Object.hashAll([
      l$seller_name,
      l$seller_phone,
      l$picture,
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersCreateInput<TRes> {
  factory CopyWith$Input$SellersCreateInput(
    Input$SellersCreateInput instance,
    TRes Function(Input$SellersCreateInput) then,
  ) = _CopyWithImpl$Input$SellersCreateInput;

  factory CopyWith$Input$SellersCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersCreateInput;

  TRes call({
    String? seller_name,
    String? seller_phone,
    String? picture,
    Input$TransactionsCreateNestedManyWithoutSellerInput? Transactions,
  });
  CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$SellersCreateInput<TRes>
    implements CopyWith$Input$SellersCreateInput<TRes> {
  _CopyWithImpl$Input$SellersCreateInput(
    this._instance,
    this._then,
  );

  final Input$SellersCreateInput _instance;

  final TRes Function(Input$SellersCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$SellersCreateInput._({
        ..._instance._$data,
        if (seller_name != _undefined && seller_name != null)
          'seller_name': (seller_name as String),
        if (seller_phone != _undefined && seller_phone != null)
          'seller_phone': (seller_phone as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsCreateNestedManyWithoutSellerInput?),
      }));
  CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$SellersCreateInput<TRes>
    implements CopyWith$Input$SellersCreateInput<TRes> {
  _CopyWithStubImpl$Input$SellersCreateInput(this._res);

  TRes _res;

  call({
    String? seller_name,
    String? seller_phone,
    String? picture,
    Input$TransactionsCreateNestedManyWithoutSellerInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput.stub(
              _res);
}

class Input$TransactionsCreateNestedManyWithoutSellerInput {
  factory Input$TransactionsCreateNestedManyWithoutSellerInput({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      Input$TransactionsCreateNestedManyWithoutSellerInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionsCreateNestedManyWithoutSellerInput._(this._$data);

  factory Input$TransactionsCreateNestedManyWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutSellerInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutSellerInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsCreateNestedManyWithoutSellerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutSellerInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutSellerInput>?);
  List<Input$TransactionsCreateOrConnectWithoutSellerInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutSellerInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<
          Input$TransactionsCreateNestedManyWithoutSellerInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateNestedManyWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput(
    Input$TransactionsCreateNestedManyWithoutSellerInput instance,
    TRes Function(Input$TransactionsCreateNestedManyWithoutSellerInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutSellerInput;

  factory CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutSellerInput;

  TRes call({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutSellerInput<
                      Input$TransactionsCreateWithoutSellerInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
                      Input$TransactionsCreateOrConnectWithoutSellerInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateNestedManyWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsCreateNestedManyWithoutSellerInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionsCreateNestedManyWithoutSellerInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$TransactionsCreateWithoutSellerInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutSellerInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutSellerInput<
                          Input$TransactionsCreateWithoutSellerInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutSellerInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
                          Input$TransactionsCreateOrConnectWithoutSellerInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutSellerInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutSellerInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$TransactionsCreateWithoutSellerInput {
  factory Input$TransactionsCreateWithoutSellerInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$CityCreateNestedOneWithoutTransactionsInput city,
    required Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      Input$TransactionsCreateWithoutSellerInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'city': city,
        r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsCreateWithoutSellerInput._(this._$data);

  factory Input$TransactionsCreateWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$city = data['city'];
    result$data['city'] =
        Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$city as Map<String, dynamic>));
    final l$transaction_type = data['transaction_type'];
    result$data['transaction_type'] =
        Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$transaction_type as Map<String, dynamic>));
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsCreateWithoutSellerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$CityCreateNestedOneWithoutTransactionsInput get city =>
      (_$data['city'] as Input$CityCreateNestedOneWithoutTransactionsInput);
  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput);
  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? get status =>
      (_$data['status']
          as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?);
  Input$PayementsCreateNestedManyWithoutTransactionInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsCreateNestedManyWithoutTransactionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$city = city;
    result$data['city'] = l$city.toJson();
    final l$transaction_type = transaction_type;
    result$data['transaction_type'] = l$transaction_type.toJson();
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateWithoutSellerInput<
          Input$TransactionsCreateWithoutSellerInput>
      get copyWith => CopyWith$Input$TransactionsCreateWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$city,
      l$transaction_type,
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> {
  factory CopyWith$Input$TransactionsCreateWithoutSellerInput(
    Input$TransactionsCreateWithoutSellerInput instance,
    TRes Function(Input$TransactionsCreateWithoutSellerInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateWithoutSellerInput;

  factory CopyWith$Input$TransactionsCreateWithoutSellerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateWithoutSellerInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  });
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city;
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type;
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status;
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsCreateWithoutSellerInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsCreateWithoutSellerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsCreateWithoutSellerInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (city != _undefined && city != null)
          'city': (city as Input$CityCreateNestedOneWithoutTransactionsInput),
        if (transaction_type != _undefined && transaction_type != null)
          'transaction_type': (transaction_type
              as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsCreateNestedManyWithoutTransactionInput?),
      }));
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city {
    final local$city = _instance.city;
    return CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
        local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
        local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateWithoutSellerInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateWithoutSellerInput(this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      _res;
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city =>
      CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(_res);
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
              _res);
}

class Input$TransactionsCreateOrConnectWithoutSellerInput {
  factory Input$TransactionsCreateOrConnectWithoutSellerInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsCreateWithoutSellerInput create,
  }) =>
      Input$TransactionsCreateOrConnectWithoutSellerInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionsCreateOrConnectWithoutSellerInput._(this._$data);

  factory Input$TransactionsCreateOrConnectWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutSellerInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsCreateOrConnectWithoutSellerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsCreateWithoutSellerInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutSellerInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
          Input$TransactionsCreateOrConnectWithoutSellerInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateOrConnectWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput(
    Input$TransactionsCreateOrConnectWithoutSellerInput instance,
    TRes Function(Input$TransactionsCreateOrConnectWithoutSellerInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutSellerInput;

  factory CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutSellerInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutSellerInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutSellerInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateOrConnectWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsCreateOrConnectWithoutSellerInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsCreateOrConnectWithoutSellerInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutSellerInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutSellerInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutSellerInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutSellerInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutSellerInput.stub(_res);
}

class Input$SellersUpdateManyMutationInput {
  factory Input$SellersUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      Input$SellersUpdateManyMutationInput._({
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
      });

  Input$SellersUpdateManyMutationInput._(this._$data);

  factory Input$SellersUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_name as Map<String, dynamic>));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_phone as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    return Input$SellersUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get seller_name =>
      (_$data['seller_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get seller_phone =>
      (_$data['seller_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] = l$seller_name?.toJson();
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] = l$seller_phone?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersUpdateManyMutationInput<
          Input$SellersUpdateManyMutationInput>
      get copyWith => CopyWith$Input$SellersUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    return Object.hashAll([
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$SellersUpdateManyMutationInput(
    Input$SellersUpdateManyMutationInput instance,
    TRes Function(Input$SellersUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$SellersUpdateManyMutationInput;

  factory CopyWith$Input$SellersUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
}

class _CopyWithImpl$Input$SellersUpdateManyMutationInput<TRes>
    implements CopyWith$Input$SellersUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$SellersUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$SellersUpdateManyMutationInput _instance;

  final TRes Function(Input$SellersUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
  }) =>
      _then(Input$SellersUpdateManyMutationInput._({
        ..._instance._$data,
        if (seller_name != _undefined)
          'seller_name':
              (seller_name as Input$StringFieldUpdateOperationsInput?),
        if (seller_phone != _undefined)
          'seller_phone':
              (seller_phone as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name {
    final local$seller_name = _instance.seller_name;
    return local$seller_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_name, (e) => call(seller_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone {
    final local$seller_phone = _instance.seller_phone;
    return local$seller_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_phone, (e) => call(seller_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }
}

class _CopyWithStubImpl$Input$SellersUpdateManyMutationInput<TRes>
    implements CopyWith$Input$SellersUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$SellersUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$SellersUpdateInput {
  factory Input$SellersUpdateInput({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$TransactionsUpdateManyWithoutSellerNestedInput? Transactions,
  }) =>
      Input$SellersUpdateInput._({
        if (seller_name != null) r'seller_name': seller_name,
        if (seller_phone != null) r'seller_phone': seller_phone,
        if (picture != null) r'picture': picture,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$SellersUpdateInput._(this._$data);

  factory Input$SellersUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('seller_name')) {
      final l$seller_name = data['seller_name'];
      result$data['seller_name'] = l$seller_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_name as Map<String, dynamic>));
    }
    if (data.containsKey('seller_phone')) {
      final l$seller_phone = data['seller_phone'];
      result$data['seller_phone'] = l$seller_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$seller_phone as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsUpdateManyWithoutSellerNestedInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$SellersUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get seller_name =>
      (_$data['seller_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get seller_phone =>
      (_$data['seller_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Input$TransactionsUpdateManyWithoutSellerNestedInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsUpdateManyWithoutSellerNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('seller_name')) {
      final l$seller_name = seller_name;
      result$data['seller_name'] = l$seller_name?.toJson();
    }
    if (_$data.containsKey('seller_phone')) {
      final l$seller_phone = seller_phone;
      result$data['seller_phone'] = l$seller_phone?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SellersUpdateInput<Input$SellersUpdateInput> get copyWith =>
      CopyWith$Input$SellersUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SellersUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$seller_name = seller_name;
    final lOther$seller_name = other.seller_name;
    if (_$data.containsKey('seller_name') !=
        other._$data.containsKey('seller_name')) {
      return false;
    }
    if (l$seller_name != lOther$seller_name) {
      return false;
    }
    final l$seller_phone = seller_phone;
    final lOther$seller_phone = other.seller_phone;
    if (_$data.containsKey('seller_phone') !=
        other._$data.containsKey('seller_phone')) {
      return false;
    }
    if (l$seller_phone != lOther$seller_phone) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$seller_name = seller_name;
    final l$seller_phone = seller_phone;
    final l$picture = picture;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('seller_name') ? l$seller_name : const {},
      _$data.containsKey('seller_phone') ? l$seller_phone : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$SellersUpdateInput<TRes> {
  factory CopyWith$Input$SellersUpdateInput(
    Input$SellersUpdateInput instance,
    TRes Function(Input$SellersUpdateInput) then,
  ) = _CopyWithImpl$Input$SellersUpdateInput;

  factory CopyWith$Input$SellersUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SellersUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$TransactionsUpdateManyWithoutSellerNestedInput? Transactions,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
  CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$SellersUpdateInput<TRes>
    implements CopyWith$Input$SellersUpdateInput<TRes> {
  _CopyWithImpl$Input$SellersUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SellersUpdateInput _instance;

  final TRes Function(Input$SellersUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? seller_name = _undefined,
    Object? seller_phone = _undefined,
    Object? picture = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$SellersUpdateInput._({
        ..._instance._$data,
        if (seller_name != _undefined)
          'seller_name':
              (seller_name as Input$StringFieldUpdateOperationsInput?),
        if (seller_phone != _undefined)
          'seller_phone':
              (seller_phone as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsUpdateManyWithoutSellerNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name {
    final local$seller_name = _instance.seller_name;
    return local$seller_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_name, (e) => call(seller_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone {
    final local$seller_phone = _instance.seller_phone;
    return local$seller_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$seller_phone, (e) => call(seller_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$SellersUpdateInput<TRes>
    implements CopyWith$Input$SellersUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SellersUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? seller_name,
    Input$StringFieldUpdateOperationsInput? seller_phone,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$TransactionsUpdateManyWithoutSellerNestedInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get seller_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateManyWithoutSellerNestedInput {
  factory Input$TransactionsUpdateManyWithoutSellerNestedInput({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      Input$TransactionsUpdateManyWithoutSellerNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$TransactionsUpdateManyWithoutSellerNestedInput._(this._$data);

  factory Input$TransactionsUpdateManyWithoutSellerNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutSellerInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutSellerInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) => Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) => Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateManyWithWhereWithoutSellerInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsUpdateManyWithoutSellerNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutSellerInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutSellerInput>?);
  List<Input$TransactionsCreateOrConnectWithoutSellerInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutSellerInput>?);
  List<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? get upsert =>
      (_$data['upsert']
          as List<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>?);
  List<Input$TransactionsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? get update =>
      (_$data['update']
          as List<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>?);
  List<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>?);
  List<Input$TransactionsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$TransactionsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<
          Input$TransactionsUpdateManyWithoutSellerNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithoutSellerNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput(
    Input$TransactionsUpdateManyWithoutSellerNestedInput instance,
    TRes Function(Input$TransactionsUpdateManyWithoutSellerNestedInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput;

  factory CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput;

  TRes call({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutSellerInput<
                      Input$TransactionsCreateWithoutSellerInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
                      Input$TransactionsCreateOrConnectWithoutSellerInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
                      Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
                      Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
                      Input$TransactionsUpdateManyWithWhereWithoutSellerInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithoutSellerNestedInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithoutSellerNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithoutSellerNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$TransactionsCreateWithoutSellerInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutSellerInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$TransactionsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$TransactionsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$TransactionsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$TransactionsUpdateManyWithWhereWithoutSellerInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$TransactionsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutSellerInput<
                          Input$TransactionsCreateWithoutSellerInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutSellerInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput<
                          Input$TransactionsCreateOrConnectWithoutSellerInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutSellerInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
                          Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
                          Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
                          Input$TransactionsUpdateManyWithWhereWithoutSellerInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutSellerNestedInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutSellerNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutSellerInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutSellerInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutSellerInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput {
  factory Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutSellerInput update,
    required Input$TransactionsCreateWithoutSellerInput create,
  }) =>
      Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput._(this._$data);

  factory Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$TransactionsUpdateWithoutSellerInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutSellerInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutSellerInput get update =>
      (_$data['update'] as Input$TransactionsUpdateWithoutSellerInput);
  Input$TransactionsCreateWithoutSellerInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutSellerInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
          Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput(
    Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput instance,
    TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput;

  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutSellerInput? update,
    Input$TransactionsCreateWithoutSellerInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get update;
  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$TransactionsUpdateWithoutSellerInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutSellerInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionsUpdateWithoutSellerInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutSellerInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutSellerInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutSellerInput? update,
    Input$TransactionsCreateWithoutSellerInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get update =>
      CopyWith$Input$TransactionsUpdateWithoutSellerInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutSellerInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutSellerInput.stub(_res);
}

class Input$TransactionsUpdateWithoutSellerInput {
  factory Input$TransactionsUpdateWithoutSellerInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      Input$TransactionsUpdateWithoutSellerInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (city != null) r'city': city,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsUpdateWithoutSellerInput._(this._$data);

  factory Input$TransactionsUpdateWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateWithoutSellerInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? get city =>
      (_$data['city']
          as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
      get status => (_$data['status']
          as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$PayementsUpdateManyWithoutTransactionNestedInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsUpdateManyWithoutTransactionNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithoutSellerInput<
          Input$TransactionsUpdateWithoutSellerInput>
      get copyWith => CopyWith$Input$TransactionsUpdateWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateWithoutSellerInput(
    Input$TransactionsUpdateWithoutSellerInput instance,
    TRes Function(Input$TransactionsUpdateWithoutSellerInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithoutSellerInput;

  factory CopyWith$Input$TransactionsUpdateWithoutSellerInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithoutSellerInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city;
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type;
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status;
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsUpdateWithoutSellerInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsUpdateWithoutSellerInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithoutSellerInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (city != _undefined)
          'city': (city
              as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsUpdateManyWithoutTransactionNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithoutSellerInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithoutSellerInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get status =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput {
  factory Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutSellerInput data,
  }) =>
      Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput._(this._$data);

  factory Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateWithoutSellerInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutSellerInput get data =>
      (_$data['data'] as Input$TransactionsUpdateWithoutSellerInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
          Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput(
    Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput instance,
    TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput;

  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutSellerInput? data,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateWithoutSellerInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateWithoutSellerInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutSellerInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutSellerInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutSellerInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateWithoutSellerInput.stub(_res);
}

class Input$TransactionsUpdateManyWithWhereWithoutSellerInput {
  factory Input$TransactionsUpdateManyWithWhereWithoutSellerInput({
    required Input$TransactionsScalarWhereInput where,
    required Input$TransactionsUpdateManyMutationInput data,
  }) =>
      Input$TransactionsUpdateManyWithWhereWithoutSellerInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateManyWithWhereWithoutSellerInput._(this._$data);

  factory Input$TransactionsUpdateManyWithWhereWithoutSellerInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateManyWithWhereWithoutSellerInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsScalarWhereInput get where =>
      (_$data['where'] as Input$TransactionsScalarWhereInput);
  Input$TransactionsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$TransactionsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
          Input$TransactionsUpdateManyWithWhereWithoutSellerInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithWhereWithoutSellerInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput(
    Input$TransactionsUpdateManyWithWhereWithoutSellerInput instance,
    TRes Function(Input$TransactionsUpdateManyWithWhereWithoutSellerInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput;

  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput;

  TRes call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  });
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithWhereWithoutSellerInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithWhereWithoutSellerInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithWhereWithoutSellerInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateManyMutationInput),
      }));
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutSellerInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutSellerInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where =>
      CopyWith$Input$TransactionsScalarWhereInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateManyMutationInput.stub(_res);
}

class Input$SizesCreateInput {
  factory Input$SizesCreateInput({
    required int id,
    required String size,
    Input$ProductModelCreateNestedManyWithoutSizeInput? ProductModel,
  }) =>
      Input$SizesCreateInput._({
        r'id': id,
        r'size': size,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$SizesCreateInput._(this._$data);

  factory Input$SizesCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$id = data['id'];
    result$data['id'] = (l$id as int);
    final l$size = data['size'];
    result$data['size'] = (l$size as String);
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelCreateNestedManyWithoutSizeInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$SizesCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get id => (_$data['id'] as int);
  String get size => (_$data['size'] as String);
  Input$ProductModelCreateNestedManyWithoutSizeInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelCreateNestedManyWithoutSizeInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$id = id;
    result$data['id'] = l$id;
    final l$size = size;
    result$data['size'] = l$size;
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesCreateInput<Input$SizesCreateInput> get copyWith =>
      CopyWith$Input$SizesCreateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (l$size != lOther$size) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      l$id,
      l$size,
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesCreateInput<TRes> {
  factory CopyWith$Input$SizesCreateInput(
    Input$SizesCreateInput instance,
    TRes Function(Input$SizesCreateInput) then,
  ) = _CopyWithImpl$Input$SizesCreateInput;

  factory CopyWith$Input$SizesCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesCreateInput;

  TRes call({
    int? id,
    String? size,
    Input$ProductModelCreateNestedManyWithoutSizeInput? ProductModel,
  });
  CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$SizesCreateInput<TRes>
    implements CopyWith$Input$SizesCreateInput<TRes> {
  _CopyWithImpl$Input$SizesCreateInput(
    this._instance,
    this._then,
  );

  final Input$SizesCreateInput _instance;

  final TRes Function(Input$SizesCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$SizesCreateInput._({
        ..._instance._$data,
        if (id != _undefined && id != null) 'id': (id as int),
        if (size != _undefined && size != null) 'size': (size as String),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelCreateNestedManyWithoutSizeInput?),
      }));
  CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$SizesCreateInput<TRes>
    implements CopyWith$Input$SizesCreateInput<TRes> {
  _CopyWithStubImpl$Input$SizesCreateInput(this._res);

  TRes _res;

  call({
    int? id,
    String? size,
    Input$ProductModelCreateNestedManyWithoutSizeInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput.stub(
              _res);
}

class Input$ProductModelCreateNestedManyWithoutSizeInput {
  factory Input$ProductModelCreateNestedManyWithoutSizeInput({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      Input$ProductModelCreateNestedManyWithoutSizeInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductModelCreateNestedManyWithoutSizeInput._(this._$data);

  factory Input$ProductModelCreateNestedManyWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutSizeInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutSizeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelCreateNestedManyWithoutSizeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutSizeInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutSizeInput>?);
  List<Input$ProductModelCreateOrConnectWithoutSizeInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutSizeInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<
          Input$ProductModelCreateNestedManyWithoutSizeInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateNestedManyWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput(
    Input$ProductModelCreateNestedManyWithoutSizeInput instance,
    TRes Function(Input$ProductModelCreateNestedManyWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutSizeInput;

  factory CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutSizeInput;

  TRes call({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutSizeInput<
                      Input$ProductModelCreateWithoutSizeInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
                      Input$ProductModelCreateOrConnectWithoutSizeInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateNestedManyWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateNestedManyWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelCreateNestedManyWithoutSizeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductModelCreateNestedManyWithoutSizeInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$ProductModelCreateWithoutSizeInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutSizeInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutSizeInput<
                          Input$ProductModelCreateWithoutSizeInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutSizeInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
                          Input$ProductModelCreateOrConnectWithoutSizeInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateNestedManyWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateNestedManyWithoutSizeInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$ProductModelCreateWithoutSizeInput {
  factory Input$ProductModelCreateWithoutSizeInput({
    required int quantity,
    required Input$ProductsCreateNestedOneWithoutProductModelInput product,
    required Input$ColorsCreateNestedOneWithoutProductModelInput color,
  }) =>
      Input$ProductModelCreateWithoutSizeInput._({
        r'quantity': quantity,
        r'product': product,
        r'color': color,
      });

  Input$ProductModelCreateWithoutSizeInput._(this._$data);

  factory Input$ProductModelCreateWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$product = data['product'];
    result$data['product'] =
        Input$ProductsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$product as Map<String, dynamic>));
    final l$color = data['color'];
    result$data['color'] =
        Input$ColorsCreateNestedOneWithoutProductModelInput.fromJson(
            (l$color as Map<String, dynamic>));
    return Input$ProductModelCreateWithoutSizeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  Input$ProductsCreateNestedOneWithoutProductModelInput get product =>
      (_$data['product']
          as Input$ProductsCreateNestedOneWithoutProductModelInput);
  Input$ColorsCreateNestedOneWithoutProductModelInput get color =>
      (_$data['color'] as Input$ColorsCreateNestedOneWithoutProductModelInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$product = product;
    result$data['product'] = l$product.toJson();
    final l$color = color;
    result$data['color'] = l$color.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateWithoutSizeInput<
          Input$ProductModelCreateWithoutSizeInput>
      get copyWith => CopyWith$Input$ProductModelCreateWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$color = color;
    return Object.hashAll([
      l$quantity,
      l$product,
      l$color,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> {
  factory CopyWith$Input$ProductModelCreateWithoutSizeInput(
    Input$ProductModelCreateWithoutSizeInput instance,
    TRes Function(Input$ProductModelCreateWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateWithoutSizeInput;

  factory CopyWith$Input$ProductModelCreateWithoutSizeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateWithoutSizeInput;

  TRes call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  });
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product;
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color;
}

class _CopyWithImpl$Input$ProductModelCreateWithoutSizeInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelCreateWithoutSizeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelCreateWithoutSizeInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (product != _undefined && product != null)
          'product': (product
              as Input$ProductsCreateNestedOneWithoutProductModelInput),
        if (color != _undefined && color != null)
          'color':
              (color as Input$ColorsCreateNestedOneWithoutProductModelInput),
      }));
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product {
    final local$product = _instance.product;
    return CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput(
        local$product, (e) => call(product: e));
  }

  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes> get color {
    final local$color = _instance.color;
    return CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput(
        local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateWithoutSizeInput<TRes>
    implements CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateWithoutSizeInput(this._res);

  TRes _res;

  call({
    int? quantity,
    Input$ProductsCreateNestedOneWithoutProductModelInput? product,
    Input$ColorsCreateNestedOneWithoutProductModelInput? color,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput<TRes>
      get product =>
          CopyWith$Input$ProductsCreateNestedOneWithoutProductModelInput.stub(
              _res);
  CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput<TRes>
      get color =>
          CopyWith$Input$ColorsCreateNestedOneWithoutProductModelInput.stub(
              _res);
}

class Input$ProductModelCreateOrConnectWithoutSizeInput {
  factory Input$ProductModelCreateOrConnectWithoutSizeInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelCreateWithoutSizeInput create,
  }) =>
      Input$ProductModelCreateOrConnectWithoutSizeInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductModelCreateOrConnectWithoutSizeInput._(this._$data);

  factory Input$ProductModelCreateOrConnectWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductModelCreateWithoutSizeInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductModelCreateOrConnectWithoutSizeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelCreateWithoutSizeInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutSizeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
          Input$ProductModelCreateOrConnectWithoutSizeInput>
      get copyWith =>
          CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelCreateOrConnectWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
    TRes> {
  factory CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput(
    Input$ProductModelCreateOrConnectWithoutSizeInput instance,
    TRes Function(Input$ProductModelCreateOrConnectWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutSizeInput;

  factory CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutSizeInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutSizeInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutSizeInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelCreateOrConnectWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelCreateOrConnectWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelCreateOrConnectWithoutSizeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelCreateOrConnectWithoutSizeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutSizeInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutSizeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutSizeInput<TRes>
    implements
        CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelCreateOrConnectWithoutSizeInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelCreateWithoutSizeInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutSizeInput.stub(_res);
}

class Input$SizesUpdateManyMutationInput {
  factory Input$SizesUpdateManyMutationInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  }) =>
      Input$SizesUpdateManyMutationInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
      });

  Input$SizesUpdateManyMutationInput._(this._$data);

  factory Input$SizesUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    return Input$SizesUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get size =>
      (_$data['size'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesUpdateManyMutationInput<
          Input$SizesUpdateManyMutationInput>
      get copyWith => CopyWith$Input$SizesUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$SizesUpdateManyMutationInput(
    Input$SizesUpdateManyMutationInput instance,
    TRes Function(Input$SizesUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$SizesUpdateManyMutationInput;

  factory CopyWith$Input$SizesUpdateManyMutationInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesUpdateManyMutationInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size;
}

class _CopyWithImpl$Input$SizesUpdateManyMutationInput<TRes>
    implements CopyWith$Input$SizesUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$SizesUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$SizesUpdateManyMutationInput _instance;

  final TRes Function(Input$SizesUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
  }) =>
      _then(Input$SizesUpdateManyMutationInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (size != _undefined)
          'size': (size as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$size, (e) => call(size: e));
  }
}

class _CopyWithStubImpl$Input$SizesUpdateManyMutationInput<TRes>
    implements CopyWith$Input$SizesUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$SizesUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$SizesUpdateInput {
  factory Input$SizesUpdateInput({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
    Input$ProductModelUpdateManyWithoutSizeNestedInput? ProductModel,
  }) =>
      Input$SizesUpdateInput._({
        if (id != null) r'id': id,
        if (size != null) r'size': size,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$SizesUpdateInput._(this._$data);

  factory Input$SizesUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('id')) {
      final l$id = data['id'];
      result$data['id'] = l$id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$id as Map<String, dynamic>));
    }
    if (data.containsKey('size')) {
      final l$size = data['size'];
      result$data['size'] = l$size == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$size as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelUpdateManyWithoutSizeNestedInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$SizesUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get id =>
      (_$data['id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get size =>
      (_$data['size'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductModelUpdateManyWithoutSizeNestedInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelUpdateManyWithoutSizeNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('id')) {
      final l$id = id;
      result$data['id'] = l$id?.toJson();
    }
    if (_$data.containsKey('size')) {
      final l$size = size;
      result$data['size'] = l$size?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$SizesUpdateInput<Input$SizesUpdateInput> get copyWith =>
      CopyWith$Input$SizesUpdateInput(
        this,
        (i) => i,
      );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$SizesUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$id = id;
    final lOther$id = other.id;
    if (_$data.containsKey('id') != other._$data.containsKey('id')) {
      return false;
    }
    if (l$id != lOther$id) {
      return false;
    }
    final l$size = size;
    final lOther$size = other.size;
    if (_$data.containsKey('size') != other._$data.containsKey('size')) {
      return false;
    }
    if (l$size != lOther$size) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$id = id;
    final l$size = size;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('id') ? l$id : const {},
      _$data.containsKey('size') ? l$size : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$SizesUpdateInput<TRes> {
  factory CopyWith$Input$SizesUpdateInput(
    Input$SizesUpdateInput instance,
    TRes Function(Input$SizesUpdateInput) then,
  ) = _CopyWithImpl$Input$SizesUpdateInput;

  factory CopyWith$Input$SizesUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$SizesUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
    Input$ProductModelUpdateManyWithoutSizeNestedInput? ProductModel,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size;
  CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$SizesUpdateInput<TRes>
    implements CopyWith$Input$SizesUpdateInput<TRes> {
  _CopyWithImpl$Input$SizesUpdateInput(
    this._instance,
    this._then,
  );

  final Input$SizesUpdateInput _instance;

  final TRes Function(Input$SizesUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? id = _undefined,
    Object? size = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$SizesUpdateInput._({
        ..._instance._$data,
        if (id != _undefined)
          'id': (id as Input$IntFieldUpdateOperationsInput?),
        if (size != _undefined)
          'size': (size as Input$StringFieldUpdateOperationsInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelUpdateManyWithoutSizeNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id {
    final local$id = _instance.id;
    return local$id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$id, (e) => call(id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size {
    final local$size = _instance.size;
    return local$size == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$size, (e) => call(size: e));
  }

  CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$SizesUpdateInput<TRes>
    implements CopyWith$Input$SizesUpdateInput<TRes> {
  _CopyWithStubImpl$Input$SizesUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? id,
    Input$StringFieldUpdateOperationsInput? size,
    Input$ProductModelUpdateManyWithoutSizeNestedInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get size =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput.stub(
              _res);
}

class Input$ProductModelUpdateManyWithoutSizeNestedInput {
  factory Input$ProductModelUpdateManyWithoutSizeNestedInput({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      Input$ProductModelUpdateManyWithoutSizeNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$ProductModelUpdateManyWithoutSizeNestedInput._(this._$data);

  factory Input$ProductModelUpdateManyWithoutSizeNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$ProductModelCreateWithoutSizeInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelCreateOrConnectWithoutSizeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$ProductModelWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$ProductModelUpdateManyWithWhereWithoutSizeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$ProductModelScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$ProductModelUpdateManyWithoutSizeNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$ProductModelCreateWithoutSizeInput>? get create =>
      (_$data['create'] as List<Input$ProductModelCreateWithoutSizeInput>?);
  List<Input$ProductModelCreateOrConnectWithoutSizeInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$ProductModelCreateOrConnectWithoutSizeInput>?);
  List<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? get upsert =>
      (_$data['upsert']
          as List<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>?);
  List<Input$ProductModelWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$ProductModelWhereUniqueInput>?);
  List<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? get update =>
      (_$data['update']
          as List<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>?);
  List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? get updateMany =>
      (_$data['updateMany']
          as List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>?);
  List<Input$ProductModelScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$ProductModelScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<
          Input$ProductModelUpdateManyWithoutSizeNestedInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithoutSizeNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput(
    Input$ProductModelUpdateManyWithoutSizeNestedInput instance,
    TRes Function(Input$ProductModelUpdateManyWithoutSizeNestedInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput;

  factory CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput;

  TRes call({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$ProductModelCreateWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateWithoutSizeInput<
                      Input$ProductModelCreateWithoutSizeInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$ProductModelCreateOrConnectWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
                      Input$ProductModelCreateOrConnectWithoutSizeInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
                      Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$ProductModelWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelWhereUniqueInput<
                      Input$ProductModelWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
                      Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<
                      Input$ProductModelUpdateManyWithWhereWithoutSizeInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$ProductModelScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$ProductModelScalarWhereInput<
                      Input$ProductModelScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithoutSizeNestedInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithoutSizeNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithoutSizeNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create as List<Input$ProductModelCreateWithoutSizeInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$ProductModelCreateOrConnectWithoutSizeInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$ProductModelWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$ProductModelWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$ProductModelWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$ProductModelWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany
              as List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$ProductModelScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$ProductModelCreateWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateWithoutSizeInput<
                          Input$ProductModelCreateWithoutSizeInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$ProductModelCreateWithoutSizeInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$ProductModelCreateOrConnectWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput<
                          Input$ProductModelCreateOrConnectWithoutSizeInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map(
              (e) => CopyWith$Input$ProductModelCreateOrConnectWithoutSizeInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes upsert(
          Iterable<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
                          Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$ProductModelWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelWhereUniqueInput<
                          Input$ProductModelWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$ProductModelWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
                          Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<
                          Input$ProductModelUpdateManyWithWhereWithoutSizeInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$ProductModelScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$ProductModelScalarWhereInput<
                          Input$ProductModelScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$ProductModelScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithoutSizeNestedInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithoutSizeNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$ProductModelCreateWithoutSizeInput>? create,
    List<Input$ProductModelCreateOrConnectWithoutSizeInput>? connectOrCreate,
    List<Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>? upsert,
    List<Input$ProductModelWhereUniqueInput>? $set,
    List<Input$ProductModelWhereUniqueInput>? disconnect,
    List<Input$ProductModelWhereUniqueInput>? delete,
    List<Input$ProductModelWhereUniqueInput>? connect,
    List<Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>? update,
    List<Input$ProductModelUpdateManyWithWhereWithoutSizeInput>? updateMany,
    List<Input$ProductModelScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput {
  factory Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutSizeInput update,
    required Input$ProductModelCreateWithoutSizeInput create,
  }) =>
      Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput._(this._$data);

  factory Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$ProductModelUpdateWithoutSizeInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$ProductModelCreateWithoutSizeInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutSizeInput get update =>
      (_$data['update'] as Input$ProductModelUpdateWithoutSizeInput);
  Input$ProductModelCreateWithoutSizeInput get create =>
      (_$data['create'] as Input$ProductModelCreateWithoutSizeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
          Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput(
    Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput instance,
    TRes Function(Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput;

  factory CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutSizeInput? update,
    Input$ProductModelCreateWithoutSizeInput? create,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get update;
  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$ProductModelUpdateWithoutSizeInput),
        if (create != _undefined && create != null)
          'create': (create as Input$ProductModelCreateWithoutSizeInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductModelUpdateWithoutSizeInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductModelCreateWithoutSizeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpsertWithWhereUniqueWithoutSizeInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutSizeInput? update,
    Input$ProductModelCreateWithoutSizeInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get update =>
      CopyWith$Input$ProductModelUpdateWithoutSizeInput.stub(_res);
  CopyWith$Input$ProductModelCreateWithoutSizeInput<TRes> get create =>
      CopyWith$Input$ProductModelCreateWithoutSizeInput.stub(_res);
}

class Input$ProductModelUpdateWithoutSizeInput {
  factory Input$ProductModelUpdateWithoutSizeInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      Input$ProductModelUpdateWithoutSizeInput._({
        if (quantity != null) r'quantity': quantity,
        if (product != null) r'product': product,
        if (color != null) r'color': color,
      });

  Input$ProductModelUpdateWithoutSizeInput._(this._$data);

  factory Input$ProductModelUpdateWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$product as Map<String, dynamic>));
    }
    if (data.containsKey('color')) {
      final l$color = data['color'];
      result$data['color'] = l$color == null
          ? null
          : Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .fromJson((l$color as Map<String, dynamic>));
    }
    return Input$ProductModelUpdateWithoutSizeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? get product =>
      (_$data['product']
          as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?);
  Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? get color =>
      (_$data['color']
          as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    if (_$data.containsKey('color')) {
      final l$color = color;
      result$data['color'] = l$color?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithoutSizeInput<
          Input$ProductModelUpdateWithoutSizeInput>
      get copyWith => CopyWith$Input$ProductModelUpdateWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    final l$color = color;
    final lOther$color = other.color;
    if (_$data.containsKey('color') != other._$data.containsKey('color')) {
      return false;
    }
    if (l$color != lOther$color) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$product = product;
    final l$color = color;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('product') ? l$product : const {},
      _$data.containsKey('color') ? l$color : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> {
  factory CopyWith$Input$ProductModelUpdateWithoutSizeInput(
    Input$ProductModelUpdateWithoutSizeInput instance,
    TRes Function(Input$ProductModelUpdateWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithoutSizeInput;

  factory CopyWith$Input$ProductModelUpdateWithoutSizeInput.stub(TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithoutSizeInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product;
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color;
}

class _CopyWithImpl$Input$ProductModelUpdateWithoutSizeInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelUpdateWithoutSizeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? product = _undefined,
    Object? color = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithoutSizeInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (product != _undefined)
          'product': (product
              as Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput?),
        if (color != _undefined)
          'color': (color
              as Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput(
            local$product, (e) => call(product: e));
  }

  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color {
    final local$color = _instance.color;
    return local$color == null
        ? CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput(
            local$color, (e) => call(color: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithoutSizeInput<TRes>
    implements CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithoutSizeInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput? product,
    Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput? color,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get product =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
  CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput<TRes>
      get color =>
          CopyWith$Input$ColorsUpdateOneRequiredWithoutProductModelNestedInput
              .stub(_res);
}

class Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput {
  factory Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput({
    required Input$ProductModelWhereUniqueInput where,
    required Input$ProductModelUpdateWithoutSizeInput data,
  }) =>
      Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput._(this._$data);

  factory Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateWithoutSizeInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductModelWhereUniqueInput);
  Input$ProductModelUpdateWithoutSizeInput get data =>
      (_$data['data'] as Input$ProductModelUpdateWithoutSizeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
          Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput(
    Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput instance,
    TRes Function(Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput;

  factory CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput;

  TRes call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutSizeInput? data,
  });
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateWithoutSizeInput),
      }));
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateWithoutSizeInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateWithWhereUniqueWithoutSizeInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelWhereUniqueInput? where,
    Input$ProductModelUpdateWithoutSizeInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductModelWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductModelUpdateWithoutSizeInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateWithoutSizeInput.stub(_res);
}

class Input$ProductModelUpdateManyWithWhereWithoutSizeInput {
  factory Input$ProductModelUpdateManyWithWhereWithoutSizeInput({
    required Input$ProductModelScalarWhereInput where,
    required Input$ProductModelUpdateManyMutationInput data,
  }) =>
      Input$ProductModelUpdateManyWithWhereWithoutSizeInput._({
        r'where': where,
        r'data': data,
      });

  Input$ProductModelUpdateManyWithWhereWithoutSizeInput._(this._$data);

  factory Input$ProductModelUpdateManyWithWhereWithoutSizeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductModelScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$ProductModelUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$ProductModelUpdateManyWithWhereWithoutSizeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductModelScalarWhereInput get where =>
      (_$data['where'] as Input$ProductModelScalarWhereInput);
  Input$ProductModelUpdateManyMutationInput get data =>
      (_$data['data'] as Input$ProductModelUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<
          Input$ProductModelUpdateManyWithWhereWithoutSizeInput>
      get copyWith =>
          CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductModelUpdateManyWithWhereWithoutSizeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<
    TRes> {
  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput(
    Input$ProductModelUpdateManyWithWhereWithoutSizeInput instance,
    TRes Function(Input$ProductModelUpdateManyWithWhereWithoutSizeInput) then,
  ) = _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput;

  factory CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput;

  TRes call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  });
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where;
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<TRes> {
  _CopyWithImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput(
    this._instance,
    this._then,
  );

  final Input$ProductModelUpdateManyWithWhereWithoutSizeInput _instance;

  final TRes Function(Input$ProductModelUpdateManyWithWhereWithoutSizeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$ProductModelUpdateManyWithWhereWithoutSizeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductModelScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$ProductModelUpdateManyMutationInput),
      }));
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductModelScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$ProductModelUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<
        TRes>
    implements
        CopyWith$Input$ProductModelUpdateManyWithWhereWithoutSizeInput<TRes> {
  _CopyWithStubImpl$Input$ProductModelUpdateManyWithWhereWithoutSizeInput(
      this._res);

  TRes _res;

  call({
    Input$ProductModelScalarWhereInput? where,
    Input$ProductModelUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$ProductModelScalarWhereInput<TRes> get where =>
      CopyWith$Input$ProductModelScalarWhereInput.stub(_res);
  CopyWith$Input$ProductModelUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$ProductModelUpdateManyMutationInput.stub(_res);
}

class Input$TransactionProductCreateInput {
  factory Input$TransactionProductCreateInput({
    required int quantity,
    required double price,
    required String product_name,
    required Input$ProductsCreateNestedOneWithoutTransactionProductInput
        product,
  }) =>
      Input$TransactionProductCreateInput._({
        r'quantity': quantity,
        r'price': price,
        r'product_name': product_name,
        r'product': product,
      });

  Input$TransactionProductCreateInput._(this._$data);

  factory Input$TransactionProductCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$price = data['price'];
    result$data['price'] = (l$price as num).toDouble();
    final l$product_name = data['product_name'];
    result$data['product_name'] = (l$product_name as String);
    final l$product = data['product'];
    result$data['product'] =
        Input$ProductsCreateNestedOneWithoutTransactionProductInput.fromJson(
            (l$product as Map<String, dynamic>));
    return Input$TransactionProductCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get quantity => (_$data['quantity'] as int);
  double get price => (_$data['price'] as double);
  String get product_name => (_$data['product_name'] as String);
  Input$ProductsCreateNestedOneWithoutTransactionProductInput get product =>
      (_$data['product']
          as Input$ProductsCreateNestedOneWithoutTransactionProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$price = price;
    result$data['price'] = l$price;
    final l$product_name = product_name;
    result$data['product_name'] = l$product_name;
    final l$product = product;
    result$data['product'] = l$product.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionProductCreateInput<
          Input$TransactionProductCreateInput>
      get copyWith => CopyWith$Input$TransactionProductCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (l$product_name != lOther$product_name) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (l$product != lOther$product) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    final l$product = product;
    return Object.hashAll([
      l$quantity,
      l$price,
      l$product_name,
      l$product,
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductCreateInput<TRes> {
  factory CopyWith$Input$TransactionProductCreateInput(
    Input$TransactionProductCreateInput instance,
    TRes Function(Input$TransactionProductCreateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductCreateInput;

  factory CopyWith$Input$TransactionProductCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductCreateInput;

  TRes call({
    int? quantity,
    double? price,
    String? product_name,
    Input$ProductsCreateNestedOneWithoutTransactionProductInput? product,
  });
  CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<TRes>
      get product;
}

class _CopyWithImpl$Input$TransactionProductCreateInput<TRes>
    implements CopyWith$Input$TransactionProductCreateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductCreateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductCreateInput _instance;

  final TRes Function(Input$TransactionProductCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
    Object? product = _undefined,
  }) =>
      _then(Input$TransactionProductCreateInput._({
        ..._instance._$data,
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (price != _undefined && price != null) 'price': (price as double),
        if (product_name != _undefined && product_name != null)
          'product_name': (product_name as String),
        if (product != _undefined && product != null)
          'product': (product
              as Input$ProductsCreateNestedOneWithoutTransactionProductInput),
      }));
  CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<TRes>
      get product {
    final local$product = _instance.product;
    return CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput(
        local$product, (e) => call(product: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductCreateInput<TRes>
    implements CopyWith$Input$TransactionProductCreateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductCreateInput(this._res);

  TRes _res;

  call({
    int? quantity,
    double? price,
    String? product_name,
    Input$ProductsCreateNestedOneWithoutTransactionProductInput? product,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<TRes>
      get product =>
          CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput
              .stub(_res);
}

class Input$ProductsCreateNestedOneWithoutTransactionProductInput {
  factory Input$ProductsCreateNestedOneWithoutTransactionProductInput({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  }) =>
      Input$ProductsCreateNestedOneWithoutTransactionProductInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$ProductsCreateNestedOneWithoutTransactionProductInput._(this._$data);

  factory Input$ProductsCreateNestedOneWithoutTransactionProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductsCreateWithoutTransactionProductInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductsCreateOrConnectWithoutTransactionProductInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    return Input$ProductsCreateNestedOneWithoutTransactionProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsCreateWithoutTransactionProductInput? get create =>
      (_$data['create'] as Input$ProductsCreateWithoutTransactionProductInput?);
  Input$ProductsCreateOrConnectWithoutTransactionProductInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$ProductsCreateOrConnectWithoutTransactionProductInput?);
  Input$ProductsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductsWhereUniqueInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
          Input$ProductsCreateNestedOneWithoutTransactionProductInput>
      get copyWith =>
          CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductsCreateNestedOneWithoutTransactionProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('connect') ? l$connect : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
    TRes> {
  factory CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput(
    Input$ProductsCreateNestedOneWithoutTransactionProductInput instance,
    TRes Function(Input$ProductsCreateNestedOneWithoutTransactionProductInput)
        then,
  ) = _CopyWithImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput;

  factory CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput;

  TRes call({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  });
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create;
  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect;
}

class _CopyWithImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
            TRes> {
  _CopyWithImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateNestedOneWithoutTransactionProductInput _instance;

  final TRes Function(
      Input$ProductsCreateNestedOneWithoutTransactionProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$ProductsCreateNestedOneWithoutTransactionProductInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as Input$ProductsCreateWithoutTransactionProductInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductsCreateOrConnectWithoutTransactionProductInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductsWhereUniqueInput?),
      }));
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateNestedOneWithoutTransactionProductInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductsCreateNestedOneWithoutTransactionProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsWhereUniqueInput? connect,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes>
      get create =>
          CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
              _res);
  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput
              .stub(_res);
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
}

class Input$ProductsCreateWithoutTransactionProductInput {
  factory Input$ProductsCreateWithoutTransactionProductInput({
    required int reference,
    required String name,
    required double buyingPrice,
    required double sellingPrice,
    required String description,
    required String picture,
    required Input$ProductFamilyCreateNestedOneWithoutProductsInput family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
  }) =>
      Input$ProductsCreateWithoutTransactionProductInput._({
        r'reference': reference,
        r'name': name,
        r'buyingPrice': buyingPrice,
        r'sellingPrice': sellingPrice,
        r'description': description,
        r'picture': picture,
        r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ProductsCreateWithoutTransactionProductInput._(this._$data);

  factory Input$ProductsCreateWithoutTransactionProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$reference = data['reference'];
    result$data['reference'] = (l$reference as int);
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$buyingPrice = data['buyingPrice'];
    result$data['buyingPrice'] = (l$buyingPrice as num).toDouble();
    final l$sellingPrice = data['sellingPrice'];
    result$data['sellingPrice'] = (l$sellingPrice as num).toDouble();
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    final l$picture = data['picture'];
    result$data['picture'] = (l$picture as String);
    final l$family = data['family'];
    result$data['family'] =
        Input$ProductFamilyCreateNestedOneWithoutProductsInput.fromJson(
            (l$family as Map<String, dynamic>));
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelCreateNestedManyWithoutProductInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ProductsCreateWithoutTransactionProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get reference => (_$data['reference'] as int);
  String get name => (_$data['name'] as String);
  double get buyingPrice => (_$data['buyingPrice'] as double);
  double get sellingPrice => (_$data['sellingPrice'] as double);
  String get description => (_$data['description'] as String);
  String get picture => (_$data['picture'] as String);
  Input$ProductFamilyCreateNestedOneWithoutProductsInput get family =>
      (_$data['family']
          as Input$ProductFamilyCreateNestedOneWithoutProductsInput);
  Input$ProductModelCreateNestedManyWithoutProductInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelCreateNestedManyWithoutProductInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$reference = reference;
    result$data['reference'] = l$reference;
    final l$name = name;
    result$data['name'] = l$name;
    final l$buyingPrice = buyingPrice;
    result$data['buyingPrice'] = l$buyingPrice;
    final l$sellingPrice = sellingPrice;
    result$data['sellingPrice'] = l$sellingPrice;
    final l$description = description;
    result$data['description'] = l$description;
    final l$picture = picture;
    result$data['picture'] = l$picture;
    final l$family = family;
    result$data['family'] = l$family.toJson();
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<
          Input$ProductsCreateWithoutTransactionProductInput>
      get copyWith =>
          CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsCreateWithoutTransactionProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      l$reference,
      l$name,
      l$buyingPrice,
      l$sellingPrice,
      l$description,
      l$picture,
      l$family,
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateWithoutTransactionProductInput<
    TRes> {
  factory CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
    Input$ProductsCreateWithoutTransactionProductInput instance,
    TRes Function(Input$ProductsCreateWithoutTransactionProductInput) then,
  ) = _CopyWithImpl$Input$ProductsCreateWithoutTransactionProductInput;

  factory CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateWithoutTransactionProductInput;

  TRes call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
  });
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family;
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$ProductsCreateWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> {
  _CopyWithImpl$Input$ProductsCreateWithoutTransactionProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateWithoutTransactionProductInput _instance;

  final TRes Function(Input$ProductsCreateWithoutTransactionProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ProductsCreateWithoutTransactionProductInput._({
        ..._instance._$data,
        if (reference != _undefined && reference != null)
          'reference': (reference as int),
        if (name != _undefined && name != null) 'name': (name as String),
        if (buyingPrice != _undefined && buyingPrice != null)
          'buyingPrice': (buyingPrice as double),
        if (sellingPrice != _undefined && sellingPrice != null)
          'sellingPrice': (sellingPrice as double),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (picture != _undefined && picture != null)
          'picture': (picture as String),
        if (family != _undefined && family != null)
          'family': (family
              as Input$ProductFamilyCreateNestedOneWithoutProductsInput),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelCreateNestedManyWithoutProductInput?),
      }));
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family {
    final local$family = _instance.family;
    return CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput(
        local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductsCreateWithoutTransactionProductInput(
      this._res);

  TRes _res;

  call({
    int? reference,
    String? name,
    double? buyingPrice,
    double? sellingPrice,
    String? description,
    String? picture,
    Input$ProductFamilyCreateNestedOneWithoutProductsInput? family,
    Input$ProductModelCreateNestedManyWithoutProductInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyCreateNestedOneWithoutProductsInput.stub(
              _res);
  CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelCreateNestedManyWithoutProductInput.stub(
              _res);
}

class Input$ProductsCreateOrConnectWithoutTransactionProductInput {
  factory Input$ProductsCreateOrConnectWithoutTransactionProductInput({
    required Input$ProductsWhereUniqueInput where,
    required Input$ProductsCreateWithoutTransactionProductInput create,
  }) =>
      Input$ProductsCreateOrConnectWithoutTransactionProductInput._({
        r'where': where,
        r'create': create,
      });

  Input$ProductsCreateOrConnectWithoutTransactionProductInput._(this._$data);

  factory Input$ProductsCreateOrConnectWithoutTransactionProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$ProductsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductsCreateWithoutTransactionProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductsCreateOrConnectWithoutTransactionProductInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsWhereUniqueInput get where =>
      (_$data['where'] as Input$ProductsWhereUniqueInput);
  Input$ProductsCreateWithoutTransactionProductInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutTransactionProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
          Input$ProductsCreateOrConnectWithoutTransactionProductInput>
      get copyWith =>
          CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductsCreateOrConnectWithoutTransactionProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
    TRes> {
  factory CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
    Input$ProductsCreateOrConnectWithoutTransactionProductInput instance,
    TRes Function(Input$ProductsCreateOrConnectWithoutTransactionProductInput)
        then,
  ) = _CopyWithImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput;

  factory CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput;

  TRes call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutTransactionProductInput? create,
  });
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where;
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
            TRes> {
  _CopyWithImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductsCreateOrConnectWithoutTransactionProductInput _instance;

  final TRes Function(
      Input$ProductsCreateOrConnectWithoutTransactionProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsCreateOrConnectWithoutTransactionProductInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$ProductsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$ProductsCreateWithoutTransactionProductInput),
      }));
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$ProductsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
        TRes>
    implements
        CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsWhereUniqueInput? where,
    Input$ProductsCreateWithoutTransactionProductInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes>
      get create =>
          CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
              _res);
}

class Input$TransactionProductUpdateInput {
  factory Input$TransactionProductUpdateInput({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
    Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?
        product,
  }) =>
      Input$TransactionProductUpdateInput._({
        if (quantity != null) r'quantity': quantity,
        if (price != null) r'price': price,
        if (product_name != null) r'product_name': product_name,
        if (product != null) r'product': product,
      });

  Input$TransactionProductUpdateInput._(this._$data);

  factory Input$TransactionProductUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('price')) {
      final l$price = data['price'];
      result$data['price'] = l$price == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$price as Map<String, dynamic>));
    }
    if (data.containsKey('product_name')) {
      final l$product_name = data['product_name'];
      result$data['product_name'] = l$product_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$product_name as Map<String, dynamic>));
    }
    if (data.containsKey('product')) {
      final l$product = data['product'];
      result$data['product'] = l$product == null
          ? null
          : Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
              .fromJson((l$product as Map<String, dynamic>));
    }
    return Input$TransactionProductUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get price =>
      (_$data['price'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get product_name =>
      (_$data['product_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?
      get product => (_$data['product']
          as Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('price')) {
      final l$price = price;
      result$data['price'] = l$price?.toJson();
    }
    if (_$data.containsKey('product_name')) {
      final l$product_name = product_name;
      result$data['product_name'] = l$product_name?.toJson();
    }
    if (_$data.containsKey('product')) {
      final l$product = product;
      result$data['product'] = l$product?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionProductUpdateInput<
          Input$TransactionProductUpdateInput>
      get copyWith => CopyWith$Input$TransactionProductUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionProductUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$price = price;
    final lOther$price = other.price;
    if (_$data.containsKey('price') != other._$data.containsKey('price')) {
      return false;
    }
    if (l$price != lOther$price) {
      return false;
    }
    final l$product_name = product_name;
    final lOther$product_name = other.product_name;
    if (_$data.containsKey('product_name') !=
        other._$data.containsKey('product_name')) {
      return false;
    }
    if (l$product_name != lOther$product_name) {
      return false;
    }
    final l$product = product;
    final lOther$product = other.product;
    if (_$data.containsKey('product') != other._$data.containsKey('product')) {
      return false;
    }
    if (l$product != lOther$product) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$quantity = quantity;
    final l$price = price;
    final l$product_name = product_name;
    final l$product = product;
    return Object.hashAll([
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('price') ? l$price : const {},
      _$data.containsKey('product_name') ? l$product_name : const {},
      _$data.containsKey('product') ? l$product : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionProductUpdateInput<TRes> {
  factory CopyWith$Input$TransactionProductUpdateInput(
    Input$TransactionProductUpdateInput instance,
    TRes Function(Input$TransactionProductUpdateInput) then,
  ) = _CopyWithImpl$Input$TransactionProductUpdateInput;

  factory CopyWith$Input$TransactionProductUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionProductUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
    Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?
        product,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name;
  CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
      TRes> get product;
}

class _CopyWithImpl$Input$TransactionProductUpdateInput<TRes>
    implements CopyWith$Input$TransactionProductUpdateInput<TRes> {
  _CopyWithImpl$Input$TransactionProductUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionProductUpdateInput _instance;

  final TRes Function(Input$TransactionProductUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? quantity = _undefined,
    Object? price = _undefined,
    Object? product_name = _undefined,
    Object? product = _undefined,
  }) =>
      _then(Input$TransactionProductUpdateInput._({
        ..._instance._$data,
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (price != _undefined)
          'price': (price as Input$FloatFieldUpdateOperationsInput?),
        if (product_name != _undefined)
          'product_name':
              (product_name as Input$StringFieldUpdateOperationsInput?),
        if (product != _undefined)
          'product': (product
              as Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price {
    final local$price = _instance.price;
    return local$price == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$price, (e) => call(price: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name {
    final local$product_name = _instance.product_name;
    return local$product_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$product_name, (e) => call(product_name: e));
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
      TRes> get product {
    final local$product = _instance.product;
    return local$product == null
        ? CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput(
            local$product, (e) => call(product: e));
  }
}

class _CopyWithStubImpl$Input$TransactionProductUpdateInput<TRes>
    implements CopyWith$Input$TransactionProductUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionProductUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$FloatFieldUpdateOperationsInput? price,
    Input$StringFieldUpdateOperationsInput? product_name,
    Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput?
        product,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get price =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get product_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
          TRes>
      get product =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
              .stub(_res);
}

class Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput {
  factory Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsUpsertWithoutTransactionProductInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutTransactionProductInput? update,
  }) =>
      Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
      });

  Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput._(
      this._$data);

  factory Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = l$create == null
          ? null
          : Input$ProductsCreateWithoutTransactionProductInput.fromJson(
              (l$create as Map<String, dynamic>));
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = l$connectOrCreate == null
          ? null
          : Input$ProductsCreateOrConnectWithoutTransactionProductInput
              .fromJson((l$connectOrCreate as Map<String, dynamic>));
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = l$upsert == null
          ? null
          : Input$ProductsUpsertWithoutTransactionProductInput.fromJson(
              (l$upsert as Map<String, dynamic>));
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = l$connect == null
          ? null
          : Input$ProductsWhereUniqueInput.fromJson(
              (l$connect as Map<String, dynamic>));
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = l$update == null
          ? null
          : Input$ProductsUpdateWithoutTransactionProductInput.fromJson(
              (l$update as Map<String, dynamic>));
    }
    return Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsCreateWithoutTransactionProductInput? get create =>
      (_$data['create'] as Input$ProductsCreateWithoutTransactionProductInput?);
  Input$ProductsCreateOrConnectWithoutTransactionProductInput?
      get connectOrCreate => (_$data['connectOrCreate']
          as Input$ProductsCreateOrConnectWithoutTransactionProductInput?);
  Input$ProductsUpsertWithoutTransactionProductInput? get upsert =>
      (_$data['upsert'] as Input$ProductsUpsertWithoutTransactionProductInput?);
  Input$ProductsWhereUniqueInput? get connect =>
      (_$data['connect'] as Input$ProductsWhereUniqueInput?);
  Input$ProductsUpdateWithoutTransactionProductInput? get update =>
      (_$data['update'] as Input$ProductsUpdateWithoutTransactionProductInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.toJson();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] = l$connectOrCreate?.toJson();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.toJson();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.toJson();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
          Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput>
      get copyWith =>
          CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != lOther$update) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$connect = connect;
    final l$update = update;
    return Object.hashAll([
      _$data.containsKey('create') ? l$create : const {},
      _$data.containsKey('connectOrCreate') ? l$connectOrCreate : const {},
      _$data.containsKey('upsert') ? l$upsert : const {},
      _$data.containsKey('connect') ? l$connect : const {},
      _$data.containsKey('update') ? l$update : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
    TRes> {
  factory CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput(
    Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
        instance,
    TRes Function(
            Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput)
        then,
  ) = _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput;

  factory CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput;

  TRes call({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsUpsertWithoutTransactionProductInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutTransactionProductInput? update,
  });
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create;
  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate;
  CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<TRes> get upsert;
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect;
  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> get update;
}

class _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
            TRes> {
  _CopyWithImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
      _instance;

  final TRes Function(
          Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
  }) =>
      _then(Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput
          ._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as Input$ProductsCreateWithoutTransactionProductInput?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as Input$ProductsCreateOrConnectWithoutTransactionProductInput?),
        if (upsert != _undefined)
          'upsert':
              (upsert as Input$ProductsUpsertWithoutTransactionProductInput?),
        if (connect != _undefined)
          'connect': (connect as Input$ProductsWhereUniqueInput?),
        if (update != _undefined)
          'update':
              (update as Input$ProductsUpdateWithoutTransactionProductInput?),
      }));
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create {
    final local$create = _instance.create;
    return local$create == null
        ? CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
            local$create, (e) => call(create: e));
  }

  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate {
    final local$connectOrCreate = _instance.connectOrCreate;
    return local$connectOrCreate == null
        ? CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput(
            local$connectOrCreate, (e) => call(connectOrCreate: e));
  }

  CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<TRes> get upsert {
    final local$upsert = _instance.upsert;
    return local$upsert == null
        ? CopyWith$Input$ProductsUpsertWithoutTransactionProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsUpsertWithoutTransactionProductInput(
            local$upsert, (e) => call(upsert: e));
  }

  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect {
    final local$connect = _instance.connect;
    return local$connect == null
        ? CopyWith$Input$ProductsWhereUniqueInput.stub(_then(_instance))
        : CopyWith$Input$ProductsWhereUniqueInput(
            local$connect, (e) => call(connect: e));
  }

  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> get update {
    final local$update = _instance.update;
    return local$update == null
        ? CopyWith$Input$ProductsUpdateWithoutTransactionProductInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductsUpdateWithoutTransactionProductInput(
            local$update, (e) => call(update: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
        TRes>
    implements
        CopyWith$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateOneRequiredWithoutTransactionProductNestedInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsCreateWithoutTransactionProductInput? create,
    Input$ProductsCreateOrConnectWithoutTransactionProductInput?
        connectOrCreate,
    Input$ProductsUpsertWithoutTransactionProductInput? upsert,
    Input$ProductsWhereUniqueInput? connect,
    Input$ProductsUpdateWithoutTransactionProductInput? update,
  }) =>
      _res;
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes>
      get create =>
          CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
              _res);
  CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput<TRes>
      get connectOrCreate =>
          CopyWith$Input$ProductsCreateOrConnectWithoutTransactionProductInput
              .stub(_res);
  CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<TRes>
      get upsert =>
          CopyWith$Input$ProductsUpsertWithoutTransactionProductInput.stub(
              _res);
  CopyWith$Input$ProductsWhereUniqueInput<TRes> get connect =>
      CopyWith$Input$ProductsWhereUniqueInput.stub(_res);
  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes>
      get update =>
          CopyWith$Input$ProductsUpdateWithoutTransactionProductInput.stub(
              _res);
}

class Input$ProductsUpsertWithoutTransactionProductInput {
  factory Input$ProductsUpsertWithoutTransactionProductInput({
    required Input$ProductsUpdateWithoutTransactionProductInput update,
    required Input$ProductsCreateWithoutTransactionProductInput create,
  }) =>
      Input$ProductsUpsertWithoutTransactionProductInput._({
        r'update': update,
        r'create': create,
      });

  Input$ProductsUpsertWithoutTransactionProductInput._(this._$data);

  factory Input$ProductsUpsertWithoutTransactionProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$update = data['update'];
    result$data['update'] =
        Input$ProductsUpdateWithoutTransactionProductInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$ProductsCreateWithoutTransactionProductInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$ProductsUpsertWithoutTransactionProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$ProductsUpdateWithoutTransactionProductInput get update =>
      (_$data['update'] as Input$ProductsUpdateWithoutTransactionProductInput);
  Input$ProductsCreateWithoutTransactionProductInput get create =>
      (_$data['create'] as Input$ProductsCreateWithoutTransactionProductInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<
          Input$ProductsUpsertWithoutTransactionProductInput>
      get copyWith =>
          CopyWith$Input$ProductsUpsertWithoutTransactionProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpsertWithoutTransactionProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<
    TRes> {
  factory CopyWith$Input$ProductsUpsertWithoutTransactionProductInput(
    Input$ProductsUpsertWithoutTransactionProductInput instance,
    TRes Function(Input$ProductsUpsertWithoutTransactionProductInput) then,
  ) = _CopyWithImpl$Input$ProductsUpsertWithoutTransactionProductInput;

  factory CopyWith$Input$ProductsUpsertWithoutTransactionProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpsertWithoutTransactionProductInput;

  TRes call({
    Input$ProductsUpdateWithoutTransactionProductInput? update,
    Input$ProductsCreateWithoutTransactionProductInput? create,
  });
  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> get update;
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create;
}

class _CopyWithImpl$Input$ProductsUpsertWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<TRes> {
  _CopyWithImpl$Input$ProductsUpsertWithoutTransactionProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpsertWithoutTransactionProductInput _instance;

  final TRes Function(Input$ProductsUpsertWithoutTransactionProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$ProductsUpsertWithoutTransactionProductInput._({
        ..._instance._$data,
        if (update != _undefined && update != null)
          'update':
              (update as Input$ProductsUpdateWithoutTransactionProductInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$ProductsCreateWithoutTransactionProductInput),
      }));
  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$ProductsUpdateWithoutTransactionProductInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$ProductsCreateWithoutTransactionProductInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpsertWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsUpsertWithoutTransactionProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpsertWithoutTransactionProductInput(
      this._res);

  TRes _res;

  call({
    Input$ProductsUpdateWithoutTransactionProductInput? update,
    Input$ProductsCreateWithoutTransactionProductInput? create,
  }) =>
      _res;
  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes>
      get update =>
          CopyWith$Input$ProductsUpdateWithoutTransactionProductInput.stub(
              _res);
  CopyWith$Input$ProductsCreateWithoutTransactionProductInput<TRes>
      get create =>
          CopyWith$Input$ProductsCreateWithoutTransactionProductInput.stub(
              _res);
}

class Input$ProductsUpdateWithoutTransactionProductInput {
  factory Input$ProductsUpdateWithoutTransactionProductInput({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
  }) =>
      Input$ProductsUpdateWithoutTransactionProductInput._({
        if (reference != null) r'reference': reference,
        if (name != null) r'name': name,
        if (buyingPrice != null) r'buyingPrice': buyingPrice,
        if (sellingPrice != null) r'sellingPrice': sellingPrice,
        if (description != null) r'description': description,
        if (picture != null) r'picture': picture,
        if (family != null) r'family': family,
        if (ProductModel != null) r'ProductModel': ProductModel,
      });

  Input$ProductsUpdateWithoutTransactionProductInput._(this._$data);

  factory Input$ProductsUpdateWithoutTransactionProductInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('reference')) {
      final l$reference = data['reference'];
      result$data['reference'] = l$reference == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$reference as Map<String, dynamic>));
    }
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('buyingPrice')) {
      final l$buyingPrice = data['buyingPrice'];
      result$data['buyingPrice'] = l$buyingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$buyingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('sellingPrice')) {
      final l$sellingPrice = data['sellingPrice'];
      result$data['sellingPrice'] = l$sellingPrice == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$sellingPrice as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('picture')) {
      final l$picture = data['picture'];
      result$data['picture'] = l$picture == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$picture as Map<String, dynamic>));
    }
    if (data.containsKey('family')) {
      final l$family = data['family'];
      result$data['family'] = l$family == null
          ? null
          : Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .fromJson((l$family as Map<String, dynamic>));
    }
    if (data.containsKey('ProductModel')) {
      final l$ProductModel = data['ProductModel'];
      result$data['ProductModel'] = l$ProductModel == null
          ? null
          : Input$ProductModelUpdateManyWithoutProductNestedInput.fromJson(
              (l$ProductModel as Map<String, dynamic>));
    }
    return Input$ProductsUpdateWithoutTransactionProductInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get reference =>
      (_$data['reference'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get buyingPrice =>
      (_$data['buyingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get sellingPrice =>
      (_$data['sellingPrice'] as Input$FloatFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get picture =>
      (_$data['picture'] as Input$StringFieldUpdateOperationsInput?);
  Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? get family =>
      (_$data['family']
          as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?);
  Input$ProductModelUpdateManyWithoutProductNestedInput? get ProductModel =>
      (_$data['ProductModel']
          as Input$ProductModelUpdateManyWithoutProductNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('reference')) {
      final l$reference = reference;
      result$data['reference'] = l$reference?.toJson();
    }
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('buyingPrice')) {
      final l$buyingPrice = buyingPrice;
      result$data['buyingPrice'] = l$buyingPrice?.toJson();
    }
    if (_$data.containsKey('sellingPrice')) {
      final l$sellingPrice = sellingPrice;
      result$data['sellingPrice'] = l$sellingPrice?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('picture')) {
      final l$picture = picture;
      result$data['picture'] = l$picture?.toJson();
    }
    if (_$data.containsKey('family')) {
      final l$family = family;
      result$data['family'] = l$family?.toJson();
    }
    if (_$data.containsKey('ProductModel')) {
      final l$ProductModel = ProductModel;
      result$data['ProductModel'] = l$ProductModel?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<
          Input$ProductsUpdateWithoutTransactionProductInput>
      get copyWith =>
          CopyWith$Input$ProductsUpdateWithoutTransactionProductInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$ProductsUpdateWithoutTransactionProductInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$reference = reference;
    final lOther$reference = other.reference;
    if (_$data.containsKey('reference') !=
        other._$data.containsKey('reference')) {
      return false;
    }
    if (l$reference != lOther$reference) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$buyingPrice = buyingPrice;
    final lOther$buyingPrice = other.buyingPrice;
    if (_$data.containsKey('buyingPrice') !=
        other._$data.containsKey('buyingPrice')) {
      return false;
    }
    if (l$buyingPrice != lOther$buyingPrice) {
      return false;
    }
    final l$sellingPrice = sellingPrice;
    final lOther$sellingPrice = other.sellingPrice;
    if (_$data.containsKey('sellingPrice') !=
        other._$data.containsKey('sellingPrice')) {
      return false;
    }
    if (l$sellingPrice != lOther$sellingPrice) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$picture = picture;
    final lOther$picture = other.picture;
    if (_$data.containsKey('picture') != other._$data.containsKey('picture')) {
      return false;
    }
    if (l$picture != lOther$picture) {
      return false;
    }
    final l$family = family;
    final lOther$family = other.family;
    if (_$data.containsKey('family') != other._$data.containsKey('family')) {
      return false;
    }
    if (l$family != lOther$family) {
      return false;
    }
    final l$ProductModel = ProductModel;
    final lOther$ProductModel = other.ProductModel;
    if (_$data.containsKey('ProductModel') !=
        other._$data.containsKey('ProductModel')) {
      return false;
    }
    if (l$ProductModel != lOther$ProductModel) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$reference = reference;
    final l$name = name;
    final l$buyingPrice = buyingPrice;
    final l$sellingPrice = sellingPrice;
    final l$description = description;
    final l$picture = picture;
    final l$family = family;
    final l$ProductModel = ProductModel;
    return Object.hashAll([
      _$data.containsKey('reference') ? l$reference : const {},
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('buyingPrice') ? l$buyingPrice : const {},
      _$data.containsKey('sellingPrice') ? l$sellingPrice : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('picture') ? l$picture : const {},
      _$data.containsKey('family') ? l$family : const {},
      _$data.containsKey('ProductModel') ? l$ProductModel : const {},
    ]);
  }
}

abstract class CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<
    TRes> {
  factory CopyWith$Input$ProductsUpdateWithoutTransactionProductInput(
    Input$ProductsUpdateWithoutTransactionProductInput instance,
    TRes Function(Input$ProductsUpdateWithoutTransactionProductInput) then,
  ) = _CopyWithImpl$Input$ProductsUpdateWithoutTransactionProductInput;

  factory CopyWith$Input$ProductsUpdateWithoutTransactionProductInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$ProductsUpdateWithoutTransactionProductInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture;
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family;
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel;
}

class _CopyWithImpl$Input$ProductsUpdateWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> {
  _CopyWithImpl$Input$ProductsUpdateWithoutTransactionProductInput(
    this._instance,
    this._then,
  );

  final Input$ProductsUpdateWithoutTransactionProductInput _instance;

  final TRes Function(Input$ProductsUpdateWithoutTransactionProductInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? reference = _undefined,
    Object? name = _undefined,
    Object? buyingPrice = _undefined,
    Object? sellingPrice = _undefined,
    Object? description = _undefined,
    Object? picture = _undefined,
    Object? family = _undefined,
    Object? ProductModel = _undefined,
  }) =>
      _then(Input$ProductsUpdateWithoutTransactionProductInput._({
        ..._instance._$data,
        if (reference != _undefined)
          'reference': (reference as Input$IntFieldUpdateOperationsInput?),
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (buyingPrice != _undefined)
          'buyingPrice':
              (buyingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (sellingPrice != _undefined)
          'sellingPrice':
              (sellingPrice as Input$FloatFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (picture != _undefined)
          'picture': (picture as Input$StringFieldUpdateOperationsInput?),
        if (family != _undefined)
          'family': (family
              as Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput?),
        if (ProductModel != _undefined)
          'ProductModel': (ProductModel
              as Input$ProductModelUpdateManyWithoutProductNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference {
    final local$reference = _instance.reference;
    return local$reference == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$reference, (e) => call(reference: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice {
    final local$buyingPrice = _instance.buyingPrice;
    return local$buyingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$buyingPrice, (e) => call(buyingPrice: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice {
    final local$sellingPrice = _instance.sellingPrice;
    return local$sellingPrice == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$sellingPrice, (e) => call(sellingPrice: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture {
    final local$picture = _instance.picture;
    return local$picture == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$picture, (e) => call(picture: e));
  }

  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family {
    final local$family = _instance.family;
    return local$family == null
        ? CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput(
            local$family, (e) => call(family: e));
  }

  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel {
    final local$ProductModel = _instance.ProductModel;
    return local$ProductModel == null
        ? CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput(
            local$ProductModel, (e) => call(ProductModel: e));
  }
}

class _CopyWithStubImpl$Input$ProductsUpdateWithoutTransactionProductInput<TRes>
    implements
        CopyWith$Input$ProductsUpdateWithoutTransactionProductInput<TRes> {
  _CopyWithStubImpl$Input$ProductsUpdateWithoutTransactionProductInput(
      this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? reference,
    Input$StringFieldUpdateOperationsInput? name,
    Input$FloatFieldUpdateOperationsInput? buyingPrice,
    Input$FloatFieldUpdateOperationsInput? sellingPrice,
    Input$StringFieldUpdateOperationsInput? description,
    Input$StringFieldUpdateOperationsInput? picture,
    Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput? family,
    Input$ProductModelUpdateManyWithoutProductNestedInput? ProductModel,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get reference =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get buyingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get sellingPrice =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get picture =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput<TRes>
      get family =>
          CopyWith$Input$ProductFamilyUpdateOneRequiredWithoutProductsNestedInput
              .stub(_res);
  CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput<TRes>
      get ProductModel =>
          CopyWith$Input$ProductModelUpdateManyWithoutProductNestedInput.stub(
              _res);
}

class Input$TransactionStatusCreateInput {
  factory Input$TransactionStatusCreateInput({
    required String name,
    required String description,
    Input$TransactionsCreateNestedManyWithoutStatusInput? Transactions,
  }) =>
      Input$TransactionStatusCreateInput._({
        r'name': name,
        r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionStatusCreateInput._(this._$data);

  factory Input$TransactionStatusCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$name = data['name'];
    result$data['name'] = (l$name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsCreateNestedManyWithoutStatusInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionStatusCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get name => (_$data['name'] as String);
  String get description => (_$data['description'] as String);
  Input$TransactionsCreateNestedManyWithoutStatusInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsCreateNestedManyWithoutStatusInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$name = name;
    result$data['name'] = l$name;
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusCreateInput<
          Input$TransactionStatusCreateInput>
      get copyWith => CopyWith$Input$TransactionStatusCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      l$name,
      l$description,
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusCreateInput<TRes> {
  factory CopyWith$Input$TransactionStatusCreateInput(
    Input$TransactionStatusCreateInput instance,
    TRes Function(Input$TransactionStatusCreateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusCreateInput;

  factory CopyWith$Input$TransactionStatusCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusCreateInput;

  TRes call({
    String? name,
    String? description,
    Input$TransactionsCreateNestedManyWithoutStatusInput? Transactions,
  });
  CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionStatusCreateInput<TRes>
    implements CopyWith$Input$TransactionStatusCreateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusCreateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusCreateInput _instance;

  final TRes Function(Input$TransactionStatusCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionStatusCreateInput._({
        ..._instance._$data,
        if (name != _undefined && name != null) 'name': (name as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsCreateNestedManyWithoutStatusInput?),
      }));
  CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusCreateInput<TRes>
    implements CopyWith$Input$TransactionStatusCreateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusCreateInput(this._res);

  TRes _res;

  call({
    String? name,
    String? description,
    Input$TransactionsCreateNestedManyWithoutStatusInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput.stub(
              _res);
}

class Input$TransactionsCreateNestedManyWithoutStatusInput {
  factory Input$TransactionsCreateNestedManyWithoutStatusInput({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      Input$TransactionsCreateNestedManyWithoutStatusInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionsCreateNestedManyWithoutStatusInput._(this._$data);

  factory Input$TransactionsCreateNestedManyWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutStatusInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutStatusInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsCreateNestedManyWithoutStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutStatusInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutStatusInput>?);
  List<Input$TransactionsCreateOrConnectWithoutStatusInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutStatusInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<
          Input$TransactionsCreateNestedManyWithoutStatusInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateNestedManyWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput(
    Input$TransactionsCreateNestedManyWithoutStatusInput instance,
    TRes Function(Input$TransactionsCreateNestedManyWithoutStatusInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutStatusInput;

  factory CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutStatusInput;

  TRes call({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutStatusInput<
                      Input$TransactionsCreateWithoutStatusInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
                      Input$TransactionsCreateOrConnectWithoutStatusInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateNestedManyWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsCreateNestedManyWithoutStatusInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionsCreateNestedManyWithoutStatusInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$TransactionsCreateWithoutStatusInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutStatusInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutStatusInput<
                          Input$TransactionsCreateWithoutStatusInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutStatusInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
                          Input$TransactionsCreateOrConnectWithoutStatusInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutStatusInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutStatusInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$TransactionsCreateWithoutStatusInput {
  factory Input$TransactionsCreateWithoutStatusInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$SellersCreateNestedOneWithoutTransactionsInput seller,
    required Input$CityCreateNestedOneWithoutTransactionsInput city,
    required Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
        transaction_type,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      Input$TransactionsCreateWithoutStatusInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'seller': seller,
        r'city': city,
        r'transaction_type': transaction_type,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsCreateWithoutStatusInput._(this._$data);

  factory Input$TransactionsCreateWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$seller = data['seller'];
    result$data['seller'] =
        Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$seller as Map<String, dynamic>));
    final l$city = data['city'];
    result$data['city'] =
        Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$city as Map<String, dynamic>));
    final l$transaction_type = data['transaction_type'];
    result$data['transaction_type'] =
        Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$transaction_type as Map<String, dynamic>));
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsCreateWithoutStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$SellersCreateNestedOneWithoutTransactionsInput get seller =>
      (_$data['seller']
          as Input$SellersCreateNestedOneWithoutTransactionsInput);
  Input$CityCreateNestedOneWithoutTransactionsInput get city =>
      (_$data['city'] as Input$CityCreateNestedOneWithoutTransactionsInput);
  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput);
  Input$PayementsCreateNestedManyWithoutTransactionInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsCreateNestedManyWithoutTransactionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$seller = seller;
    result$data['seller'] = l$seller.toJson();
    final l$city = city;
    result$data['city'] = l$city.toJson();
    final l$transaction_type = transaction_type;
    result$data['transaction_type'] = l$transaction_type.toJson();
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateWithoutStatusInput<
          Input$TransactionsCreateWithoutStatusInput>
      get copyWith => CopyWith$Input$TransactionsCreateWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$Payements = Payements;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$seller,
      l$city,
      l$transaction_type,
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> {
  factory CopyWith$Input$TransactionsCreateWithoutStatusInput(
    Input$TransactionsCreateWithoutStatusInput instance,
    TRes Function(Input$TransactionsCreateWithoutStatusInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateWithoutStatusInput;

  factory CopyWith$Input$TransactionsCreateWithoutStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateWithoutStatusInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  });
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller;
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city;
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type;
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsCreateWithoutStatusInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsCreateWithoutStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsCreateWithoutStatusInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (seller != _undefined && seller != null)
          'seller':
              (seller as Input$SellersCreateNestedOneWithoutTransactionsInput),
        if (city != _undefined && city != null)
          'city': (city as Input$CityCreateNestedOneWithoutTransactionsInput),
        if (transaction_type != _undefined && transaction_type != null)
          'transaction_type': (transaction_type
              as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsCreateNestedManyWithoutTransactionInput?),
      }));
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
        local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city {
    final local$city = _instance.city;
    return CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
        local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
        local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateWithoutStatusInput<TRes>
    implements CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateWithoutStatusInput(this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      _res;
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city =>
      CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(_res);
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
              _res);
}

class Input$TransactionsCreateOrConnectWithoutStatusInput {
  factory Input$TransactionsCreateOrConnectWithoutStatusInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsCreateWithoutStatusInput create,
  }) =>
      Input$TransactionsCreateOrConnectWithoutStatusInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionsCreateOrConnectWithoutStatusInput._(this._$data);

  factory Input$TransactionsCreateOrConnectWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutStatusInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsCreateOrConnectWithoutStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsCreateWithoutStatusInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutStatusInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
          Input$TransactionsCreateOrConnectWithoutStatusInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateOrConnectWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput(
    Input$TransactionsCreateOrConnectWithoutStatusInput instance,
    TRes Function(Input$TransactionsCreateOrConnectWithoutStatusInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutStatusInput;

  factory CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutStatusInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutStatusInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutStatusInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateOrConnectWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsCreateOrConnectWithoutStatusInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsCreateOrConnectWithoutStatusInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutStatusInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutStatusInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutStatusInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutStatusInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutStatusInput.stub(_res);
}

class Input$TransactionStatusUpdateManyMutationInput {
  factory Input$TransactionStatusUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      Input$TransactionStatusUpdateManyMutationInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
      });

  Input$TransactionStatusUpdateManyMutationInput._(this._$data);

  factory Input$TransactionStatusUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionStatusUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusUpdateManyMutationInput<
          Input$TransactionStatusUpdateManyMutationInput>
      get copyWith => CopyWith$Input$TransactionStatusUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$TransactionStatusUpdateManyMutationInput(
    Input$TransactionStatusUpdateManyMutationInput instance,
    TRes Function(Input$TransactionStatusUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusUpdateManyMutationInput;

  factory CopyWith$Input$TransactionStatusUpdateManyMutationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
}

class _CopyWithImpl$Input$TransactionStatusUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionStatusUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusUpdateManyMutationInput _instance;

  final TRes Function(Input$TransactionStatusUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionStatusUpdateManyMutationInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionStatusUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionStatusUpdateInput {
  factory Input$TransactionStatusUpdateInput({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutStatusNestedInput? Transactions,
  }) =>
      Input$TransactionStatusUpdateInput._({
        if (name != null) r'name': name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionStatusUpdateInput._(this._$data);

  factory Input$TransactionStatusUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('name')) {
      final l$name = data['name'];
      result$data['name'] = l$name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsUpdateManyWithoutStatusNestedInput.fromJson(
              (l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionStatusUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get name =>
      (_$data['name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$TransactionsUpdateManyWithoutStatusNestedInput? get Transactions =>
      (_$data['Transactions']
          as Input$TransactionsUpdateManyWithoutStatusNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('name')) {
      final l$name = name;
      result$data['name'] = l$name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionStatusUpdateInput<
          Input$TransactionStatusUpdateInput>
      get copyWith => CopyWith$Input$TransactionStatusUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionStatusUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$name = name;
    final lOther$name = other.name;
    if (_$data.containsKey('name') != other._$data.containsKey('name')) {
      return false;
    }
    if (l$name != lOther$name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$name = name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('name') ? l$name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionStatusUpdateInput<TRes> {
  factory CopyWith$Input$TransactionStatusUpdateInput(
    Input$TransactionStatusUpdateInput instance,
    TRes Function(Input$TransactionStatusUpdateInput) then,
  ) = _CopyWithImpl$Input$TransactionStatusUpdateInput;

  factory CopyWith$Input$TransactionStatusUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionStatusUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutStatusNestedInput? Transactions,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionStatusUpdateInput<TRes>
    implements CopyWith$Input$TransactionStatusUpdateInput<TRes> {
  _CopyWithImpl$Input$TransactionStatusUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionStatusUpdateInput _instance;

  final TRes Function(Input$TransactionStatusUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionStatusUpdateInput._({
        ..._instance._$data,
        if (name != _undefined)
          'name': (name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsUpdateManyWithoutStatusNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name {
    final local$name = _instance.name;
    return local$name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$name, (e) => call(name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionStatusUpdateInput<TRes>
    implements CopyWith$Input$TransactionStatusUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionStatusUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutStatusNestedInput? Transactions,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateManyWithoutStatusNestedInput {
  factory Input$TransactionsUpdateManyWithoutStatusNestedInput({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      Input$TransactionsUpdateManyWithoutStatusNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$TransactionsUpdateManyWithoutStatusNestedInput._(this._$data);

  factory Input$TransactionsUpdateManyWithoutStatusNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) => Input$TransactionsCreateWithoutStatusInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutStatusInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) => Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) => Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput
              .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateManyWithWhereWithoutStatusInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsUpdateManyWithoutStatusNestedInput._(result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutStatusInput>? get create =>
      (_$data['create'] as List<Input$TransactionsCreateWithoutStatusInput>?);
  List<Input$TransactionsCreateOrConnectWithoutStatusInput>?
      get connectOrCreate => (_$data['connectOrCreate']
          as List<Input$TransactionsCreateOrConnectWithoutStatusInput>?);
  List<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? get upsert =>
      (_$data['upsert']
          as List<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>?);
  List<Input$TransactionsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? get update =>
      (_$data['update']
          as List<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>?);
  List<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>?
      get updateMany => (_$data['updateMany']
          as List<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>?);
  List<Input$TransactionsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$TransactionsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<
          Input$TransactionsUpdateManyWithoutStatusNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithoutStatusNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput(
    Input$TransactionsUpdateManyWithoutStatusNestedInput instance,
    TRes Function(Input$TransactionsUpdateManyWithoutStatusNestedInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput;

  factory CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput;

  TRes call({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutStatusInput<
                      Input$TransactionsCreateWithoutStatusInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
                      Input$TransactionsCreateOrConnectWithoutStatusInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
                      Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
                      Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
                      Input$TransactionsUpdateManyWithWhereWithoutStatusInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithoutStatusNestedInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithoutStatusNestedInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithoutStatusNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create':
              (create as List<Input$TransactionsCreateWithoutStatusInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate
              as List<Input$TransactionsCreateOrConnectWithoutStatusInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$TransactionsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$TransactionsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$TransactionsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$TransactionsUpdateManyWithWhereWithoutStatusInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$TransactionsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutStatusInput<
                          Input$TransactionsCreateWithoutStatusInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create
              ?.map((e) => CopyWith$Input$TransactionsCreateWithoutStatusInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput<
                          Input$TransactionsCreateOrConnectWithoutStatusInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutStatusInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
                          Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
                          Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
                          Input$TransactionsUpdateManyWithWhereWithoutStatusInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutStatusNestedInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutStatusNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutStatusInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutStatusInput>? connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>? upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>? update,
    List<Input$TransactionsUpdateManyWithWhereWithoutStatusInput>? updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput {
  factory Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutStatusInput update,
    required Input$TransactionsCreateWithoutStatusInput create,
  }) =>
      Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput._(this._$data);

  factory Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] = Input$TransactionsUpdateWithoutStatusInput.fromJson(
        (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] = Input$TransactionsCreateWithoutStatusInput.fromJson(
        (l$create as Map<String, dynamic>));
    return Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutStatusInput get update =>
      (_$data['update'] as Input$TransactionsUpdateWithoutStatusInput);
  Input$TransactionsCreateWithoutStatusInput get create =>
      (_$data['create'] as Input$TransactionsCreateWithoutStatusInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
          Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput(
    Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput instance,
    TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput;

  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutStatusInput? update,
    Input$TransactionsCreateWithoutStatusInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get update;
  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create;
}

class _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update': (update as Input$TransactionsUpdateWithoutStatusInput),
        if (create != _undefined && create != null)
          'create': (create as Input$TransactionsCreateWithoutStatusInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionsUpdateWithoutStatusInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutStatusInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutStatusInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutStatusInput? update,
    Input$TransactionsCreateWithoutStatusInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get update =>
      CopyWith$Input$TransactionsUpdateWithoutStatusInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutStatusInput<TRes> get create =>
      CopyWith$Input$TransactionsCreateWithoutStatusInput.stub(_res);
}

class Input$TransactionsUpdateWithoutStatusInput {
  factory Input$TransactionsUpdateWithoutStatusInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      Input$TransactionsUpdateWithoutStatusInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsUpdateWithoutStatusInput._(this._$data);

  factory Input$TransactionsUpdateWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateWithoutStatusInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? get seller =>
      (_$data['seller']
          as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? get city =>
      (_$data['city']
          as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$PayementsUpdateManyWithoutTransactionNestedInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsUpdateManyWithoutTransactionNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithoutStatusInput<
          Input$TransactionsUpdateWithoutStatusInput>
      get copyWith => CopyWith$Input$TransactionsUpdateWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateWithoutStatusInput(
    Input$TransactionsUpdateWithoutStatusInput instance,
    TRes Function(Input$TransactionsUpdateWithoutStatusInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithoutStatusInput;

  factory CopyWith$Input$TransactionsUpdateWithoutStatusInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithoutStatusInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller;
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city;
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type;
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsUpdateWithoutStatusInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsUpdateWithoutStatusInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithoutStatusInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (seller != _undefined)
          'seller': (seller
              as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (city != _undefined)
          'city': (city
              as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsUpdateManyWithoutTransactionNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithoutStatusInput<TRes>
    implements CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithoutStatusInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput {
  factory Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutStatusInput data,
  }) =>
      Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput._(this._$data);

  factory Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateWithoutStatusInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutStatusInput get data =>
      (_$data['data'] as Input$TransactionsUpdateWithoutStatusInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
          Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput(
    Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput instance,
    TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput;

  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutStatusInput? data,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateWithoutStatusInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateWithoutStatusInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutStatusInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutStatusInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutStatusInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateWithoutStatusInput.stub(_res);
}

class Input$TransactionsUpdateManyWithWhereWithoutStatusInput {
  factory Input$TransactionsUpdateManyWithWhereWithoutStatusInput({
    required Input$TransactionsScalarWhereInput where,
    required Input$TransactionsUpdateManyMutationInput data,
  }) =>
      Input$TransactionsUpdateManyWithWhereWithoutStatusInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateManyWithWhereWithoutStatusInput._(this._$data);

  factory Input$TransactionsUpdateManyWithWhereWithoutStatusInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateManyWithWhereWithoutStatusInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsScalarWhereInput get where =>
      (_$data['where'] as Input$TransactionsScalarWhereInput);
  Input$TransactionsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$TransactionsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
          Input$TransactionsUpdateManyWithWhereWithoutStatusInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateManyWithWhereWithoutStatusInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput(
    Input$TransactionsUpdateManyWithWhereWithoutStatusInput instance,
    TRes Function(Input$TransactionsUpdateManyWithWhereWithoutStatusInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput;

  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput;

  TRes call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  });
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithWhereWithoutStatusInput _instance;

  final TRes Function(Input$TransactionsUpdateManyWithWhereWithoutStatusInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithWhereWithoutStatusInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateManyMutationInput),
      }));
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutStatusInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutStatusInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where =>
      CopyWith$Input$TransactionsScalarWhereInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateManyMutationInput.stub(_res);
}

class Input$TransactionTypesCreateInput {
  factory Input$TransactionTypesCreateInput({
    required String type_name,
    required String description,
    Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?
        Transactions,
  }) =>
      Input$TransactionTypesCreateInput._({
        r'type_name': type_name,
        r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionTypesCreateInput._(this._$data);

  factory Input$TransactionTypesCreateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$type_name = data['type_name'];
    result$data['type_name'] = (l$type_name as String);
    final l$description = data['description'];
    result$data['description'] = (l$description as String);
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsCreateNestedManyWithoutTransaction_typeInput
              .fromJson((l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionTypesCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  String get type_name => (_$data['type_name'] as String);
  String get description => (_$data['description'] as String);
  Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?
      get Transactions => (_$data['Transactions']
          as Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$type_name = type_name;
    result$data['type_name'] = l$type_name;
    final l$description = description;
    result$data['description'] = l$description;
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesCreateInput<Input$TransactionTypesCreateInput>
      get copyWith => CopyWith$Input$TransactionTypesCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type_name = type_name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      l$type_name,
      l$description,
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesCreateInput<TRes> {
  factory CopyWith$Input$TransactionTypesCreateInput(
    Input$TransactionTypesCreateInput instance,
    TRes Function(Input$TransactionTypesCreateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesCreateInput;

  factory CopyWith$Input$TransactionTypesCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesCreateInput;

  TRes call({
    String? type_name,
    String? description,
    Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?
        Transactions,
  });
  CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionTypesCreateInput<TRes>
    implements CopyWith$Input$TransactionTypesCreateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesCreateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesCreateInput _instance;

  final TRes Function(Input$TransactionTypesCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type_name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionTypesCreateInput._({
        ..._instance._$data,
        if (type_name != _undefined && type_name != null)
          'type_name': (type_name as String),
        if (description != _undefined && description != null)
          'description': (description as String),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?),
      }));
  CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesCreateInput<TRes>
    implements CopyWith$Input$TransactionTypesCreateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesCreateInput(this._res);

  TRes _res;

  call({
    String? type_name,
    String? description,
    Input$TransactionsCreateNestedManyWithoutTransaction_typeInput?
        Transactions,
  }) =>
      _res;
  CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput
              .stub(_res);
}

class Input$TransactionsCreateNestedManyWithoutTransaction_typeInput {
  factory Input$TransactionsCreateNestedManyWithoutTransaction_typeInput({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      Input$TransactionsCreateNestedManyWithoutTransaction_typeInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (connect != null) r'connect': connect,
      });

  Input$TransactionsCreateNestedManyWithoutTransaction_typeInput._(this._$data);

  factory Input$TransactionsCreateNestedManyWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateWithoutTransaction_typeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutTransaction_typeInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsCreateNestedManyWithoutTransaction_typeInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutTransaction_typeInput>? get create =>
      (_$data['create']
          as List<Input$TransactionsCreateWithoutTransaction_typeInput>?);
  List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
      get connectOrCreate => (_$data['connectOrCreate'] as List<
          Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
          Input$TransactionsCreateNestedManyWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsCreateNestedManyWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$connect = connect;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput(
    Input$TransactionsCreateNestedManyWithoutTransaction_typeInput instance,
    TRes Function(
            Input$TransactionsCreateNestedManyWithoutTransaction_typeInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput;

  TRes call({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
                      Input$TransactionsCreateWithoutTransaction_typeInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
                      Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateNestedManyWithoutTransaction_typeInput
      _instance;

  final TRes Function(
      Input$TransactionsCreateNestedManyWithoutTransaction_typeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? connect = _undefined,
  }) =>
      _then(Input$TransactionsCreateNestedManyWithoutTransaction_typeInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as List<Input$TransactionsCreateWithoutTransaction_typeInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate as List<
              Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
                          Input$TransactionsCreateWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map((e) =>
              CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
                          Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateNestedManyWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsWhereUniqueInput>? connect,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  connect(_fn) => _res;
}

class Input$TransactionsCreateWithoutTransaction_typeInput {
  factory Input$TransactionsCreateWithoutTransaction_typeInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$SellersCreateNestedOneWithoutTransactionsInput seller,
    required Input$CityCreateNestedOneWithoutTransactionsInput city,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      Input$TransactionsCreateWithoutTransaction_typeInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'seller': seller,
        r'city': city,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsCreateWithoutTransaction_typeInput._(this._$data);

  factory Input$TransactionsCreateWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$seller = data['seller'];
    result$data['seller'] =
        Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$seller as Map<String, dynamic>));
    final l$city = data['city'];
    result$data['city'] =
        Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$city as Map<String, dynamic>));
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsCreateWithoutTransaction_typeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$SellersCreateNestedOneWithoutTransactionsInput get seller =>
      (_$data['seller']
          as Input$SellersCreateNestedOneWithoutTransactionsInput);
  Input$CityCreateNestedOneWithoutTransactionsInput get city =>
      (_$data['city'] as Input$CityCreateNestedOneWithoutTransactionsInput);
  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? get status =>
      (_$data['status']
          as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?);
  Input$PayementsCreateNestedManyWithoutTransactionInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsCreateNestedManyWithoutTransactionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$seller = seller;
    result$data['seller'] = l$seller.toJson();
    final l$city = city;
    result$data['city'] = l$city.toJson();
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
          Input$TransactionsCreateWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (l$city != lOther$city) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$seller,
      l$city,
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
    Input$TransactionsCreateWithoutTransaction_typeInput instance,
    TRes Function(Input$TransactionsCreateWithoutTransaction_typeInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateWithoutTransaction_typeInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  });
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller;
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city;
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status;
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
    implements
        CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateWithoutTransaction_typeInput _instance;

  final TRes Function(Input$TransactionsCreateWithoutTransaction_typeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsCreateWithoutTransaction_typeInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (seller != _undefined && seller != null)
          'seller':
              (seller as Input$SellersCreateNestedOneWithoutTransactionsInput),
        if (city != _undefined && city != null)
          'city': (city as Input$CityCreateNestedOneWithoutTransactionsInput),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsCreateNestedManyWithoutTransactionInput?),
      }));
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
        local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city {
    final local$city = _instance.city;
    return CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
        local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      _res;
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city =>
      CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(_res);
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
              _res);
}

class Input$TransactionsCreateOrConnectWithoutTransaction_typeInput {
  factory Input$TransactionsCreateOrConnectWithoutTransaction_typeInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsCreateWithoutTransaction_typeInput create,
  }) =>
      Input$TransactionsCreateOrConnectWithoutTransaction_typeInput._({
        r'where': where,
        r'create': create,
      });

  Input$TransactionsCreateOrConnectWithoutTransaction_typeInput._(this._$data);

  factory Input$TransactionsCreateOrConnectWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionsCreateWithoutTransaction_typeInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionsCreateOrConnectWithoutTransaction_typeInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsCreateWithoutTransaction_typeInput get create =>
      (_$data['create']
          as Input$TransactionsCreateWithoutTransaction_typeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
          Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsCreateOrConnectWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
    Input$TransactionsCreateOrConnectWithoutTransaction_typeInput instance,
    TRes Function(Input$TransactionsCreateOrConnectWithoutTransaction_typeInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutTransaction_typeInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateOrConnectWithoutTransaction_typeInput _instance;

  final TRes Function(
      Input$TransactionsCreateOrConnectWithoutTransaction_typeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsCreateOrConnectWithoutTransaction_typeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionsCreateWithoutTransaction_typeInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsCreateWithoutTransaction_typeInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create =>
          CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput.stub(
              _res);
}

class Input$TransactionTypesUpdateManyMutationInput {
  factory Input$TransactionTypesUpdateManyMutationInput({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      Input$TransactionTypesUpdateManyMutationInput._({
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
      });

  Input$TransactionTypesUpdateManyMutationInput._(this._$data);

  factory Input$TransactionTypesUpdateManyMutationInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$type_name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    return Input$TransactionTypesUpdateManyMutationInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get type_name =>
      (_$data['type_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] = l$type_name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesUpdateManyMutationInput<
          Input$TransactionTypesUpdateManyMutationInput>
      get copyWith => CopyWith$Input$TransactionTypesUpdateManyMutationInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesUpdateManyMutationInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type_name = type_name;
    final l$description = description;
    return Object.hashAll([
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesUpdateManyMutationInput<TRes> {
  factory CopyWith$Input$TransactionTypesUpdateManyMutationInput(
    Input$TransactionTypesUpdateManyMutationInput instance,
    TRes Function(Input$TransactionTypesUpdateManyMutationInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesUpdateManyMutationInput;

  factory CopyWith$Input$TransactionTypesUpdateManyMutationInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesUpdateManyMutationInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
}

class _CopyWithImpl$Input$TransactionTypesUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionTypesUpdateManyMutationInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesUpdateManyMutationInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesUpdateManyMutationInput _instance;

  final TRes Function(Input$TransactionTypesUpdateManyMutationInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type_name = _undefined,
    Object? description = _undefined,
  }) =>
      _then(Input$TransactionTypesUpdateManyMutationInput._({
        ..._instance._$data,
        if (type_name != _undefined)
          'type_name': (type_name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name {
    final local$type_name = _instance.type_name;
    return local$type_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$type_name, (e) => call(type_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesUpdateManyMutationInput<TRes>
    implements CopyWith$Input$TransactionTypesUpdateManyMutationInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesUpdateManyMutationInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
}

class Input$TransactionTypesUpdateInput {
  factory Input$TransactionTypesUpdateInput({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?
        Transactions,
  }) =>
      Input$TransactionTypesUpdateInput._({
        if (type_name != null) r'type_name': type_name,
        if (description != null) r'description': description,
        if (Transactions != null) r'Transactions': Transactions,
      });

  Input$TransactionTypesUpdateInput._(this._$data);

  factory Input$TransactionTypesUpdateInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('type_name')) {
      final l$type_name = data['type_name'];
      result$data['type_name'] = l$type_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$type_name as Map<String, dynamic>));
    }
    if (data.containsKey('description')) {
      final l$description = data['description'];
      result$data['description'] = l$description == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$description as Map<String, dynamic>));
    }
    if (data.containsKey('Transactions')) {
      final l$Transactions = data['Transactions'];
      result$data['Transactions'] = l$Transactions == null
          ? null
          : Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput
              .fromJson((l$Transactions as Map<String, dynamic>));
    }
    return Input$TransactionTypesUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$StringFieldUpdateOperationsInput? get type_name =>
      (_$data['type_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get description =>
      (_$data['description'] as Input$StringFieldUpdateOperationsInput?);
  Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?
      get Transactions => (_$data['Transactions']
          as Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('type_name')) {
      final l$type_name = type_name;
      result$data['type_name'] = l$type_name?.toJson();
    }
    if (_$data.containsKey('description')) {
      final l$description = description;
      result$data['description'] = l$description?.toJson();
    }
    if (_$data.containsKey('Transactions')) {
      final l$Transactions = Transactions;
      result$data['Transactions'] = l$Transactions?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionTypesUpdateInput<Input$TransactionTypesUpdateInput>
      get copyWith => CopyWith$Input$TransactionTypesUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionTypesUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$type_name = type_name;
    final lOther$type_name = other.type_name;
    if (_$data.containsKey('type_name') !=
        other._$data.containsKey('type_name')) {
      return false;
    }
    if (l$type_name != lOther$type_name) {
      return false;
    }
    final l$description = description;
    final lOther$description = other.description;
    if (_$data.containsKey('description') !=
        other._$data.containsKey('description')) {
      return false;
    }
    if (l$description != lOther$description) {
      return false;
    }
    final l$Transactions = Transactions;
    final lOther$Transactions = other.Transactions;
    if (_$data.containsKey('Transactions') !=
        other._$data.containsKey('Transactions')) {
      return false;
    }
    if (l$Transactions != lOther$Transactions) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$type_name = type_name;
    final l$description = description;
    final l$Transactions = Transactions;
    return Object.hashAll([
      _$data.containsKey('type_name') ? l$type_name : const {},
      _$data.containsKey('description') ? l$description : const {},
      _$data.containsKey('Transactions') ? l$Transactions : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionTypesUpdateInput<TRes> {
  factory CopyWith$Input$TransactionTypesUpdateInput(
    Input$TransactionTypesUpdateInput instance,
    TRes Function(Input$TransactionTypesUpdateInput) then,
  ) = _CopyWithImpl$Input$TransactionTypesUpdateInput;

  factory CopyWith$Input$TransactionTypesUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionTypesUpdateInput;

  TRes call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?
        Transactions,
  });
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description;
  CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<TRes>
      get Transactions;
}

class _CopyWithImpl$Input$TransactionTypesUpdateInput<TRes>
    implements CopyWith$Input$TransactionTypesUpdateInput<TRes> {
  _CopyWithImpl$Input$TransactionTypesUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionTypesUpdateInput _instance;

  final TRes Function(Input$TransactionTypesUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? type_name = _undefined,
    Object? description = _undefined,
    Object? Transactions = _undefined,
  }) =>
      _then(Input$TransactionTypesUpdateInput._({
        ..._instance._$data,
        if (type_name != _undefined)
          'type_name': (type_name as Input$StringFieldUpdateOperationsInput?),
        if (description != _undefined)
          'description':
              (description as Input$StringFieldUpdateOperationsInput?),
        if (Transactions != _undefined)
          'Transactions': (Transactions
              as Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?),
      }));
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name {
    final local$type_name = _instance.type_name;
    return local$type_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$type_name, (e) => call(type_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description {
    final local$description = _instance.description;
    return local$description == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$description, (e) => call(description: e));
  }

  CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<TRes>
      get Transactions {
    final local$Transactions = _instance.Transactions;
    return local$Transactions == null
        ? CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput(
            local$Transactions, (e) => call(Transactions: e));
  }
}

class _CopyWithStubImpl$Input$TransactionTypesUpdateInput<TRes>
    implements CopyWith$Input$TransactionTypesUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionTypesUpdateInput(this._res);

  TRes _res;

  call({
    Input$StringFieldUpdateOperationsInput? type_name,
    Input$StringFieldUpdateOperationsInput? description,
    Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput?
        Transactions,
  }) =>
      _res;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get type_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get description =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<TRes>
      get Transactions =>
          CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput
              .stub(_res);
}

class Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput {
  factory Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?
        upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?
        update,
    List<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?
        updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput._({
        if (create != null) r'create': create,
        if (connectOrCreate != null) r'connectOrCreate': connectOrCreate,
        if (upsert != null) r'upsert': upsert,
        if ($set != null) r'set': $set,
        if (disconnect != null) r'disconnect': disconnect,
        if (delete != null) r'delete': delete,
        if (connect != null) r'connect': connect,
        if (update != null) r'update': update,
        if (updateMany != null) r'updateMany': updateMany,
        if (deleteMany != null) r'deleteMany': deleteMany,
      });

  Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput._(this._$data);

  factory Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('create')) {
      final l$create = data['create'];
      result$data['create'] = (l$create as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateWithoutTransaction_typeInput.fromJson(
                  (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = data['connectOrCreate'];
      result$data['connectOrCreate'] = (l$connectOrCreate as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsCreateOrConnectWithoutTransaction_typeInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('upsert')) {
      final l$upsert = data['upsert'];
      result$data['upsert'] = (l$upsert as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('set')) {
      final l$$set = data['set'];
      result$data['set'] = (l$$set as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('disconnect')) {
      final l$disconnect = data['disconnect'];
      result$data['disconnect'] = (l$disconnect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('delete')) {
      final l$delete = data['delete'];
      result$data['delete'] = (l$delete as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('connect')) {
      final l$connect = data['connect'];
      result$data['connect'] = (l$connect as List<dynamic>?)
          ?.map((e) => Input$TransactionsWhereUniqueInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('update')) {
      final l$update = data['update'];
      result$data['update'] = (l$update as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('updateMany')) {
      final l$updateMany = data['updateMany'];
      result$data['updateMany'] = (l$updateMany as List<dynamic>?)
          ?.map((e) =>
              Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput
                  .fromJson((e as Map<String, dynamic>)))
          .toList();
    }
    if (data.containsKey('deleteMany')) {
      final l$deleteMany = data['deleteMany'];
      result$data['deleteMany'] = (l$deleteMany as List<dynamic>?)
          ?.map((e) => Input$TransactionsScalarWhereInput.fromJson(
              (e as Map<String, dynamic>)))
          .toList();
    }
    return Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  List<Input$TransactionsCreateWithoutTransaction_typeInput>? get create =>
      (_$data['create']
          as List<Input$TransactionsCreateWithoutTransaction_typeInput>?);
  List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
      get connectOrCreate => (_$data['connectOrCreate'] as List<
          Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?);
  List<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?
      get upsert => (_$data['upsert'] as List<
          Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?);
  List<Input$TransactionsWhereUniqueInput>? get $set =>
      (_$data['set'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get disconnect =>
      (_$data['disconnect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get delete =>
      (_$data['delete'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsWhereUniqueInput>? get connect =>
      (_$data['connect'] as List<Input$TransactionsWhereUniqueInput>?);
  List<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?
      get update => (_$data['update'] as List<
          Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?);
  List<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?
      get updateMany => (_$data['updateMany'] as List<
          Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?);
  List<Input$TransactionsScalarWhereInput>? get deleteMany =>
      (_$data['deleteMany'] as List<Input$TransactionsScalarWhereInput>?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('create')) {
      final l$create = create;
      result$data['create'] = l$create?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connectOrCreate')) {
      final l$connectOrCreate = connectOrCreate;
      result$data['connectOrCreate'] =
          l$connectOrCreate?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('upsert')) {
      final l$upsert = upsert;
      result$data['upsert'] = l$upsert?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('set')) {
      final l$$set = $set;
      result$data['set'] = l$$set?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('disconnect')) {
      final l$disconnect = disconnect;
      result$data['disconnect'] = l$disconnect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('delete')) {
      final l$delete = delete;
      result$data['delete'] = l$delete?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('connect')) {
      final l$connect = connect;
      result$data['connect'] = l$connect?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('update')) {
      final l$update = update;
      result$data['update'] = l$update?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('updateMany')) {
      final l$updateMany = updateMany;
      result$data['updateMany'] = l$updateMany?.map((e) => e.toJson()).toList();
    }
    if (_$data.containsKey('deleteMany')) {
      final l$deleteMany = deleteMany;
      result$data['deleteMany'] = l$deleteMany?.map((e) => e.toJson()).toList();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
          Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (_$data.containsKey('create') != other._$data.containsKey('create')) {
      return false;
    }
    if (l$create != null && lOther$create != null) {
      if (l$create.length != lOther$create.length) {
        return false;
      }
      for (int i = 0; i < l$create.length; i++) {
        final l$create$entry = l$create[i];
        final lOther$create$entry = lOther$create[i];
        if (l$create$entry != lOther$create$entry) {
          return false;
        }
      }
    } else if (l$create != lOther$create) {
      return false;
    }
    final l$connectOrCreate = connectOrCreate;
    final lOther$connectOrCreate = other.connectOrCreate;
    if (_$data.containsKey('connectOrCreate') !=
        other._$data.containsKey('connectOrCreate')) {
      return false;
    }
    if (l$connectOrCreate != null && lOther$connectOrCreate != null) {
      if (l$connectOrCreate.length != lOther$connectOrCreate.length) {
        return false;
      }
      for (int i = 0; i < l$connectOrCreate.length; i++) {
        final l$connectOrCreate$entry = l$connectOrCreate[i];
        final lOther$connectOrCreate$entry = lOther$connectOrCreate[i];
        if (l$connectOrCreate$entry != lOther$connectOrCreate$entry) {
          return false;
        }
      }
    } else if (l$connectOrCreate != lOther$connectOrCreate) {
      return false;
    }
    final l$upsert = upsert;
    final lOther$upsert = other.upsert;
    if (_$data.containsKey('upsert') != other._$data.containsKey('upsert')) {
      return false;
    }
    if (l$upsert != null && lOther$upsert != null) {
      if (l$upsert.length != lOther$upsert.length) {
        return false;
      }
      for (int i = 0; i < l$upsert.length; i++) {
        final l$upsert$entry = l$upsert[i];
        final lOther$upsert$entry = lOther$upsert[i];
        if (l$upsert$entry != lOther$upsert$entry) {
          return false;
        }
      }
    } else if (l$upsert != lOther$upsert) {
      return false;
    }
    final l$$set = $set;
    final lOther$$set = other.$set;
    if (_$data.containsKey('set') != other._$data.containsKey('set')) {
      return false;
    }
    if (l$$set != null && lOther$$set != null) {
      if (l$$set.length != lOther$$set.length) {
        return false;
      }
      for (int i = 0; i < l$$set.length; i++) {
        final l$$set$entry = l$$set[i];
        final lOther$$set$entry = lOther$$set[i];
        if (l$$set$entry != lOther$$set$entry) {
          return false;
        }
      }
    } else if (l$$set != lOther$$set) {
      return false;
    }
    final l$disconnect = disconnect;
    final lOther$disconnect = other.disconnect;
    if (_$data.containsKey('disconnect') !=
        other._$data.containsKey('disconnect')) {
      return false;
    }
    if (l$disconnect != null && lOther$disconnect != null) {
      if (l$disconnect.length != lOther$disconnect.length) {
        return false;
      }
      for (int i = 0; i < l$disconnect.length; i++) {
        final l$disconnect$entry = l$disconnect[i];
        final lOther$disconnect$entry = lOther$disconnect[i];
        if (l$disconnect$entry != lOther$disconnect$entry) {
          return false;
        }
      }
    } else if (l$disconnect != lOther$disconnect) {
      return false;
    }
    final l$delete = delete;
    final lOther$delete = other.delete;
    if (_$data.containsKey('delete') != other._$data.containsKey('delete')) {
      return false;
    }
    if (l$delete != null && lOther$delete != null) {
      if (l$delete.length != lOther$delete.length) {
        return false;
      }
      for (int i = 0; i < l$delete.length; i++) {
        final l$delete$entry = l$delete[i];
        final lOther$delete$entry = lOther$delete[i];
        if (l$delete$entry != lOther$delete$entry) {
          return false;
        }
      }
    } else if (l$delete != lOther$delete) {
      return false;
    }
    final l$connect = connect;
    final lOther$connect = other.connect;
    if (_$data.containsKey('connect') != other._$data.containsKey('connect')) {
      return false;
    }
    if (l$connect != null && lOther$connect != null) {
      if (l$connect.length != lOther$connect.length) {
        return false;
      }
      for (int i = 0; i < l$connect.length; i++) {
        final l$connect$entry = l$connect[i];
        final lOther$connect$entry = lOther$connect[i];
        if (l$connect$entry != lOther$connect$entry) {
          return false;
        }
      }
    } else if (l$connect != lOther$connect) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (_$data.containsKey('update') != other._$data.containsKey('update')) {
      return false;
    }
    if (l$update != null && lOther$update != null) {
      if (l$update.length != lOther$update.length) {
        return false;
      }
      for (int i = 0; i < l$update.length; i++) {
        final l$update$entry = l$update[i];
        final lOther$update$entry = lOther$update[i];
        if (l$update$entry != lOther$update$entry) {
          return false;
        }
      }
    } else if (l$update != lOther$update) {
      return false;
    }
    final l$updateMany = updateMany;
    final lOther$updateMany = other.updateMany;
    if (_$data.containsKey('updateMany') !=
        other._$data.containsKey('updateMany')) {
      return false;
    }
    if (l$updateMany != null && lOther$updateMany != null) {
      if (l$updateMany.length != lOther$updateMany.length) {
        return false;
      }
      for (int i = 0; i < l$updateMany.length; i++) {
        final l$updateMany$entry = l$updateMany[i];
        final lOther$updateMany$entry = lOther$updateMany[i];
        if (l$updateMany$entry != lOther$updateMany$entry) {
          return false;
        }
      }
    } else if (l$updateMany != lOther$updateMany) {
      return false;
    }
    final l$deleteMany = deleteMany;
    final lOther$deleteMany = other.deleteMany;
    if (_$data.containsKey('deleteMany') !=
        other._$data.containsKey('deleteMany')) {
      return false;
    }
    if (l$deleteMany != null && lOther$deleteMany != null) {
      if (l$deleteMany.length != lOther$deleteMany.length) {
        return false;
      }
      for (int i = 0; i < l$deleteMany.length; i++) {
        final l$deleteMany$entry = l$deleteMany[i];
        final lOther$deleteMany$entry = lOther$deleteMany[i];
        if (l$deleteMany$entry != lOther$deleteMany$entry) {
          return false;
        }
      }
    } else if (l$deleteMany != lOther$deleteMany) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$create = create;
    final l$connectOrCreate = connectOrCreate;
    final l$upsert = upsert;
    final l$$set = $set;
    final l$disconnect = disconnect;
    final l$delete = delete;
    final l$connect = connect;
    final l$update = update;
    final l$updateMany = updateMany;
    final l$deleteMany = deleteMany;
    return Object.hashAll([
      _$data.containsKey('create')
          ? l$create == null
              ? null
              : Object.hashAll(l$create.map((v) => v))
          : const {},
      _$data.containsKey('connectOrCreate')
          ? l$connectOrCreate == null
              ? null
              : Object.hashAll(l$connectOrCreate.map((v) => v))
          : const {},
      _$data.containsKey('upsert')
          ? l$upsert == null
              ? null
              : Object.hashAll(l$upsert.map((v) => v))
          : const {},
      _$data.containsKey('set')
          ? l$$set == null
              ? null
              : Object.hashAll(l$$set.map((v) => v))
          : const {},
      _$data.containsKey('disconnect')
          ? l$disconnect == null
              ? null
              : Object.hashAll(l$disconnect.map((v) => v))
          : const {},
      _$data.containsKey('delete')
          ? l$delete == null
              ? null
              : Object.hashAll(l$delete.map((v) => v))
          : const {},
      _$data.containsKey('connect')
          ? l$connect == null
              ? null
              : Object.hashAll(l$connect.map((v) => v))
          : const {},
      _$data.containsKey('update')
          ? l$update == null
              ? null
              : Object.hashAll(l$update.map((v) => v))
          : const {},
      _$data.containsKey('updateMany')
          ? l$updateMany == null
              ? null
              : Object.hashAll(l$updateMany.map((v) => v))
          : const {},
      _$data.containsKey('deleteMany')
          ? l$deleteMany == null
              ? null
              : Object.hashAll(l$deleteMany.map((v) => v))
          : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput(
    Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput instance,
    TRes Function(
            Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput;

  factory CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput;

  TRes call({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?
        upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?
        update,
    List<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?
        updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  });
  TRes create(
      Iterable<Input$TransactionsCreateWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
                      Input$TransactionsCreateWithoutTransaction_typeInput>>?)
          _fn);
  TRes connectOrCreate(
      Iterable<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
                      Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>>?)
          _fn);
  TRes upsert(
      Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
                      Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>>?)
          _fn);
  TRes $set(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes disconnect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes delete(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes connect(
      Iterable<Input$TransactionsWhereUniqueInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsWhereUniqueInput<
                      Input$TransactionsWhereUniqueInput>>?)
          _fn);
  TRes update(
      Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
                      Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>>?)
          _fn);
  TRes updateMany(
      Iterable<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
                      Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>>?)
          _fn);
  TRes deleteMany(
      Iterable<Input$TransactionsScalarWhereInput>? Function(
              Iterable<
                  CopyWith$Input$TransactionsScalarWhereInput<
                      Input$TransactionsScalarWhereInput>>?)
          _fn);
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput
      _instance;

  final TRes Function(
      Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? create = _undefined,
    Object? connectOrCreate = _undefined,
    Object? upsert = _undefined,
    Object? $set = _undefined,
    Object? disconnect = _undefined,
    Object? delete = _undefined,
    Object? connect = _undefined,
    Object? update = _undefined,
    Object? updateMany = _undefined,
    Object? deleteMany = _undefined,
  }) =>
      _then(Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput._({
        ..._instance._$data,
        if (create != _undefined)
          'create': (create
              as List<Input$TransactionsCreateWithoutTransaction_typeInput>?),
        if (connectOrCreate != _undefined)
          'connectOrCreate': (connectOrCreate as List<
              Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?),
        if (upsert != _undefined)
          'upsert': (upsert as List<
              Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?),
        if ($set != _undefined)
          'set': ($set as List<Input$TransactionsWhereUniqueInput>?),
        if (disconnect != _undefined)
          'disconnect':
              (disconnect as List<Input$TransactionsWhereUniqueInput>?),
        if (delete != _undefined)
          'delete': (delete as List<Input$TransactionsWhereUniqueInput>?),
        if (connect != _undefined)
          'connect': (connect as List<Input$TransactionsWhereUniqueInput>?),
        if (update != _undefined)
          'update': (update as List<
              Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?),
        if (updateMany != _undefined)
          'updateMany': (updateMany as List<
              Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?),
        if (deleteMany != _undefined)
          'deleteMany':
              (deleteMany as List<Input$TransactionsScalarWhereInput>?),
      }));
  TRes create(
          Iterable<Input$TransactionsCreateWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<
                          Input$TransactionsCreateWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          create: _fn(_instance.create?.map((e) =>
              CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes connectOrCreate(
          Iterable<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput<
                          Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          connectOrCreate: _fn(_instance.connectOrCreate?.map((e) =>
              CopyWith$Input$TransactionsCreateOrConnectWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes upsert(
          Iterable<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
                          Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          upsert: _fn(_instance.upsert?.map((e) =>
              CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes $set(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          $set: _fn(_instance.$set
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes disconnect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          disconnect: _fn(_instance.disconnect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes delete(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          delete: _fn(_instance.delete
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes connect(
          Iterable<Input$TransactionsWhereUniqueInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsWhereUniqueInput<
                          Input$TransactionsWhereUniqueInput>>?)
              _fn) =>
      call(
          connect: _fn(_instance.connect
              ?.map((e) => CopyWith$Input$TransactionsWhereUniqueInput(
                    e,
                    (i) => i,
                  )))?.toList());
  TRes update(
          Iterable<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
                          Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          update: _fn(_instance.update?.map((e) =>
              CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes updateMany(
          Iterable<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
                          Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>>?)
              _fn) =>
      call(
          updateMany: _fn(_instance.updateMany?.map((e) =>
              CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput(
                e,
                (i) => i,
              )))?.toList());
  TRes deleteMany(
          Iterable<Input$TransactionsScalarWhereInput>? Function(
                  Iterable<
                      CopyWith$Input$TransactionsScalarWhereInput<
                          Input$TransactionsScalarWhereInput>>?)
              _fn) =>
      call(
          deleteMany: _fn(_instance.deleteMany
              ?.map((e) => CopyWith$Input$TransactionsScalarWhereInput(
                    e,
                    (i) => i,
                  )))?.toList());
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithoutTransaction_typeNestedInput(
      this._res);

  TRes _res;

  call({
    List<Input$TransactionsCreateWithoutTransaction_typeInput>? create,
    List<Input$TransactionsCreateOrConnectWithoutTransaction_typeInput>?
        connectOrCreate,
    List<Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>?
        upsert,
    List<Input$TransactionsWhereUniqueInput>? $set,
    List<Input$TransactionsWhereUniqueInput>? disconnect,
    List<Input$TransactionsWhereUniqueInput>? delete,
    List<Input$TransactionsWhereUniqueInput>? connect,
    List<Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>?
        update,
    List<Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>?
        updateMany,
    List<Input$TransactionsScalarWhereInput>? deleteMany,
  }) =>
      _res;
  create(_fn) => _res;
  connectOrCreate(_fn) => _res;
  upsert(_fn) => _res;
  $set(_fn) => _res;
  disconnect(_fn) => _res;
  delete(_fn) => _res;
  connect(_fn) => _res;
  update(_fn) => _res;
  updateMany(_fn) => _res;
  deleteMany(_fn) => _res;
}

class Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput {
  factory Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutTransaction_typeInput update,
    required Input$TransactionsCreateWithoutTransaction_typeInput create,
  }) =>
      Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput._({
        r'where': where,
        r'update': update,
        r'create': create,
      });

  Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput._(
      this._$data);

  factory Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$update = data['update'];
    result$data['update'] =
        Input$TransactionsUpdateWithoutTransaction_typeInput.fromJson(
            (l$update as Map<String, dynamic>));
    final l$create = data['create'];
    result$data['create'] =
        Input$TransactionsCreateWithoutTransaction_typeInput.fromJson(
            (l$create as Map<String, dynamic>));
    return Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutTransaction_typeInput get update =>
      (_$data['update']
          as Input$TransactionsUpdateWithoutTransaction_typeInput);
  Input$TransactionsCreateWithoutTransaction_typeInput get create =>
      (_$data['create']
          as Input$TransactionsCreateWithoutTransaction_typeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$update = update;
    result$data['update'] = l$update.toJson();
    final l$create = create;
    result$data['create'] = l$create.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
          Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$update = update;
    final lOther$update = other.update;
    if (l$update != lOther$update) {
      return false;
    }
    final l$create = create;
    final lOther$create = other.create;
    if (l$create != lOther$create) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$update = update;
    final l$create = create;
    return Object.hashAll([
      l$where,
      l$update,
      l$create,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput(
    Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput
        instance,
    TRes Function(
            Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutTransaction_typeInput? update,
    Input$TransactionsCreateWithoutTransaction_typeInput? create,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes>
      get update;
  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create;
}

class _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput
      _instance;

  final TRes Function(
          Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? update = _undefined,
    Object? create = _undefined,
  }) =>
      _then(Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput
          ._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (update != _undefined && update != null)
          'update':
              (update as Input$TransactionsUpdateWithoutTransaction_typeInput),
        if (create != _undefined && create != null)
          'create':
              (create as Input$TransactionsCreateWithoutTransaction_typeInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes>
      get update {
    final local$update = _instance.update;
    return CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput(
        local$update, (e) => call(update: e));
  }

  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create {
    final local$create = _instance.create;
    return CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput(
        local$create, (e) => call(create: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpsertWithWhereUniqueWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutTransaction_typeInput? update,
    Input$TransactionsCreateWithoutTransaction_typeInput? create,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes>
      get update =>
          CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput.stub(
              _res);
  CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput<TRes>
      get create =>
          CopyWith$Input$TransactionsCreateWithoutTransaction_typeInput.stub(
              _res);
}

class Input$TransactionsUpdateWithoutTransaction_typeInput {
  factory Input$TransactionsUpdateWithoutTransaction_typeInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      Input$TransactionsUpdateWithoutTransaction_typeInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsUpdateWithoutTransaction_typeInput._(this._$data);

  factory Input$TransactionsUpdateWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateWithoutTransaction_typeInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? get seller =>
      (_$data['seller']
          as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? get city =>
      (_$data['city']
          as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
      get status => (_$data['status']
          as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$PayementsUpdateManyWithoutTransactionNestedInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsUpdateManyWithoutTransactionNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<
          Input$TransactionsUpdateWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput(
    Input$TransactionsUpdateWithoutTransaction_typeInput instance,
    TRes Function(Input$TransactionsUpdateWithoutTransaction_typeInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithoutTransaction_typeInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller;
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city;
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status;
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithoutTransaction_typeInput _instance;

  final TRes Function(Input$TransactionsUpdateWithoutTransaction_typeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithoutTransaction_typeInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (seller != _undefined)
          'seller': (seller
              as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (city != _undefined)
          'city': (city
              as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsUpdateManyWithoutTransactionNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get status =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
              _res);
}

class Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput {
  factory Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput({
    required Input$TransactionsWhereUniqueInput where,
    required Input$TransactionsUpdateWithoutTransaction_typeInput data,
  }) =>
      Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput._(
      this._$data);

  factory Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsWhereUniqueInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] =
        Input$TransactionsUpdateWithoutTransaction_typeInput.fromJson(
            (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput
        ._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsWhereUniqueInput get where =>
      (_$data['where'] as Input$TransactionsWhereUniqueInput);
  Input$TransactionsUpdateWithoutTransaction_typeInput get data =>
      (_$data['data'] as Input$TransactionsUpdateWithoutTransaction_typeInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
          Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput(
    Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput
        instance,
    TRes Function(
            Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput;

  TRes call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutTransaction_typeInput? data,
  });
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput
      _instance;

  final TRes Function(
          Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput)
      _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput
          ._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsWhereUniqueInput),
        if (data != _undefined && data != null)
          'data':
              (data as Input$TransactionsUpdateWithoutTransaction_typeInput),
      }));
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsWhereUniqueInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateWithWhereUniqueWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsWhereUniqueInput? where,
    Input$TransactionsUpdateWithoutTransaction_typeInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsWhereUniqueInput<TRes> get where =>
      CopyWith$Input$TransactionsWhereUniqueInput.stub(_res);
  CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput<TRes>
      get data =>
          CopyWith$Input$TransactionsUpdateWithoutTransaction_typeInput.stub(
              _res);
}

class Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput {
  factory Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput({
    required Input$TransactionsScalarWhereInput where,
    required Input$TransactionsUpdateManyMutationInput data,
  }) =>
      Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput._({
        r'where': where,
        r'data': data,
      });

  Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput._(
      this._$data);

  factory Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput.fromJson(
      Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$where = data['where'];
    result$data['where'] = Input$TransactionsScalarWhereInput.fromJson(
        (l$where as Map<String, dynamic>));
    final l$data = data['data'];
    result$data['data'] = Input$TransactionsUpdateManyMutationInput.fromJson(
        (l$data as Map<String, dynamic>));
    return Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput._(
        result$data);
  }

  Map<String, dynamic> _$data;

  Input$TransactionsScalarWhereInput get where =>
      (_$data['where'] as Input$TransactionsScalarWhereInput);
  Input$TransactionsUpdateManyMutationInput get data =>
      (_$data['data'] as Input$TransactionsUpdateManyMutationInput);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$where = where;
    result$data['where'] = l$where.toJson();
    final l$data = data;
    result$data['data'] = l$data.toJson();
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
          Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput>
      get copyWith =>
          CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other
            is Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$where = where;
    final lOther$where = other.where;
    if (l$where != lOther$where) {
      return false;
    }
    final l$data = data;
    final lOther$data = other.data;
    if (l$data != lOther$data) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$where = where;
    final l$data = data;
    return Object.hashAll([
      l$where,
      l$data,
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
    TRes> {
  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput(
    Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput instance,
    TRes Function(
            Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput)
        then,
  ) = _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput;

  factory CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput.stub(
          TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput;

  TRes call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  });
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where;
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data;
}

class _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
            TRes> {
  _CopyWithImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput
      _instance;

  final TRes Function(
      Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? where = _undefined,
    Object? data = _undefined,
  }) =>
      _then(
          Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput._({
        ..._instance._$data,
        if (where != _undefined && where != null)
          'where': (where as Input$TransactionsScalarWhereInput),
        if (data != _undefined && data != null)
          'data': (data as Input$TransactionsUpdateManyMutationInput),
      }));
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where {
    final local$where = _instance.where;
    return CopyWith$Input$TransactionsScalarWhereInput(
        local$where, (e) => call(where: e));
  }

  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data {
    final local$data = _instance.data;
    return CopyWith$Input$TransactionsUpdateManyMutationInput(
        local$data, (e) => call(data: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
        TRes>
    implements
        CopyWith$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput<
            TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateManyWithWhereWithoutTransaction_typeInput(
      this._res);

  TRes _res;

  call({
    Input$TransactionsScalarWhereInput? where,
    Input$TransactionsUpdateManyMutationInput? data,
  }) =>
      _res;
  CopyWith$Input$TransactionsScalarWhereInput<TRes> get where =>
      CopyWith$Input$TransactionsScalarWhereInput.stub(_res);
  CopyWith$Input$TransactionsUpdateManyMutationInput<TRes> get data =>
      CopyWith$Input$TransactionsUpdateManyMutationInput.stub(_res);
}

class Input$TransactionsCreateInput {
  factory Input$TransactionsCreateInput({
    required int transaction_id,
    required int product_id,
    required String customer_name,
    required String customer_phone,
    required String address,
    required int quantity,
    required String date,
    required double remainingPayement,
    required double totalPayement,
    required Input$SellersCreateNestedOneWithoutTransactionsInput seller,
    required Input$CityCreateNestedOneWithoutTransactionsInput city,
    required Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      Input$TransactionsCreateInput._({
        r'transaction_id': transaction_id,
        r'product_id': product_id,
        r'customer_name': customer_name,
        r'customer_phone': customer_phone,
        r'address': address,
        r'quantity': quantity,
        r'date': date,
        r'remainingPayement': remainingPayement,
        r'totalPayement': totalPayement,
        r'seller': seller,
        r'city': city,
        r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsCreateInput._(this._$data);

  factory Input$TransactionsCreateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    final l$transaction_id = data['transaction_id'];
    result$data['transaction_id'] = (l$transaction_id as int);
    final l$product_id = data['product_id'];
    result$data['product_id'] = (l$product_id as int);
    final l$customer_name = data['customer_name'];
    result$data['customer_name'] = (l$customer_name as String);
    final l$customer_phone = data['customer_phone'];
    result$data['customer_phone'] = (l$customer_phone as String);
    final l$address = data['address'];
    result$data['address'] = (l$address as String);
    final l$quantity = data['quantity'];
    result$data['quantity'] = (l$quantity as int);
    final l$date = data['date'];
    result$data['date'] = (l$date as String);
    final l$remainingPayement = data['remainingPayement'];
    result$data['remainingPayement'] = (l$remainingPayement as num).toDouble();
    final l$totalPayement = data['totalPayement'];
    result$data['totalPayement'] = (l$totalPayement as num).toDouble();
    final l$seller = data['seller'];
    result$data['seller'] =
        Input$SellersCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$seller as Map<String, dynamic>));
    final l$city = data['city'];
    result$data['city'] =
        Input$CityCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$city as Map<String, dynamic>));
    final l$transaction_type = data['transaction_type'];
    result$data['transaction_type'] =
        Input$TransactionTypesCreateNestedOneWithoutTransactionsInput.fromJson(
            (l$transaction_type as Map<String, dynamic>));
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsCreateNestedManyWithoutTransactionInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsCreateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  int get transaction_id => (_$data['transaction_id'] as int);
  int get product_id => (_$data['product_id'] as int);
  String get customer_name => (_$data['customer_name'] as String);
  String get customer_phone => (_$data['customer_phone'] as String);
  String get address => (_$data['address'] as String);
  int get quantity => (_$data['quantity'] as int);
  String get date => (_$data['date'] as String);
  double get remainingPayement => (_$data['remainingPayement'] as double);
  double get totalPayement => (_$data['totalPayement'] as double);
  Input$SellersCreateNestedOneWithoutTransactionsInput get seller =>
      (_$data['seller']
          as Input$SellersCreateNestedOneWithoutTransactionsInput);
  Input$CityCreateNestedOneWithoutTransactionsInput get city =>
      (_$data['city'] as Input$CityCreateNestedOneWithoutTransactionsInput);
  Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput);
  Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? get status =>
      (_$data['status']
          as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?);
  Input$PayementsCreateNestedManyWithoutTransactionInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsCreateNestedManyWithoutTransactionInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    final l$transaction_id = transaction_id;
    result$data['transaction_id'] = l$transaction_id;
    final l$product_id = product_id;
    result$data['product_id'] = l$product_id;
    final l$customer_name = customer_name;
    result$data['customer_name'] = l$customer_name;
    final l$customer_phone = customer_phone;
    result$data['customer_phone'] = l$customer_phone;
    final l$address = address;
    result$data['address'] = l$address;
    final l$quantity = quantity;
    result$data['quantity'] = l$quantity;
    final l$date = date;
    result$data['date'] = l$date;
    final l$remainingPayement = remainingPayement;
    result$data['remainingPayement'] = l$remainingPayement;
    final l$totalPayement = totalPayement;
    result$data['totalPayement'] = l$totalPayement;
    final l$seller = seller;
    result$data['seller'] = l$seller.toJson();
    final l$city = city;
    result$data['city'] = l$city.toJson();
    final l$transaction_type = transaction_type;
    result$data['transaction_type'] = l$transaction_type.toJson();
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsCreateInput<Input$TransactionsCreateInput>
      get copyWith => CopyWith$Input$TransactionsCreateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsCreateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      l$transaction_id,
      l$product_id,
      l$customer_name,
      l$customer_phone,
      l$address,
      l$quantity,
      l$date,
      l$remainingPayement,
      l$totalPayement,
      l$seller,
      l$city,
      l$transaction_type,
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsCreateInput<TRes> {
  factory CopyWith$Input$TransactionsCreateInput(
    Input$TransactionsCreateInput instance,
    TRes Function(Input$TransactionsCreateInput) then,
  ) = _CopyWithImpl$Input$TransactionsCreateInput;

  factory CopyWith$Input$TransactionsCreateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsCreateInput;

  TRes call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  });
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller;
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city;
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type;
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status;
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsCreateInput<TRes>
    implements CopyWith$Input$TransactionsCreateInput<TRes> {
  _CopyWithImpl$Input$TransactionsCreateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsCreateInput _instance;

  final TRes Function(Input$TransactionsCreateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsCreateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined && transaction_id != null)
          'transaction_id': (transaction_id as int),
        if (product_id != _undefined && product_id != null)
          'product_id': (product_id as int),
        if (customer_name != _undefined && customer_name != null)
          'customer_name': (customer_name as String),
        if (customer_phone != _undefined && customer_phone != null)
          'customer_phone': (customer_phone as String),
        if (address != _undefined && address != null)
          'address': (address as String),
        if (quantity != _undefined && quantity != null)
          'quantity': (quantity as int),
        if (date != _undefined && date != null) 'date': (date as String),
        if (remainingPayement != _undefined && remainingPayement != null)
          'remainingPayement': (remainingPayement as double),
        if (totalPayement != _undefined && totalPayement != null)
          'totalPayement': (totalPayement as double),
        if (seller != _undefined && seller != null)
          'seller':
              (seller as Input$SellersCreateNestedOneWithoutTransactionsInput),
        if (city != _undefined && city != null)
          'city': (city as Input$CityCreateNestedOneWithoutTransactionsInput),
        if (transaction_type != _undefined && transaction_type != null)
          'transaction_type': (transaction_type
              as Input$TransactionTypesCreateNestedOneWithoutTransactionsInput),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusCreateNestedOneWithoutTransactionsInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsCreateNestedManyWithoutTransactionInput?),
      }));
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput(
        local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city {
    final local$city = _instance.city;
    return CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput(
        local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput(
        local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsCreateInput<TRes>
    implements CopyWith$Input$TransactionsCreateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsCreateInput(this._res);

  TRes _res;

  call({
    int? transaction_id,
    int? product_id,
    String? customer_name,
    String? customer_phone,
    String? address,
    int? quantity,
    String? date,
    double? remainingPayement,
    double? totalPayement,
    Input$SellersCreateNestedOneWithoutTransactionsInput? seller,
    Input$CityCreateNestedOneWithoutTransactionsInput? city,
    Input$TransactionTypesCreateNestedOneWithoutTransactionsInput?
        transaction_type,
    Input$TransactionStatusCreateNestedOneWithoutTransactionsInput? status,
    Input$PayementsCreateNestedManyWithoutTransactionInput? Payements,
  }) =>
      _res;
  CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput<TRes>
      get seller =>
          CopyWith$Input$SellersCreateNestedOneWithoutTransactionsInput.stub(
              _res);
  CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput<TRes> get city =>
      CopyWith$Input$CityCreateNestedOneWithoutTransactionsInput.stub(_res);
  CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput<TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput<TRes>
      get status =>
          CopyWith$Input$TransactionStatusCreateNestedOneWithoutTransactionsInput
              .stub(_res);
  CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsCreateNestedManyWithoutTransactionInput.stub(
              _res);
}

class Input$TransactionsUpdateInput {
  factory Input$TransactionsUpdateInput({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      Input$TransactionsUpdateInput._({
        if (transaction_id != null) r'transaction_id': transaction_id,
        if (product_id != null) r'product_id': product_id,
        if (customer_name != null) r'customer_name': customer_name,
        if (customer_phone != null) r'customer_phone': customer_phone,
        if (address != null) r'address': address,
        if (quantity != null) r'quantity': quantity,
        if (date != null) r'date': date,
        if (remainingPayement != null) r'remainingPayement': remainingPayement,
        if (totalPayement != null) r'totalPayement': totalPayement,
        if (seller != null) r'seller': seller,
        if (city != null) r'city': city,
        if (transaction_type != null) r'transaction_type': transaction_type,
        if (status != null) r'status': status,
        if (Payements != null) r'Payements': Payements,
      });

  Input$TransactionsUpdateInput._(this._$data);

  factory Input$TransactionsUpdateInput.fromJson(Map<String, dynamic> data) {
    final result$data = <String, dynamic>{};
    if (data.containsKey('transaction_id')) {
      final l$transaction_id = data['transaction_id'];
      result$data['transaction_id'] = l$transaction_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$transaction_id as Map<String, dynamic>));
    }
    if (data.containsKey('product_id')) {
      final l$product_id = data['product_id'];
      result$data['product_id'] = l$product_id == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$product_id as Map<String, dynamic>));
    }
    if (data.containsKey('customer_name')) {
      final l$customer_name = data['customer_name'];
      result$data['customer_name'] = l$customer_name == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_name as Map<String, dynamic>));
    }
    if (data.containsKey('customer_phone')) {
      final l$customer_phone = data['customer_phone'];
      result$data['customer_phone'] = l$customer_phone == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$customer_phone as Map<String, dynamic>));
    }
    if (data.containsKey('address')) {
      final l$address = data['address'];
      result$data['address'] = l$address == null
          ? null
          : Input$StringFieldUpdateOperationsInput.fromJson(
              (l$address as Map<String, dynamic>));
    }
    if (data.containsKey('quantity')) {
      final l$quantity = data['quantity'];
      result$data['quantity'] = l$quantity == null
          ? null
          : Input$IntFieldUpdateOperationsInput.fromJson(
              (l$quantity as Map<String, dynamic>));
    }
    if (data.containsKey('date')) {
      final l$date = data['date'];
      result$data['date'] = l$date == null
          ? null
          : Input$DateTimeFieldUpdateOperationsInput.fromJson(
              (l$date as Map<String, dynamic>));
    }
    if (data.containsKey('remainingPayement')) {
      final l$remainingPayement = data['remainingPayement'];
      result$data['remainingPayement'] = l$remainingPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$remainingPayement as Map<String, dynamic>));
    }
    if (data.containsKey('totalPayement')) {
      final l$totalPayement = data['totalPayement'];
      result$data['totalPayement'] = l$totalPayement == null
          ? null
          : Input$FloatFieldUpdateOperationsInput.fromJson(
              (l$totalPayement as Map<String, dynamic>));
    }
    if (data.containsKey('seller')) {
      final l$seller = data['seller'];
      result$data['seller'] = l$seller == null
          ? null
          : Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$seller as Map<String, dynamic>));
    }
    if (data.containsKey('city')) {
      final l$city = data['city'];
      result$data['city'] = l$city == null
          ? null
          : Input$CityUpdateOneRequiredWithoutTransactionsNestedInput.fromJson(
              (l$city as Map<String, dynamic>));
    }
    if (data.containsKey('transaction_type')) {
      final l$transaction_type = data['transaction_type'];
      result$data['transaction_type'] = l$transaction_type == null
          ? null
          : Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$transaction_type as Map<String, dynamic>));
    }
    if (data.containsKey('status')) {
      final l$status = data['status'];
      result$data['status'] = l$status == null
          ? null
          : Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .fromJson((l$status as Map<String, dynamic>));
    }
    if (data.containsKey('Payements')) {
      final l$Payements = data['Payements'];
      result$data['Payements'] = l$Payements == null
          ? null
          : Input$PayementsUpdateManyWithoutTransactionNestedInput.fromJson(
              (l$Payements as Map<String, dynamic>));
    }
    return Input$TransactionsUpdateInput._(result$data);
  }

  Map<String, dynamic> _$data;

  Input$IntFieldUpdateOperationsInput? get transaction_id =>
      (_$data['transaction_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get product_id =>
      (_$data['product_id'] as Input$IntFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_name =>
      (_$data['customer_name'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get customer_phone =>
      (_$data['customer_phone'] as Input$StringFieldUpdateOperationsInput?);
  Input$StringFieldUpdateOperationsInput? get address =>
      (_$data['address'] as Input$StringFieldUpdateOperationsInput?);
  Input$IntFieldUpdateOperationsInput? get quantity =>
      (_$data['quantity'] as Input$IntFieldUpdateOperationsInput?);
  Input$DateTimeFieldUpdateOperationsInput? get date =>
      (_$data['date'] as Input$DateTimeFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get remainingPayement =>
      (_$data['remainingPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$FloatFieldUpdateOperationsInput? get totalPayement =>
      (_$data['totalPayement'] as Input$FloatFieldUpdateOperationsInput?);
  Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? get seller =>
      (_$data['seller']
          as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? get city =>
      (_$data['city']
          as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
      get transaction_type => (_$data['transaction_type']
          as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
      get status => (_$data['status']
          as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?);
  Input$PayementsUpdateManyWithoutTransactionNestedInput? get Payements =>
      (_$data['Payements']
          as Input$PayementsUpdateManyWithoutTransactionNestedInput?);
  Map<String, dynamic> toJson() {
    final result$data = <String, dynamic>{};
    if (_$data.containsKey('transaction_id')) {
      final l$transaction_id = transaction_id;
      result$data['transaction_id'] = l$transaction_id?.toJson();
    }
    if (_$data.containsKey('product_id')) {
      final l$product_id = product_id;
      result$data['product_id'] = l$product_id?.toJson();
    }
    if (_$data.containsKey('customer_name')) {
      final l$customer_name = customer_name;
      result$data['customer_name'] = l$customer_name?.toJson();
    }
    if (_$data.containsKey('customer_phone')) {
      final l$customer_phone = customer_phone;
      result$data['customer_phone'] = l$customer_phone?.toJson();
    }
    if (_$data.containsKey('address')) {
      final l$address = address;
      result$data['address'] = l$address?.toJson();
    }
    if (_$data.containsKey('quantity')) {
      final l$quantity = quantity;
      result$data['quantity'] = l$quantity?.toJson();
    }
    if (_$data.containsKey('date')) {
      final l$date = date;
      result$data['date'] = l$date?.toJson();
    }
    if (_$data.containsKey('remainingPayement')) {
      final l$remainingPayement = remainingPayement;
      result$data['remainingPayement'] = l$remainingPayement?.toJson();
    }
    if (_$data.containsKey('totalPayement')) {
      final l$totalPayement = totalPayement;
      result$data['totalPayement'] = l$totalPayement?.toJson();
    }
    if (_$data.containsKey('seller')) {
      final l$seller = seller;
      result$data['seller'] = l$seller?.toJson();
    }
    if (_$data.containsKey('city')) {
      final l$city = city;
      result$data['city'] = l$city?.toJson();
    }
    if (_$data.containsKey('transaction_type')) {
      final l$transaction_type = transaction_type;
      result$data['transaction_type'] = l$transaction_type?.toJson();
    }
    if (_$data.containsKey('status')) {
      final l$status = status;
      result$data['status'] = l$status?.toJson();
    }
    if (_$data.containsKey('Payements')) {
      final l$Payements = Payements;
      result$data['Payements'] = l$Payements?.toJson();
    }
    return result$data;
  }

  CopyWith$Input$TransactionsUpdateInput<Input$TransactionsUpdateInput>
      get copyWith => CopyWith$Input$TransactionsUpdateInput(
            this,
            (i) => i,
          );
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) {
      return true;
    }
    if (!(other is Input$TransactionsUpdateInput) ||
        runtimeType != other.runtimeType) {
      return false;
    }
    final l$transaction_id = transaction_id;
    final lOther$transaction_id = other.transaction_id;
    if (_$data.containsKey('transaction_id') !=
        other._$data.containsKey('transaction_id')) {
      return false;
    }
    if (l$transaction_id != lOther$transaction_id) {
      return false;
    }
    final l$product_id = product_id;
    final lOther$product_id = other.product_id;
    if (_$data.containsKey('product_id') !=
        other._$data.containsKey('product_id')) {
      return false;
    }
    if (l$product_id != lOther$product_id) {
      return false;
    }
    final l$customer_name = customer_name;
    final lOther$customer_name = other.customer_name;
    if (_$data.containsKey('customer_name') !=
        other._$data.containsKey('customer_name')) {
      return false;
    }
    if (l$customer_name != lOther$customer_name) {
      return false;
    }
    final l$customer_phone = customer_phone;
    final lOther$customer_phone = other.customer_phone;
    if (_$data.containsKey('customer_phone') !=
        other._$data.containsKey('customer_phone')) {
      return false;
    }
    if (l$customer_phone != lOther$customer_phone) {
      return false;
    }
    final l$address = address;
    final lOther$address = other.address;
    if (_$data.containsKey('address') != other._$data.containsKey('address')) {
      return false;
    }
    if (l$address != lOther$address) {
      return false;
    }
    final l$quantity = quantity;
    final lOther$quantity = other.quantity;
    if (_$data.containsKey('quantity') !=
        other._$data.containsKey('quantity')) {
      return false;
    }
    if (l$quantity != lOther$quantity) {
      return false;
    }
    final l$date = date;
    final lOther$date = other.date;
    if (_$data.containsKey('date') != other._$data.containsKey('date')) {
      return false;
    }
    if (l$date != lOther$date) {
      return false;
    }
    final l$remainingPayement = remainingPayement;
    final lOther$remainingPayement = other.remainingPayement;
    if (_$data.containsKey('remainingPayement') !=
        other._$data.containsKey('remainingPayement')) {
      return false;
    }
    if (l$remainingPayement != lOther$remainingPayement) {
      return false;
    }
    final l$totalPayement = totalPayement;
    final lOther$totalPayement = other.totalPayement;
    if (_$data.containsKey('totalPayement') !=
        other._$data.containsKey('totalPayement')) {
      return false;
    }
    if (l$totalPayement != lOther$totalPayement) {
      return false;
    }
    final l$seller = seller;
    final lOther$seller = other.seller;
    if (_$data.containsKey('seller') != other._$data.containsKey('seller')) {
      return false;
    }
    if (l$seller != lOther$seller) {
      return false;
    }
    final l$city = city;
    final lOther$city = other.city;
    if (_$data.containsKey('city') != other._$data.containsKey('city')) {
      return false;
    }
    if (l$city != lOther$city) {
      return false;
    }
    final l$transaction_type = transaction_type;
    final lOther$transaction_type = other.transaction_type;
    if (_$data.containsKey('transaction_type') !=
        other._$data.containsKey('transaction_type')) {
      return false;
    }
    if (l$transaction_type != lOther$transaction_type) {
      return false;
    }
    final l$status = status;
    final lOther$status = other.status;
    if (_$data.containsKey('status') != other._$data.containsKey('status')) {
      return false;
    }
    if (l$status != lOther$status) {
      return false;
    }
    final l$Payements = Payements;
    final lOther$Payements = other.Payements;
    if (_$data.containsKey('Payements') !=
        other._$data.containsKey('Payements')) {
      return false;
    }
    if (l$Payements != lOther$Payements) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    final l$transaction_id = transaction_id;
    final l$product_id = product_id;
    final l$customer_name = customer_name;
    final l$customer_phone = customer_phone;
    final l$address = address;
    final l$quantity = quantity;
    final l$date = date;
    final l$remainingPayement = remainingPayement;
    final l$totalPayement = totalPayement;
    final l$seller = seller;
    final l$city = city;
    final l$transaction_type = transaction_type;
    final l$status = status;
    final l$Payements = Payements;
    return Object.hashAll([
      _$data.containsKey('transaction_id') ? l$transaction_id : const {},
      _$data.containsKey('product_id') ? l$product_id : const {},
      _$data.containsKey('customer_name') ? l$customer_name : const {},
      _$data.containsKey('customer_phone') ? l$customer_phone : const {},
      _$data.containsKey('address') ? l$address : const {},
      _$data.containsKey('quantity') ? l$quantity : const {},
      _$data.containsKey('date') ? l$date : const {},
      _$data.containsKey('remainingPayement') ? l$remainingPayement : const {},
      _$data.containsKey('totalPayement') ? l$totalPayement : const {},
      _$data.containsKey('seller') ? l$seller : const {},
      _$data.containsKey('city') ? l$city : const {},
      _$data.containsKey('transaction_type') ? l$transaction_type : const {},
      _$data.containsKey('status') ? l$status : const {},
      _$data.containsKey('Payements') ? l$Payements : const {},
    ]);
  }
}

abstract class CopyWith$Input$TransactionsUpdateInput<TRes> {
  factory CopyWith$Input$TransactionsUpdateInput(
    Input$TransactionsUpdateInput instance,
    TRes Function(Input$TransactionsUpdateInput) then,
  ) = _CopyWithImpl$Input$TransactionsUpdateInput;

  factory CopyWith$Input$TransactionsUpdateInput.stub(TRes res) =
      _CopyWithStubImpl$Input$TransactionsUpdateInput;

  TRes call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  });
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone;
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity;
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement;
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement;
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller;
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city;
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type;
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status;
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements;
}

class _CopyWithImpl$Input$TransactionsUpdateInput<TRes>
    implements CopyWith$Input$TransactionsUpdateInput<TRes> {
  _CopyWithImpl$Input$TransactionsUpdateInput(
    this._instance,
    this._then,
  );

  final Input$TransactionsUpdateInput _instance;

  final TRes Function(Input$TransactionsUpdateInput) _then;

  static const _undefined = <dynamic, dynamic>{};

  TRes call({
    Object? transaction_id = _undefined,
    Object? product_id = _undefined,
    Object? customer_name = _undefined,
    Object? customer_phone = _undefined,
    Object? address = _undefined,
    Object? quantity = _undefined,
    Object? date = _undefined,
    Object? remainingPayement = _undefined,
    Object? totalPayement = _undefined,
    Object? seller = _undefined,
    Object? city = _undefined,
    Object? transaction_type = _undefined,
    Object? status = _undefined,
    Object? Payements = _undefined,
  }) =>
      _then(Input$TransactionsUpdateInput._({
        ..._instance._$data,
        if (transaction_id != _undefined)
          'transaction_id':
              (transaction_id as Input$IntFieldUpdateOperationsInput?),
        if (product_id != _undefined)
          'product_id': (product_id as Input$IntFieldUpdateOperationsInput?),
        if (customer_name != _undefined)
          'customer_name':
              (customer_name as Input$StringFieldUpdateOperationsInput?),
        if (customer_phone != _undefined)
          'customer_phone':
              (customer_phone as Input$StringFieldUpdateOperationsInput?),
        if (address != _undefined)
          'address': (address as Input$StringFieldUpdateOperationsInput?),
        if (quantity != _undefined)
          'quantity': (quantity as Input$IntFieldUpdateOperationsInput?),
        if (date != _undefined)
          'date': (date as Input$DateTimeFieldUpdateOperationsInput?),
        if (remainingPayement != _undefined)
          'remainingPayement':
              (remainingPayement as Input$FloatFieldUpdateOperationsInput?),
        if (totalPayement != _undefined)
          'totalPayement':
              (totalPayement as Input$FloatFieldUpdateOperationsInput?),
        if (seller != _undefined)
          'seller': (seller
              as Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (city != _undefined)
          'city': (city
              as Input$CityUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (transaction_type != _undefined)
          'transaction_type': (transaction_type
              as Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (status != _undefined)
          'status': (status
              as Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?),
        if (Payements != _undefined)
          'Payements': (Payements
              as Input$PayementsUpdateManyWithoutTransactionNestedInput?),
      }));
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id {
    final local$transaction_id = _instance.transaction_id;
    return local$transaction_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$transaction_id, (e) => call(transaction_id: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id {
    final local$product_id = _instance.product_id;
    return local$product_id == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$product_id, (e) => call(product_id: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name {
    final local$customer_name = _instance.customer_name;
    return local$customer_name == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_name, (e) => call(customer_name: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone {
    final local$customer_phone = _instance.customer_phone;
    return local$customer_phone == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$customer_phone, (e) => call(customer_phone: e));
  }

  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address {
    final local$address = _instance.address;
    return local$address == null
        ? CopyWith$Input$StringFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$StringFieldUpdateOperationsInput(
            local$address, (e) => call(address: e));
  }

  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity {
    final local$quantity = _instance.quantity;
    return local$quantity == null
        ? CopyWith$Input$IntFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$IntFieldUpdateOperationsInput(
            local$quantity, (e) => call(quantity: e));
  }

  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date {
    final local$date = _instance.date;
    return local$date == null
        ? CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(
            _then(_instance))
        : CopyWith$Input$DateTimeFieldUpdateOperationsInput(
            local$date, (e) => call(date: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement {
    final local$remainingPayement = _instance.remainingPayement;
    return local$remainingPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$remainingPayement, (e) => call(remainingPayement: e));
  }

  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement {
    final local$totalPayement = _instance.totalPayement;
    return local$totalPayement == null
        ? CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_then(_instance))
        : CopyWith$Input$FloatFieldUpdateOperationsInput(
            local$totalPayement, (e) => call(totalPayement: e));
  }

  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller {
    final local$seller = _instance.seller;
    return local$seller == null
        ? CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput(
            local$seller, (e) => call(seller: e));
  }

  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city {
    final local$city = _instance.city;
    return local$city == null
        ? CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput(
            local$city, (e) => call(city: e));
  }

  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get transaction_type {
    final local$transaction_type = _instance.transaction_type;
    return local$transaction_type == null
        ? CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput(
            local$transaction_type, (e) => call(transaction_type: e));
  }

  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
      TRes> get status {
    final local$status = _instance.status;
    return local$status == null
        ? CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
            .stub(_then(_instance))
        : CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput(
            local$status, (e) => call(status: e));
  }

  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements {
    final local$Payements = _instance.Payements;
    return local$Payements == null
        ? CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
            _then(_instance))
        : CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput(
            local$Payements, (e) => call(Payements: e));
  }
}

class _CopyWithStubImpl$Input$TransactionsUpdateInput<TRes>
    implements CopyWith$Input$TransactionsUpdateInput<TRes> {
  _CopyWithStubImpl$Input$TransactionsUpdateInput(this._res);

  TRes _res;

  call({
    Input$IntFieldUpdateOperationsInput? transaction_id,
    Input$IntFieldUpdateOperationsInput? product_id,
    Input$StringFieldUpdateOperationsInput? customer_name,
    Input$StringFieldUpdateOperationsInput? customer_phone,
    Input$StringFieldUpdateOperationsInput? address,
    Input$IntFieldUpdateOperationsInput? quantity,
    Input$DateTimeFieldUpdateOperationsInput? date,
    Input$FloatFieldUpdateOperationsInput? remainingPayement,
    Input$FloatFieldUpdateOperationsInput? totalPayement,
    Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput? seller,
    Input$CityUpdateOneRequiredWithoutTransactionsNestedInput? city,
    Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput?
        transaction_type,
    Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput?
        status,
    Input$PayementsUpdateManyWithoutTransactionNestedInput? Payements,
  }) =>
      _res;
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get transaction_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get product_id =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_name =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get customer_phone =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$StringFieldUpdateOperationsInput<TRes> get address =>
      CopyWith$Input$StringFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$IntFieldUpdateOperationsInput<TRes> get quantity =>
      CopyWith$Input$IntFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$DateTimeFieldUpdateOperationsInput<TRes> get date =>
      CopyWith$Input$DateTimeFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get remainingPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$FloatFieldUpdateOperationsInput<TRes> get totalPayement =>
      CopyWith$Input$FloatFieldUpdateOperationsInput.stub(_res);
  CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get seller =>
          CopyWith$Input$SellersUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput<TRes>
      get city =>
          CopyWith$Input$CityUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get transaction_type =>
          CopyWith$Input$TransactionTypesUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput<
          TRes>
      get status =>
          CopyWith$Input$TransactionStatusUpdateOneRequiredWithoutTransactionsNestedInput
              .stub(_res);
  CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput<TRes>
      get Payements =>
          CopyWith$Input$PayementsUpdateManyWithoutTransactionNestedInput.stub(
              _res);
}

enum Enum$SortOrder { asc, desc, $unknown }

String toJson$Enum$SortOrder(Enum$SortOrder e) {
  switch (e) {
    case Enum$SortOrder.asc:
      return r'asc';
    case Enum$SortOrder.desc:
      return r'desc';
    case Enum$SortOrder.$unknown:
      return r'$unknown';
  }
}

Enum$SortOrder fromJson$Enum$SortOrder(String value) {
  switch (value) {
    case r'asc':
      return Enum$SortOrder.asc;
    case r'desc':
      return Enum$SortOrder.desc;
    default:
      return Enum$SortOrder.$unknown;
  }
}

enum Enum$TransactionsScalarFieldEnum {
  transaction_id,
  seller_id,
  product_id,
  customer_name,
  customer_phone,
  city_id,
  address,
  quantity,
  date,
  remainingPayement,
  totalPayement,
  transaction_type_id,
  status_id,
  $unknown
}

String toJson$Enum$TransactionsScalarFieldEnum(
    Enum$TransactionsScalarFieldEnum e) {
  switch (e) {
    case Enum$TransactionsScalarFieldEnum.transaction_id:
      return r'transaction_id';
    case Enum$TransactionsScalarFieldEnum.seller_id:
      return r'seller_id';
    case Enum$TransactionsScalarFieldEnum.product_id:
      return r'product_id';
    case Enum$TransactionsScalarFieldEnum.customer_name:
      return r'customer_name';
    case Enum$TransactionsScalarFieldEnum.customer_phone:
      return r'customer_phone';
    case Enum$TransactionsScalarFieldEnum.city_id:
      return r'city_id';
    case Enum$TransactionsScalarFieldEnum.address:
      return r'address';
    case Enum$TransactionsScalarFieldEnum.quantity:
      return r'quantity';
    case Enum$TransactionsScalarFieldEnum.date:
      return r'date';
    case Enum$TransactionsScalarFieldEnum.remainingPayement:
      return r'remainingPayement';
    case Enum$TransactionsScalarFieldEnum.totalPayement:
      return r'totalPayement';
    case Enum$TransactionsScalarFieldEnum.transaction_type_id:
      return r'transaction_type_id';
    case Enum$TransactionsScalarFieldEnum.status_id:
      return r'status_id';
    case Enum$TransactionsScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionsScalarFieldEnum fromJson$Enum$TransactionsScalarFieldEnum(
    String value) {
  switch (value) {
    case r'transaction_id':
      return Enum$TransactionsScalarFieldEnum.transaction_id;
    case r'seller_id':
      return Enum$TransactionsScalarFieldEnum.seller_id;
    case r'product_id':
      return Enum$TransactionsScalarFieldEnum.product_id;
    case r'customer_name':
      return Enum$TransactionsScalarFieldEnum.customer_name;
    case r'customer_phone':
      return Enum$TransactionsScalarFieldEnum.customer_phone;
    case r'city_id':
      return Enum$TransactionsScalarFieldEnum.city_id;
    case r'address':
      return Enum$TransactionsScalarFieldEnum.address;
    case r'quantity':
      return Enum$TransactionsScalarFieldEnum.quantity;
    case r'date':
      return Enum$TransactionsScalarFieldEnum.date;
    case r'remainingPayement':
      return Enum$TransactionsScalarFieldEnum.remainingPayement;
    case r'totalPayement':
      return Enum$TransactionsScalarFieldEnum.totalPayement;
    case r'transaction_type_id':
      return Enum$TransactionsScalarFieldEnum.transaction_type_id;
    case r'status_id':
      return Enum$TransactionsScalarFieldEnum.status_id;
    default:
      return Enum$TransactionsScalarFieldEnum.$unknown;
  }
}

enum Enum$PayementsScalarFieldEnum {
  payement_id,
  transaction_id,
  payement,
  $unknown
}

String toJson$Enum$PayementsScalarFieldEnum(Enum$PayementsScalarFieldEnum e) {
  switch (e) {
    case Enum$PayementsScalarFieldEnum.payement_id:
      return r'payement_id';
    case Enum$PayementsScalarFieldEnum.transaction_id:
      return r'transaction_id';
    case Enum$PayementsScalarFieldEnum.payement:
      return r'payement';
    case Enum$PayementsScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$PayementsScalarFieldEnum fromJson$Enum$PayementsScalarFieldEnum(
    String value) {
  switch (value) {
    case r'payement_id':
      return Enum$PayementsScalarFieldEnum.payement_id;
    case r'transaction_id':
      return Enum$PayementsScalarFieldEnum.transaction_id;
    case r'payement':
      return Enum$PayementsScalarFieldEnum.payement;
    default:
      return Enum$PayementsScalarFieldEnum.$unknown;
  }
}

enum Enum$CityScalarFieldEnum { city_id, city_name, $unknown }

String toJson$Enum$CityScalarFieldEnum(Enum$CityScalarFieldEnum e) {
  switch (e) {
    case Enum$CityScalarFieldEnum.city_id:
      return r'city_id';
    case Enum$CityScalarFieldEnum.city_name:
      return r'city_name';
    case Enum$CityScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$CityScalarFieldEnum fromJson$Enum$CityScalarFieldEnum(String value) {
  switch (value) {
    case r'city_id':
      return Enum$CityScalarFieldEnum.city_id;
    case r'city_name':
      return Enum$CityScalarFieldEnum.city_name;
    default:
      return Enum$CityScalarFieldEnum.$unknown;
  }
}

enum Enum$ProductsScalarFieldEnum {
  product_id,
  reference,
  name,
  buyingPrice,
  sellingPrice,
  description,
  picture,
  family_id,
  $unknown
}

String toJson$Enum$ProductsScalarFieldEnum(Enum$ProductsScalarFieldEnum e) {
  switch (e) {
    case Enum$ProductsScalarFieldEnum.product_id:
      return r'product_id';
    case Enum$ProductsScalarFieldEnum.reference:
      return r'reference';
    case Enum$ProductsScalarFieldEnum.name:
      return r'name';
    case Enum$ProductsScalarFieldEnum.buyingPrice:
      return r'buyingPrice';
    case Enum$ProductsScalarFieldEnum.sellingPrice:
      return r'sellingPrice';
    case Enum$ProductsScalarFieldEnum.description:
      return r'description';
    case Enum$ProductsScalarFieldEnum.picture:
      return r'picture';
    case Enum$ProductsScalarFieldEnum.family_id:
      return r'family_id';
    case Enum$ProductsScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductsScalarFieldEnum fromJson$Enum$ProductsScalarFieldEnum(
    String value) {
  switch (value) {
    case r'product_id':
      return Enum$ProductsScalarFieldEnum.product_id;
    case r'reference':
      return Enum$ProductsScalarFieldEnum.reference;
    case r'name':
      return Enum$ProductsScalarFieldEnum.name;
    case r'buyingPrice':
      return Enum$ProductsScalarFieldEnum.buyingPrice;
    case r'sellingPrice':
      return Enum$ProductsScalarFieldEnum.sellingPrice;
    case r'description':
      return Enum$ProductsScalarFieldEnum.description;
    case r'picture':
      return Enum$ProductsScalarFieldEnum.picture;
    case r'family_id':
      return Enum$ProductsScalarFieldEnum.family_id;
    default:
      return Enum$ProductsScalarFieldEnum.$unknown;
  }
}

enum Enum$ProductModelScalarFieldEnum {
  product_id,
  color_id,
  size_id,
  quantity,
  $unknown
}

String toJson$Enum$ProductModelScalarFieldEnum(
    Enum$ProductModelScalarFieldEnum e) {
  switch (e) {
    case Enum$ProductModelScalarFieldEnum.product_id:
      return r'product_id';
    case Enum$ProductModelScalarFieldEnum.color_id:
      return r'color_id';
    case Enum$ProductModelScalarFieldEnum.size_id:
      return r'size_id';
    case Enum$ProductModelScalarFieldEnum.quantity:
      return r'quantity';
    case Enum$ProductModelScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductModelScalarFieldEnum fromJson$Enum$ProductModelScalarFieldEnum(
    String value) {
  switch (value) {
    case r'product_id':
      return Enum$ProductModelScalarFieldEnum.product_id;
    case r'color_id':
      return Enum$ProductModelScalarFieldEnum.color_id;
    case r'size_id':
      return Enum$ProductModelScalarFieldEnum.size_id;
    case r'quantity':
      return Enum$ProductModelScalarFieldEnum.quantity;
    default:
      return Enum$ProductModelScalarFieldEnum.$unknown;
  }
}

enum Enum$TransactionProductScalarFieldEnum {
  transaction_id,
  product_id,
  quantity,
  price,
  product_name,
  $unknown
}

String toJson$Enum$TransactionProductScalarFieldEnum(
    Enum$TransactionProductScalarFieldEnum e) {
  switch (e) {
    case Enum$TransactionProductScalarFieldEnum.transaction_id:
      return r'transaction_id';
    case Enum$TransactionProductScalarFieldEnum.product_id:
      return r'product_id';
    case Enum$TransactionProductScalarFieldEnum.quantity:
      return r'quantity';
    case Enum$TransactionProductScalarFieldEnum.price:
      return r'price';
    case Enum$TransactionProductScalarFieldEnum.product_name:
      return r'product_name';
    case Enum$TransactionProductScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionProductScalarFieldEnum
    fromJson$Enum$TransactionProductScalarFieldEnum(String value) {
  switch (value) {
    case r'transaction_id':
      return Enum$TransactionProductScalarFieldEnum.transaction_id;
    case r'product_id':
      return Enum$TransactionProductScalarFieldEnum.product_id;
    case r'quantity':
      return Enum$TransactionProductScalarFieldEnum.quantity;
    case r'price':
      return Enum$TransactionProductScalarFieldEnum.price;
    case r'product_name':
      return Enum$TransactionProductScalarFieldEnum.product_name;
    default:
      return Enum$TransactionProductScalarFieldEnum.$unknown;
  }
}

enum Enum$ColorsScalarFieldEnum { id, color, $unknown }

String toJson$Enum$ColorsScalarFieldEnum(Enum$ColorsScalarFieldEnum e) {
  switch (e) {
    case Enum$ColorsScalarFieldEnum.id:
      return r'id';
    case Enum$ColorsScalarFieldEnum.color:
      return r'color';
    case Enum$ColorsScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ColorsScalarFieldEnum fromJson$Enum$ColorsScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$ColorsScalarFieldEnum.id;
    case r'color':
      return Enum$ColorsScalarFieldEnum.color;
    default:
      return Enum$ColorsScalarFieldEnum.$unknown;
  }
}

enum Enum$ProductFamilyScalarFieldEnum { id, name, $unknown }

String toJson$Enum$ProductFamilyScalarFieldEnum(
    Enum$ProductFamilyScalarFieldEnum e) {
  switch (e) {
    case Enum$ProductFamilyScalarFieldEnum.id:
      return r'id';
    case Enum$ProductFamilyScalarFieldEnum.name:
      return r'name';
    case Enum$ProductFamilyScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$ProductFamilyScalarFieldEnum fromJson$Enum$ProductFamilyScalarFieldEnum(
    String value) {
  switch (value) {
    case r'id':
      return Enum$ProductFamilyScalarFieldEnum.id;
    case r'name':
      return Enum$ProductFamilyScalarFieldEnum.name;
    default:
      return Enum$ProductFamilyScalarFieldEnum.$unknown;
  }
}

enum Enum$SellersScalarFieldEnum {
  seller_id,
  seller_name,
  seller_phone,
  picture,
  $unknown
}

String toJson$Enum$SellersScalarFieldEnum(Enum$SellersScalarFieldEnum e) {
  switch (e) {
    case Enum$SellersScalarFieldEnum.seller_id:
      return r'seller_id';
    case Enum$SellersScalarFieldEnum.seller_name:
      return r'seller_name';
    case Enum$SellersScalarFieldEnum.seller_phone:
      return r'seller_phone';
    case Enum$SellersScalarFieldEnum.picture:
      return r'picture';
    case Enum$SellersScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SellersScalarFieldEnum fromJson$Enum$SellersScalarFieldEnum(String value) {
  switch (value) {
    case r'seller_id':
      return Enum$SellersScalarFieldEnum.seller_id;
    case r'seller_name':
      return Enum$SellersScalarFieldEnum.seller_name;
    case r'seller_phone':
      return Enum$SellersScalarFieldEnum.seller_phone;
    case r'picture':
      return Enum$SellersScalarFieldEnum.picture;
    default:
      return Enum$SellersScalarFieldEnum.$unknown;
  }
}

enum Enum$SizesScalarFieldEnum { id, size, $unknown }

String toJson$Enum$SizesScalarFieldEnum(Enum$SizesScalarFieldEnum e) {
  switch (e) {
    case Enum$SizesScalarFieldEnum.id:
      return r'id';
    case Enum$SizesScalarFieldEnum.size:
      return r'size';
    case Enum$SizesScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$SizesScalarFieldEnum fromJson$Enum$SizesScalarFieldEnum(String value) {
  switch (value) {
    case r'id':
      return Enum$SizesScalarFieldEnum.id;
    case r'size':
      return Enum$SizesScalarFieldEnum.size;
    default:
      return Enum$SizesScalarFieldEnum.$unknown;
  }
}

enum Enum$TransactionStatusScalarFieldEnum {
  transaction_status_id,
  name,
  description,
  $unknown
}

String toJson$Enum$TransactionStatusScalarFieldEnum(
    Enum$TransactionStatusScalarFieldEnum e) {
  switch (e) {
    case Enum$TransactionStatusScalarFieldEnum.transaction_status_id:
      return r'transaction_status_id';
    case Enum$TransactionStatusScalarFieldEnum.name:
      return r'name';
    case Enum$TransactionStatusScalarFieldEnum.description:
      return r'description';
    case Enum$TransactionStatusScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionStatusScalarFieldEnum
    fromJson$Enum$TransactionStatusScalarFieldEnum(String value) {
  switch (value) {
    case r'transaction_status_id':
      return Enum$TransactionStatusScalarFieldEnum.transaction_status_id;
    case r'name':
      return Enum$TransactionStatusScalarFieldEnum.name;
    case r'description':
      return Enum$TransactionStatusScalarFieldEnum.description;
    default:
      return Enum$TransactionStatusScalarFieldEnum.$unknown;
  }
}

enum Enum$TransactionTypesScalarFieldEnum {
  transaction_type_id,
  type_name,
  description,
  $unknown
}

String toJson$Enum$TransactionTypesScalarFieldEnum(
    Enum$TransactionTypesScalarFieldEnum e) {
  switch (e) {
    case Enum$TransactionTypesScalarFieldEnum.transaction_type_id:
      return r'transaction_type_id';
    case Enum$TransactionTypesScalarFieldEnum.type_name:
      return r'type_name';
    case Enum$TransactionTypesScalarFieldEnum.description:
      return r'description';
    case Enum$TransactionTypesScalarFieldEnum.$unknown:
      return r'$unknown';
  }
}

Enum$TransactionTypesScalarFieldEnum
    fromJson$Enum$TransactionTypesScalarFieldEnum(String value) {
  switch (value) {
    case r'transaction_type_id':
      return Enum$TransactionTypesScalarFieldEnum.transaction_type_id;
    case r'type_name':
      return Enum$TransactionTypesScalarFieldEnum.type_name;
    case r'description':
      return Enum$TransactionTypesScalarFieldEnum.description;
    default:
      return Enum$TransactionTypesScalarFieldEnum.$unknown;
  }
}

const possibleTypesMap = <String, Set<String>>{};
